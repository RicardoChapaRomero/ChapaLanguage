Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT

Grammar

Rule 0     S' -> PROGRAMA
Rule 1     PROGRAMA -> PROGRAM V M S END
Rule 2     V -> DIM setType Idv AS T Arr
Rule 3     V -> empty
Rule 4     Arr -> OPENBRACKET EA CLOSINGBRACKET Arr
Rule 5     Arr -> OPENBRACKET ID CLOSINGBRACKET Arr
Rule 6     Arr -> empty
Rule 7     T -> INT
Rule 8     T -> FLOAT
Rule 9     T -> WORD
Rule 10    S -> SUBPROCEDURE ID TWOPOINTS M RETURN S
Rule 11    S -> empty
Rule 12    M -> F M
Rule 13    M -> empty
Rule 14    F -> E F
Rule 15    F -> empty
Rule 16    E -> LET setType Idv EQUALS Ex
Rule 17    E -> DIM setType Idv AS T Arr
Rule 18    E -> IF EL THEN F Esf EIF
Rule 19    E -> FOR ID EQUALS EA TO Ex F NEXT ID
Rule 20    E -> WHILE OPENPAR EL CLOSINGPAR F WEND
Rule 21    E -> GOSUB ID
Rule 22    E -> INPUT ES COMA IDEx
Rule 23    E -> PRINT Ex
Rule 24    Idv -> ID COMA Idv
Rule 25    Idv -> ID
Rule 26    setType -> <empty>
Rule 27    Esf -> ELSE F
Rule 28    Esf -> empty
Rule 29    IDEx -> ID
Rule 30    IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET
Rule 31    Ex -> EA
Rule 32    Ex -> ES
Rule 33    Ex -> EL
Rule 34    Ex -> ID
Rule 35    ES -> WORDVAL
Rule 36    EA -> P PLUS EA
Rule 37    EA -> P MINUS EA
Rule 38    EA -> P
Rule 39    P -> N MULTIPLY P
Rule 40    P -> N DIVIDE P
Rule 41    P -> N
Rule 42    N -> cte
Rule 43    N -> ID
Rule 44    N -> OPENPAR EA CLOSINGPAR
Rule 45    N -> ID OPENBRACKET INTVAL CLOSINGBRACKET
Rule 46    N -> ID OPENBRACKET setType Idv CLOSINGBRACKET
Rule 47    cte -> INTVAL
Rule 48    cte -> FLOATVAL
Rule 49    EL -> TRUE
Rule 50    EL -> FALSE
Rule 51    EL -> OPENPAR O CLOSINGPAR Olt
Rule 52    Olt -> OL OPENPAR O CLOSINGPAR Olt
Rule 53    Olt -> empty
Rule 54    OL -> AND
Rule 55    OL -> OR
Rule 56    OL -> NOT
Rule 57    O -> WORD EQUALTO WORD
Rule 58    O -> EA OPR EA
Rule 59    O -> ID OPR ID
Rule 60    O -> ID OPR EA
Rule 61    O -> EA OPR ID
Rule 62    OPR -> EQUALTO
Rule 63    OPR -> GREATHER
Rule 64    OPR -> GREATHEREQUAL
Rule 65    OPR -> SMALLER
Rule 66    OPR -> SMALLEREQUAL
Rule 67    OPR -> NOTEQUAL
Rule 68    empty -> <empty>

Terminals, with rules where they appear

AND                  : 54
AS                   : 2 17
CLOSINGBRACKET       : 4 5 30 45 46
CLOSINGPAR           : 20 44 51 52
COMA                 : 22 24
COMMENT              : 
DIM                  : 2 17
DIVIDE               : 40
EIF                  : 18
ELSE                 : 27
END                  : 1
EQUALS               : 16 19
EQUALTO              : 57 62
FALSE                : 50
FLOAT                : 8
FLOATVAL             : 48
FOR                  : 19
GOSUB                : 21
GREATHER             : 63
GREATHEREQUAL        : 64
ID                   : 5 10 19 19 21 24 25 29 30 34 43 45 46 59 59 60 61
IF                   : 18
INPUT                : 22
INT                  : 7
INTVAL               : 45 47
LET                  : 16
MINUS                : 37
MULTIPLY             : 39
NEXT                 : 19
NOT                  : 56
NOTEQUAL             : 67
OPENBRACKET          : 4 5 30 45 46
OPENPAR              : 20 44 51 52
OR                   : 55
PLUS                 : 36
PRINT                : 23
PROGRAM              : 1
RETURN               : 10
SMALLER              : 65
SMALLEREQUAL         : 66
SUBPROCEDURE         : 10
THEN                 : 18
TO                   : 19
TRUE                 : 49
TWOPOINTS            : 10
WEND                 : 20
WHILE                : 20
WORD                 : 9 57 57
WORDVAL              : 35
error                : 

Nonterminals, with rules where they appear

Arr                  : 2 4 5 17
E                    : 14
EA                   : 4 19 31 36 37 44 58 58 60 61
EL                   : 18 20 33
ES                   : 22 32
Esf                  : 18
Ex                   : 16 19 23
F                    : 12 14 18 19 20 27
IDEx                 : 22
Idv                  : 2 16 17 24 30 46
M                    : 1 10 12
N                    : 39 40 41
O                    : 51 52
OL                   : 52
OPR                  : 58 59 60 61
Olt                  : 51 52
P                    : 36 37 38 39 40
PROGRAMA             : 0
S                    : 1 10
T                    : 2 17
V                    : 1
cte                  : 42
empty                : 3 6 11 13 15 28 53
setType              : 2 16 17 30 46

Parsing method: LALR

state 0

    (0) S' -> . PROGRAMA
    (1) PROGRAMA -> . PROGRAM V M S END

    PROGRAM         shift and go to state 2

    PROGRAMA                       shift and go to state 1

state 1

    (0) S' -> PROGRAMA .



state 2

    (1) PROGRAMA -> PROGRAM . V M S END
    (2) V -> . DIM setType Idv AS T Arr
    (3) V -> . empty
    (68) empty -> .

  ! shift/reduce conflict for DIM resolved as shift
    DIM             shift and go to state 4
    LET             reduce using rule 68 (empty -> .)
    IF              reduce using rule 68 (empty -> .)
    FOR             reduce using rule 68 (empty -> .)
    WHILE           reduce using rule 68 (empty -> .)
    GOSUB           reduce using rule 68 (empty -> .)
    INPUT           reduce using rule 68 (empty -> .)
    PRINT           reduce using rule 68 (empty -> .)
    SUBPROCEDURE    reduce using rule 68 (empty -> .)
    END             reduce using rule 68 (empty -> .)

  ! DIM             [ reduce using rule 68 (empty -> .) ]

    V                              shift and go to state 3
    empty                          shift and go to state 5

state 3

    (1) PROGRAMA -> PROGRAM V . M S END
    (12) M -> . F M
    (13) M -> . empty
    (14) F -> . E F
    (15) F -> . empty
    (68) empty -> .
    (16) E -> . LET setType Idv EQUALS Ex
    (17) E -> . DIM setType Idv AS T Arr
    (18) E -> . IF EL THEN F Esf EIF
    (19) E -> . FOR ID EQUALS EA TO Ex F NEXT ID
    (20) E -> . WHILE OPENPAR EL CLOSINGPAR F WEND
    (21) E -> . GOSUB ID
    (22) E -> . INPUT ES COMA IDEx
    (23) E -> . PRINT Ex

  ! shift/reduce conflict for LET resolved as shift
  ! shift/reduce conflict for DIM resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for GOSUB resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
    SUBPROCEDURE    reduce using rule 68 (empty -> .)
    END             reduce using rule 68 (empty -> .)
    LET             shift and go to state 10
    DIM             shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    GOSUB           shift and go to state 15
    INPUT           shift and go to state 16
    PRINT           shift and go to state 17

  ! LET             [ reduce using rule 68 (empty -> .) ]
  ! DIM             [ reduce using rule 68 (empty -> .) ]
  ! IF              [ reduce using rule 68 (empty -> .) ]
  ! FOR             [ reduce using rule 68 (empty -> .) ]
  ! WHILE           [ reduce using rule 68 (empty -> .) ]
  ! GOSUB           [ reduce using rule 68 (empty -> .) ]
  ! INPUT           [ reduce using rule 68 (empty -> .) ]
  ! PRINT           [ reduce using rule 68 (empty -> .) ]

    M                              shift and go to state 6
    F                              shift and go to state 7
    empty                          shift and go to state 8
    E                              shift and go to state 9

state 4

    (2) V -> DIM . setType Idv AS T Arr
    (26) setType -> .

    ID              reduce using rule 26 (setType -> .)

    setType                        shift and go to state 18

state 5

    (3) V -> empty .

    LET             reduce using rule 3 (V -> empty .)
    DIM             reduce using rule 3 (V -> empty .)
    IF              reduce using rule 3 (V -> empty .)
    FOR             reduce using rule 3 (V -> empty .)
    WHILE           reduce using rule 3 (V -> empty .)
    GOSUB           reduce using rule 3 (V -> empty .)
    INPUT           reduce using rule 3 (V -> empty .)
    PRINT           reduce using rule 3 (V -> empty .)
    SUBPROCEDURE    reduce using rule 3 (V -> empty .)
    END             reduce using rule 3 (V -> empty .)


state 6

    (1) PROGRAMA -> PROGRAM V M . S END
    (10) S -> . SUBPROCEDURE ID TWOPOINTS M RETURN S
    (11) S -> . empty
    (68) empty -> .

    SUBPROCEDURE    shift and go to state 20
    END             reduce using rule 68 (empty -> .)

    S                              shift and go to state 19
    empty                          shift and go to state 21

state 7

    (12) M -> F . M
    (12) M -> . F M
    (13) M -> . empty
    (14) F -> . E F
    (15) F -> . empty
    (68) empty -> .
    (16) E -> . LET setType Idv EQUALS Ex
    (17) E -> . DIM setType Idv AS T Arr
    (18) E -> . IF EL THEN F Esf EIF
    (19) E -> . FOR ID EQUALS EA TO Ex F NEXT ID
    (20) E -> . WHILE OPENPAR EL CLOSINGPAR F WEND
    (21) E -> . GOSUB ID
    (22) E -> . INPUT ES COMA IDEx
    (23) E -> . PRINT Ex

  ! shift/reduce conflict for LET resolved as shift
  ! shift/reduce conflict for DIM resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for GOSUB resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
    SUBPROCEDURE    reduce using rule 68 (empty -> .)
    END             reduce using rule 68 (empty -> .)
    RETURN          reduce using rule 68 (empty -> .)
    LET             shift and go to state 10
    DIM             shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    GOSUB           shift and go to state 15
    INPUT           shift and go to state 16
    PRINT           shift and go to state 17

  ! LET             [ reduce using rule 68 (empty -> .) ]
  ! DIM             [ reduce using rule 68 (empty -> .) ]
  ! IF              [ reduce using rule 68 (empty -> .) ]
  ! FOR             [ reduce using rule 68 (empty -> .) ]
  ! WHILE           [ reduce using rule 68 (empty -> .) ]
  ! GOSUB           [ reduce using rule 68 (empty -> .) ]
  ! INPUT           [ reduce using rule 68 (empty -> .) ]
  ! PRINT           [ reduce using rule 68 (empty -> .) ]

    F                              shift and go to state 7
    M                              shift and go to state 22
    empty                          shift and go to state 8
    E                              shift and go to state 9

state 8

    (13) M -> empty .
    (15) F -> empty .

  ! reduce/reduce conflict for SUBPROCEDURE resolved using rule 13 (M -> empty .)
  ! reduce/reduce conflict for END resolved using rule 13 (M -> empty .)
  ! reduce/reduce conflict for RETURN resolved using rule 13 (M -> empty .)
    SUBPROCEDURE    reduce using rule 13 (M -> empty .)
    END             reduce using rule 13 (M -> empty .)
    RETURN          reduce using rule 13 (M -> empty .)
    LET             reduce using rule 15 (F -> empty .)
    DIM             reduce using rule 15 (F -> empty .)
    IF              reduce using rule 15 (F -> empty .)
    FOR             reduce using rule 15 (F -> empty .)
    WHILE           reduce using rule 15 (F -> empty .)
    GOSUB           reduce using rule 15 (F -> empty .)
    INPUT           reduce using rule 15 (F -> empty .)
    PRINT           reduce using rule 15 (F -> empty .)

  ! SUBPROCEDURE    [ reduce using rule 15 (F -> empty .) ]
  ! END             [ reduce using rule 15 (F -> empty .) ]
  ! RETURN          [ reduce using rule 15 (F -> empty .) ]


state 9

    (14) F -> E . F
    (14) F -> . E F
    (15) F -> . empty
    (16) E -> . LET setType Idv EQUALS Ex
    (17) E -> . DIM setType Idv AS T Arr
    (18) E -> . IF EL THEN F Esf EIF
    (19) E -> . FOR ID EQUALS EA TO Ex F NEXT ID
    (20) E -> . WHILE OPENPAR EL CLOSINGPAR F WEND
    (21) E -> . GOSUB ID
    (22) E -> . INPUT ES COMA IDEx
    (23) E -> . PRINT Ex
    (68) empty -> .

  ! shift/reduce conflict for LET resolved as shift
  ! shift/reduce conflict for DIM resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for GOSUB resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
    LET             shift and go to state 10
    DIM             shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    GOSUB           shift and go to state 15
    INPUT           shift and go to state 16
    PRINT           shift and go to state 17
    SUBPROCEDURE    reduce using rule 68 (empty -> .)
    END             reduce using rule 68 (empty -> .)
    RETURN          reduce using rule 68 (empty -> .)
    ELSE            reduce using rule 68 (empty -> .)
    EIF             reduce using rule 68 (empty -> .)
    WEND            reduce using rule 68 (empty -> .)
    NEXT            reduce using rule 68 (empty -> .)

  ! LET             [ reduce using rule 68 (empty -> .) ]
  ! DIM             [ reduce using rule 68 (empty -> .) ]
  ! IF              [ reduce using rule 68 (empty -> .) ]
  ! FOR             [ reduce using rule 68 (empty -> .) ]
  ! WHILE           [ reduce using rule 68 (empty -> .) ]
  ! GOSUB           [ reduce using rule 68 (empty -> .) ]
  ! INPUT           [ reduce using rule 68 (empty -> .) ]
  ! PRINT           [ reduce using rule 68 (empty -> .) ]

    E                              shift and go to state 9
    F                              shift and go to state 23
    empty                          shift and go to state 24

state 10

    (16) E -> LET . setType Idv EQUALS Ex
    (26) setType -> .

    ID              reduce using rule 26 (setType -> .)

    setType                        shift and go to state 25

state 11

    (17) E -> DIM . setType Idv AS T Arr
    (26) setType -> .

    ID              reduce using rule 26 (setType -> .)

    setType                        shift and go to state 26

state 12

    (18) E -> IF . EL THEN F Esf EIF
    (49) EL -> . TRUE
    (50) EL -> . FALSE
    (51) EL -> . OPENPAR O CLOSINGPAR Olt

    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    OPENPAR         shift and go to state 30

    EL                             shift and go to state 27

state 13

    (19) E -> FOR . ID EQUALS EA TO Ex F NEXT ID

    ID              shift and go to state 31


state 14

    (20) E -> WHILE . OPENPAR EL CLOSINGPAR F WEND

    OPENPAR         shift and go to state 32


state 15

    (21) E -> GOSUB . ID

    ID              shift and go to state 33


state 16

    (22) E -> INPUT . ES COMA IDEx
    (35) ES -> . WORDVAL

    WORDVAL         shift and go to state 35

    ES                             shift and go to state 34

state 17

    (23) E -> PRINT . Ex
    (31) Ex -> . EA
    (32) Ex -> . ES
    (33) Ex -> . EL
    (34) Ex -> . ID
    (36) EA -> . P PLUS EA
    (37) EA -> . P MINUS EA
    (38) EA -> . P
    (35) ES -> . WORDVAL
    (49) EL -> . TRUE
    (50) EL -> . FALSE
    (51) EL -> . OPENPAR O CLOSINGPAR Olt
    (39) P -> . N MULTIPLY P
    (40) P -> . N DIVIDE P
    (41) P -> . N
    (42) N -> . cte
    (43) N -> . ID
    (44) N -> . OPENPAR EA CLOSINGPAR
    (45) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (46) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (47) cte -> . INTVAL
    (48) cte -> . FLOATVAL

    ID              shift and go to state 40
    WORDVAL         shift and go to state 35
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    OPENPAR         shift and go to state 42
    INTVAL          shift and go to state 45
    FLOATVAL        shift and go to state 46

    Ex                             shift and go to state 36
    EA                             shift and go to state 37
    ES                             shift and go to state 38
    EL                             shift and go to state 39
    P                              shift and go to state 41
    N                              shift and go to state 43
    cte                            shift and go to state 44

state 18

    (2) V -> DIM setType . Idv AS T Arr
    (24) Idv -> . ID COMA Idv
    (25) Idv -> . ID

    ID              shift and go to state 48

    Idv                            shift and go to state 47

state 19

    (1) PROGRAMA -> PROGRAM V M S . END

    END             shift and go to state 49


state 20

    (10) S -> SUBPROCEDURE . ID TWOPOINTS M RETURN S

    ID              shift and go to state 50


state 21

    (11) S -> empty .

    END             reduce using rule 11 (S -> empty .)


state 22

    (12) M -> F M .

    SUBPROCEDURE    reduce using rule 12 (M -> F M .)
    END             reduce using rule 12 (M -> F M .)
    RETURN          reduce using rule 12 (M -> F M .)


state 23

    (14) F -> E F .

    LET             reduce using rule 14 (F -> E F .)
    DIM             reduce using rule 14 (F -> E F .)
    IF              reduce using rule 14 (F -> E F .)
    FOR             reduce using rule 14 (F -> E F .)
    WHILE           reduce using rule 14 (F -> E F .)
    GOSUB           reduce using rule 14 (F -> E F .)
    INPUT           reduce using rule 14 (F -> E F .)
    PRINT           reduce using rule 14 (F -> E F .)
    SUBPROCEDURE    reduce using rule 14 (F -> E F .)
    END             reduce using rule 14 (F -> E F .)
    RETURN          reduce using rule 14 (F -> E F .)
    ELSE            reduce using rule 14 (F -> E F .)
    EIF             reduce using rule 14 (F -> E F .)
    WEND            reduce using rule 14 (F -> E F .)
    NEXT            reduce using rule 14 (F -> E F .)


state 24

    (15) F -> empty .

    LET             reduce using rule 15 (F -> empty .)
    DIM             reduce using rule 15 (F -> empty .)
    IF              reduce using rule 15 (F -> empty .)
    FOR             reduce using rule 15 (F -> empty .)
    WHILE           reduce using rule 15 (F -> empty .)
    GOSUB           reduce using rule 15 (F -> empty .)
    INPUT           reduce using rule 15 (F -> empty .)
    PRINT           reduce using rule 15 (F -> empty .)
    SUBPROCEDURE    reduce using rule 15 (F -> empty .)
    END             reduce using rule 15 (F -> empty .)
    RETURN          reduce using rule 15 (F -> empty .)
    ELSE            reduce using rule 15 (F -> empty .)
    EIF             reduce using rule 15 (F -> empty .)
    WEND            reduce using rule 15 (F -> empty .)
    NEXT            reduce using rule 15 (F -> empty .)


state 25

    (16) E -> LET setType . Idv EQUALS Ex
    (24) Idv -> . ID COMA Idv
    (25) Idv -> . ID

    ID              shift and go to state 48

    Idv                            shift and go to state 51

state 26

    (17) E -> DIM setType . Idv AS T Arr
    (24) Idv -> . ID COMA Idv
    (25) Idv -> . ID

    ID              shift and go to state 48

    Idv                            shift and go to state 52

state 27

    (18) E -> IF EL . THEN F Esf EIF

    THEN            shift and go to state 53


state 28

    (49) EL -> TRUE .

    THEN            reduce using rule 49 (EL -> TRUE .)
    LET             reduce using rule 49 (EL -> TRUE .)
    DIM             reduce using rule 49 (EL -> TRUE .)
    IF              reduce using rule 49 (EL -> TRUE .)
    FOR             reduce using rule 49 (EL -> TRUE .)
    WHILE           reduce using rule 49 (EL -> TRUE .)
    GOSUB           reduce using rule 49 (EL -> TRUE .)
    INPUT           reduce using rule 49 (EL -> TRUE .)
    PRINT           reduce using rule 49 (EL -> TRUE .)
    SUBPROCEDURE    reduce using rule 49 (EL -> TRUE .)
    END             reduce using rule 49 (EL -> TRUE .)
    RETURN          reduce using rule 49 (EL -> TRUE .)
    ELSE            reduce using rule 49 (EL -> TRUE .)
    EIF             reduce using rule 49 (EL -> TRUE .)
    WEND            reduce using rule 49 (EL -> TRUE .)
    NEXT            reduce using rule 49 (EL -> TRUE .)
    CLOSINGPAR      reduce using rule 49 (EL -> TRUE .)


state 29

    (50) EL -> FALSE .

    THEN            reduce using rule 50 (EL -> FALSE .)
    LET             reduce using rule 50 (EL -> FALSE .)
    DIM             reduce using rule 50 (EL -> FALSE .)
    IF              reduce using rule 50 (EL -> FALSE .)
    FOR             reduce using rule 50 (EL -> FALSE .)
    WHILE           reduce using rule 50 (EL -> FALSE .)
    GOSUB           reduce using rule 50 (EL -> FALSE .)
    INPUT           reduce using rule 50 (EL -> FALSE .)
    PRINT           reduce using rule 50 (EL -> FALSE .)
    SUBPROCEDURE    reduce using rule 50 (EL -> FALSE .)
    END             reduce using rule 50 (EL -> FALSE .)
    RETURN          reduce using rule 50 (EL -> FALSE .)
    ELSE            reduce using rule 50 (EL -> FALSE .)
    EIF             reduce using rule 50 (EL -> FALSE .)
    WEND            reduce using rule 50 (EL -> FALSE .)
    NEXT            reduce using rule 50 (EL -> FALSE .)
    CLOSINGPAR      reduce using rule 50 (EL -> FALSE .)


state 30

    (51) EL -> OPENPAR . O CLOSINGPAR Olt
    (57) O -> . WORD EQUALTO WORD
    (58) O -> . EA OPR EA
    (59) O -> . ID OPR ID
    (60) O -> . ID OPR EA
    (61) O -> . EA OPR ID
    (36) EA -> . P PLUS EA
    (37) EA -> . P MINUS EA
    (38) EA -> . P
    (39) P -> . N MULTIPLY P
    (40) P -> . N DIVIDE P
    (41) P -> . N
    (42) N -> . cte
    (43) N -> . ID
    (44) N -> . OPENPAR EA CLOSINGPAR
    (45) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (46) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (47) cte -> . INTVAL
    (48) cte -> . FLOATVAL

    WORD            shift and go to state 56
    ID              shift and go to state 58
    OPENPAR         shift and go to state 54
    INTVAL          shift and go to state 45
    FLOATVAL        shift and go to state 46

    O                              shift and go to state 55
    EA                             shift and go to state 57
    P                              shift and go to state 41
    N                              shift and go to state 43
    cte                            shift and go to state 44

state 31

    (19) E -> FOR ID . EQUALS EA TO Ex F NEXT ID

    EQUALS          shift and go to state 59


state 32

    (20) E -> WHILE OPENPAR . EL CLOSINGPAR F WEND
    (49) EL -> . TRUE
    (50) EL -> . FALSE
    (51) EL -> . OPENPAR O CLOSINGPAR Olt

    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    OPENPAR         shift and go to state 30

    EL                             shift and go to state 60

state 33

    (21) E -> GOSUB ID .

    LET             reduce using rule 21 (E -> GOSUB ID .)
    DIM             reduce using rule 21 (E -> GOSUB ID .)
    IF              reduce using rule 21 (E -> GOSUB ID .)
    FOR             reduce using rule 21 (E -> GOSUB ID .)
    WHILE           reduce using rule 21 (E -> GOSUB ID .)
    GOSUB           reduce using rule 21 (E -> GOSUB ID .)
    INPUT           reduce using rule 21 (E -> GOSUB ID .)
    PRINT           reduce using rule 21 (E -> GOSUB ID .)
    SUBPROCEDURE    reduce using rule 21 (E -> GOSUB ID .)
    END             reduce using rule 21 (E -> GOSUB ID .)
    RETURN          reduce using rule 21 (E -> GOSUB ID .)
    ELSE            reduce using rule 21 (E -> GOSUB ID .)
    EIF             reduce using rule 21 (E -> GOSUB ID .)
    WEND            reduce using rule 21 (E -> GOSUB ID .)
    NEXT            reduce using rule 21 (E -> GOSUB ID .)


state 34

    (22) E -> INPUT ES . COMA IDEx

    COMA            shift and go to state 61


state 35

    (35) ES -> WORDVAL .

    COMA            reduce using rule 35 (ES -> WORDVAL .)
    LET             reduce using rule 35 (ES -> WORDVAL .)
    DIM             reduce using rule 35 (ES -> WORDVAL .)
    IF              reduce using rule 35 (ES -> WORDVAL .)
    FOR             reduce using rule 35 (ES -> WORDVAL .)
    WHILE           reduce using rule 35 (ES -> WORDVAL .)
    GOSUB           reduce using rule 35 (ES -> WORDVAL .)
    INPUT           reduce using rule 35 (ES -> WORDVAL .)
    PRINT           reduce using rule 35 (ES -> WORDVAL .)
    SUBPROCEDURE    reduce using rule 35 (ES -> WORDVAL .)
    END             reduce using rule 35 (ES -> WORDVAL .)
    RETURN          reduce using rule 35 (ES -> WORDVAL .)
    ELSE            reduce using rule 35 (ES -> WORDVAL .)
    EIF             reduce using rule 35 (ES -> WORDVAL .)
    WEND            reduce using rule 35 (ES -> WORDVAL .)
    NEXT            reduce using rule 35 (ES -> WORDVAL .)


state 36

    (23) E -> PRINT Ex .

    LET             reduce using rule 23 (E -> PRINT Ex .)
    DIM             reduce using rule 23 (E -> PRINT Ex .)
    IF              reduce using rule 23 (E -> PRINT Ex .)
    FOR             reduce using rule 23 (E -> PRINT Ex .)
    WHILE           reduce using rule 23 (E -> PRINT Ex .)
    GOSUB           reduce using rule 23 (E -> PRINT Ex .)
    INPUT           reduce using rule 23 (E -> PRINT Ex .)
    PRINT           reduce using rule 23 (E -> PRINT Ex .)
    SUBPROCEDURE    reduce using rule 23 (E -> PRINT Ex .)
    END             reduce using rule 23 (E -> PRINT Ex .)
    RETURN          reduce using rule 23 (E -> PRINT Ex .)
    ELSE            reduce using rule 23 (E -> PRINT Ex .)
    EIF             reduce using rule 23 (E -> PRINT Ex .)
    WEND            reduce using rule 23 (E -> PRINT Ex .)
    NEXT            reduce using rule 23 (E -> PRINT Ex .)


state 37

    (31) Ex -> EA .

    LET             reduce using rule 31 (Ex -> EA .)
    DIM             reduce using rule 31 (Ex -> EA .)
    IF              reduce using rule 31 (Ex -> EA .)
    FOR             reduce using rule 31 (Ex -> EA .)
    WHILE           reduce using rule 31 (Ex -> EA .)
    GOSUB           reduce using rule 31 (Ex -> EA .)
    INPUT           reduce using rule 31 (Ex -> EA .)
    PRINT           reduce using rule 31 (Ex -> EA .)
    SUBPROCEDURE    reduce using rule 31 (Ex -> EA .)
    END             reduce using rule 31 (Ex -> EA .)
    RETURN          reduce using rule 31 (Ex -> EA .)
    ELSE            reduce using rule 31 (Ex -> EA .)
    EIF             reduce using rule 31 (Ex -> EA .)
    WEND            reduce using rule 31 (Ex -> EA .)
    NEXT            reduce using rule 31 (Ex -> EA .)


state 38

    (32) Ex -> ES .

    LET             reduce using rule 32 (Ex -> ES .)
    DIM             reduce using rule 32 (Ex -> ES .)
    IF              reduce using rule 32 (Ex -> ES .)
    FOR             reduce using rule 32 (Ex -> ES .)
    WHILE           reduce using rule 32 (Ex -> ES .)
    GOSUB           reduce using rule 32 (Ex -> ES .)
    INPUT           reduce using rule 32 (Ex -> ES .)
    PRINT           reduce using rule 32 (Ex -> ES .)
    SUBPROCEDURE    reduce using rule 32 (Ex -> ES .)
    END             reduce using rule 32 (Ex -> ES .)
    RETURN          reduce using rule 32 (Ex -> ES .)
    ELSE            reduce using rule 32 (Ex -> ES .)
    EIF             reduce using rule 32 (Ex -> ES .)
    WEND            reduce using rule 32 (Ex -> ES .)
    NEXT            reduce using rule 32 (Ex -> ES .)


state 39

    (33) Ex -> EL .

    LET             reduce using rule 33 (Ex -> EL .)
    DIM             reduce using rule 33 (Ex -> EL .)
    IF              reduce using rule 33 (Ex -> EL .)
    FOR             reduce using rule 33 (Ex -> EL .)
    WHILE           reduce using rule 33 (Ex -> EL .)
    GOSUB           reduce using rule 33 (Ex -> EL .)
    INPUT           reduce using rule 33 (Ex -> EL .)
    PRINT           reduce using rule 33 (Ex -> EL .)
    SUBPROCEDURE    reduce using rule 33 (Ex -> EL .)
    END             reduce using rule 33 (Ex -> EL .)
    RETURN          reduce using rule 33 (Ex -> EL .)
    ELSE            reduce using rule 33 (Ex -> EL .)
    EIF             reduce using rule 33 (Ex -> EL .)
    WEND            reduce using rule 33 (Ex -> EL .)
    NEXT            reduce using rule 33 (Ex -> EL .)


state 40

    (34) Ex -> ID .
    (43) N -> ID .
    (45) N -> ID . OPENBRACKET INTVAL CLOSINGBRACKET
    (46) N -> ID . OPENBRACKET setType Idv CLOSINGBRACKET

  ! reduce/reduce conflict for LET resolved using rule 34 (Ex -> ID .)
  ! reduce/reduce conflict for DIM resolved using rule 34 (Ex -> ID .)
  ! reduce/reduce conflict for IF resolved using rule 34 (Ex -> ID .)
  ! reduce/reduce conflict for FOR resolved using rule 34 (Ex -> ID .)
  ! reduce/reduce conflict for WHILE resolved using rule 34 (Ex -> ID .)
  ! reduce/reduce conflict for GOSUB resolved using rule 34 (Ex -> ID .)
  ! reduce/reduce conflict for INPUT resolved using rule 34 (Ex -> ID .)
  ! reduce/reduce conflict for PRINT resolved using rule 34 (Ex -> ID .)
  ! reduce/reduce conflict for SUBPROCEDURE resolved using rule 34 (Ex -> ID .)
  ! reduce/reduce conflict for END resolved using rule 34 (Ex -> ID .)
  ! reduce/reduce conflict for RETURN resolved using rule 34 (Ex -> ID .)
  ! reduce/reduce conflict for ELSE resolved using rule 34 (Ex -> ID .)
  ! reduce/reduce conflict for EIF resolved using rule 34 (Ex -> ID .)
  ! reduce/reduce conflict for WEND resolved using rule 34 (Ex -> ID .)
  ! reduce/reduce conflict for NEXT resolved using rule 34 (Ex -> ID .)
    LET             reduce using rule 34 (Ex -> ID .)
    DIM             reduce using rule 34 (Ex -> ID .)
    IF              reduce using rule 34 (Ex -> ID .)
    FOR             reduce using rule 34 (Ex -> ID .)
    WHILE           reduce using rule 34 (Ex -> ID .)
    GOSUB           reduce using rule 34 (Ex -> ID .)
    INPUT           reduce using rule 34 (Ex -> ID .)
    PRINT           reduce using rule 34 (Ex -> ID .)
    SUBPROCEDURE    reduce using rule 34 (Ex -> ID .)
    END             reduce using rule 34 (Ex -> ID .)
    RETURN          reduce using rule 34 (Ex -> ID .)
    ELSE            reduce using rule 34 (Ex -> ID .)
    EIF             reduce using rule 34 (Ex -> ID .)
    WEND            reduce using rule 34 (Ex -> ID .)
    NEXT            reduce using rule 34 (Ex -> ID .)
    MULTIPLY        reduce using rule 43 (N -> ID .)
    DIVIDE          reduce using rule 43 (N -> ID .)
    PLUS            reduce using rule 43 (N -> ID .)
    MINUS           reduce using rule 43 (N -> ID .)
    OPENBRACKET     shift and go to state 62

  ! LET             [ reduce using rule 43 (N -> ID .) ]
  ! DIM             [ reduce using rule 43 (N -> ID .) ]
  ! IF              [ reduce using rule 43 (N -> ID .) ]
  ! FOR             [ reduce using rule 43 (N -> ID .) ]
  ! WHILE           [ reduce using rule 43 (N -> ID .) ]
  ! GOSUB           [ reduce using rule 43 (N -> ID .) ]
  ! INPUT           [ reduce using rule 43 (N -> ID .) ]
  ! PRINT           [ reduce using rule 43 (N -> ID .) ]
  ! SUBPROCEDURE    [ reduce using rule 43 (N -> ID .) ]
  ! END             [ reduce using rule 43 (N -> ID .) ]
  ! RETURN          [ reduce using rule 43 (N -> ID .) ]
  ! ELSE            [ reduce using rule 43 (N -> ID .) ]
  ! EIF             [ reduce using rule 43 (N -> ID .) ]
  ! WEND            [ reduce using rule 43 (N -> ID .) ]
  ! NEXT            [ reduce using rule 43 (N -> ID .) ]


state 41

    (36) EA -> P . PLUS EA
    (37) EA -> P . MINUS EA
    (38) EA -> P .

    PLUS            shift and go to state 63
    MINUS           shift and go to state 64
    LET             reduce using rule 38 (EA -> P .)
    DIM             reduce using rule 38 (EA -> P .)
    IF              reduce using rule 38 (EA -> P .)
    FOR             reduce using rule 38 (EA -> P .)
    WHILE           reduce using rule 38 (EA -> P .)
    GOSUB           reduce using rule 38 (EA -> P .)
    INPUT           reduce using rule 38 (EA -> P .)
    PRINT           reduce using rule 38 (EA -> P .)
    SUBPROCEDURE    reduce using rule 38 (EA -> P .)
    END             reduce using rule 38 (EA -> P .)
    RETURN          reduce using rule 38 (EA -> P .)
    ELSE            reduce using rule 38 (EA -> P .)
    EIF             reduce using rule 38 (EA -> P .)
    WEND            reduce using rule 38 (EA -> P .)
    NEXT            reduce using rule 38 (EA -> P .)
    EQUALTO         reduce using rule 38 (EA -> P .)
    GREATHER        reduce using rule 38 (EA -> P .)
    GREATHEREQUAL   reduce using rule 38 (EA -> P .)
    SMALLER         reduce using rule 38 (EA -> P .)
    SMALLEREQUAL    reduce using rule 38 (EA -> P .)
    NOTEQUAL        reduce using rule 38 (EA -> P .)
    CLOSINGPAR      reduce using rule 38 (EA -> P .)
    TO              reduce using rule 38 (EA -> P .)
    CLOSINGBRACKET  reduce using rule 38 (EA -> P .)


state 42

    (51) EL -> OPENPAR . O CLOSINGPAR Olt
    (44) N -> OPENPAR . EA CLOSINGPAR
    (57) O -> . WORD EQUALTO WORD
    (58) O -> . EA OPR EA
    (59) O -> . ID OPR ID
    (60) O -> . ID OPR EA
    (61) O -> . EA OPR ID
    (36) EA -> . P PLUS EA
    (37) EA -> . P MINUS EA
    (38) EA -> . P
    (39) P -> . N MULTIPLY P
    (40) P -> . N DIVIDE P
    (41) P -> . N
    (42) N -> . cte
    (43) N -> . ID
    (44) N -> . OPENPAR EA CLOSINGPAR
    (45) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (46) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (47) cte -> . INTVAL
    (48) cte -> . FLOATVAL

    WORD            shift and go to state 56
    ID              shift and go to state 58
    OPENPAR         shift and go to state 54
    INTVAL          shift and go to state 45
    FLOATVAL        shift and go to state 46

    O                              shift and go to state 55
    EA                             shift and go to state 65
    P                              shift and go to state 41
    N                              shift and go to state 43
    cte                            shift and go to state 44

state 43

    (39) P -> N . MULTIPLY P
    (40) P -> N . DIVIDE P
    (41) P -> N .

    MULTIPLY        shift and go to state 66
    DIVIDE          shift and go to state 67
    PLUS            reduce using rule 41 (P -> N .)
    MINUS           reduce using rule 41 (P -> N .)
    LET             reduce using rule 41 (P -> N .)
    DIM             reduce using rule 41 (P -> N .)
    IF              reduce using rule 41 (P -> N .)
    FOR             reduce using rule 41 (P -> N .)
    WHILE           reduce using rule 41 (P -> N .)
    GOSUB           reduce using rule 41 (P -> N .)
    INPUT           reduce using rule 41 (P -> N .)
    PRINT           reduce using rule 41 (P -> N .)
    SUBPROCEDURE    reduce using rule 41 (P -> N .)
    END             reduce using rule 41 (P -> N .)
    RETURN          reduce using rule 41 (P -> N .)
    ELSE            reduce using rule 41 (P -> N .)
    EIF             reduce using rule 41 (P -> N .)
    WEND            reduce using rule 41 (P -> N .)
    NEXT            reduce using rule 41 (P -> N .)
    EQUALTO         reduce using rule 41 (P -> N .)
    GREATHER        reduce using rule 41 (P -> N .)
    GREATHEREQUAL   reduce using rule 41 (P -> N .)
    SMALLER         reduce using rule 41 (P -> N .)
    SMALLEREQUAL    reduce using rule 41 (P -> N .)
    NOTEQUAL        reduce using rule 41 (P -> N .)
    CLOSINGPAR      reduce using rule 41 (P -> N .)
    TO              reduce using rule 41 (P -> N .)
    CLOSINGBRACKET  reduce using rule 41 (P -> N .)


state 44

    (42) N -> cte .

    MULTIPLY        reduce using rule 42 (N -> cte .)
    DIVIDE          reduce using rule 42 (N -> cte .)
    PLUS            reduce using rule 42 (N -> cte .)
    MINUS           reduce using rule 42 (N -> cte .)
    LET             reduce using rule 42 (N -> cte .)
    DIM             reduce using rule 42 (N -> cte .)
    IF              reduce using rule 42 (N -> cte .)
    FOR             reduce using rule 42 (N -> cte .)
    WHILE           reduce using rule 42 (N -> cte .)
    GOSUB           reduce using rule 42 (N -> cte .)
    INPUT           reduce using rule 42 (N -> cte .)
    PRINT           reduce using rule 42 (N -> cte .)
    SUBPROCEDURE    reduce using rule 42 (N -> cte .)
    END             reduce using rule 42 (N -> cte .)
    RETURN          reduce using rule 42 (N -> cte .)
    ELSE            reduce using rule 42 (N -> cte .)
    EIF             reduce using rule 42 (N -> cte .)
    WEND            reduce using rule 42 (N -> cte .)
    NEXT            reduce using rule 42 (N -> cte .)
    EQUALTO         reduce using rule 42 (N -> cte .)
    GREATHER        reduce using rule 42 (N -> cte .)
    GREATHEREQUAL   reduce using rule 42 (N -> cte .)
    SMALLER         reduce using rule 42 (N -> cte .)
    SMALLEREQUAL    reduce using rule 42 (N -> cte .)
    NOTEQUAL        reduce using rule 42 (N -> cte .)
    CLOSINGPAR      reduce using rule 42 (N -> cte .)
    TO              reduce using rule 42 (N -> cte .)
    CLOSINGBRACKET  reduce using rule 42 (N -> cte .)


state 45

    (47) cte -> INTVAL .

    MULTIPLY        reduce using rule 47 (cte -> INTVAL .)
    DIVIDE          reduce using rule 47 (cte -> INTVAL .)
    PLUS            reduce using rule 47 (cte -> INTVAL .)
    MINUS           reduce using rule 47 (cte -> INTVAL .)
    LET             reduce using rule 47 (cte -> INTVAL .)
    DIM             reduce using rule 47 (cte -> INTVAL .)
    IF              reduce using rule 47 (cte -> INTVAL .)
    FOR             reduce using rule 47 (cte -> INTVAL .)
    WHILE           reduce using rule 47 (cte -> INTVAL .)
    GOSUB           reduce using rule 47 (cte -> INTVAL .)
    INPUT           reduce using rule 47 (cte -> INTVAL .)
    PRINT           reduce using rule 47 (cte -> INTVAL .)
    SUBPROCEDURE    reduce using rule 47 (cte -> INTVAL .)
    END             reduce using rule 47 (cte -> INTVAL .)
    RETURN          reduce using rule 47 (cte -> INTVAL .)
    ELSE            reduce using rule 47 (cte -> INTVAL .)
    EIF             reduce using rule 47 (cte -> INTVAL .)
    WEND            reduce using rule 47 (cte -> INTVAL .)
    NEXT            reduce using rule 47 (cte -> INTVAL .)
    EQUALTO         reduce using rule 47 (cte -> INTVAL .)
    GREATHER        reduce using rule 47 (cte -> INTVAL .)
    GREATHEREQUAL   reduce using rule 47 (cte -> INTVAL .)
    SMALLER         reduce using rule 47 (cte -> INTVAL .)
    SMALLEREQUAL    reduce using rule 47 (cte -> INTVAL .)
    NOTEQUAL        reduce using rule 47 (cte -> INTVAL .)
    CLOSINGPAR      reduce using rule 47 (cte -> INTVAL .)
    TO              reduce using rule 47 (cte -> INTVAL .)
    CLOSINGBRACKET  reduce using rule 47 (cte -> INTVAL .)


state 46

    (48) cte -> FLOATVAL .

    MULTIPLY        reduce using rule 48 (cte -> FLOATVAL .)
    DIVIDE          reduce using rule 48 (cte -> FLOATVAL .)
    PLUS            reduce using rule 48 (cte -> FLOATVAL .)
    MINUS           reduce using rule 48 (cte -> FLOATVAL .)
    LET             reduce using rule 48 (cte -> FLOATVAL .)
    DIM             reduce using rule 48 (cte -> FLOATVAL .)
    IF              reduce using rule 48 (cte -> FLOATVAL .)
    FOR             reduce using rule 48 (cte -> FLOATVAL .)
    WHILE           reduce using rule 48 (cte -> FLOATVAL .)
    GOSUB           reduce using rule 48 (cte -> FLOATVAL .)
    INPUT           reduce using rule 48 (cte -> FLOATVAL .)
    PRINT           reduce using rule 48 (cte -> FLOATVAL .)
    SUBPROCEDURE    reduce using rule 48 (cte -> FLOATVAL .)
    END             reduce using rule 48 (cte -> FLOATVAL .)
    RETURN          reduce using rule 48 (cte -> FLOATVAL .)
    ELSE            reduce using rule 48 (cte -> FLOATVAL .)
    EIF             reduce using rule 48 (cte -> FLOATVAL .)
    WEND            reduce using rule 48 (cte -> FLOATVAL .)
    NEXT            reduce using rule 48 (cte -> FLOATVAL .)
    EQUALTO         reduce using rule 48 (cte -> FLOATVAL .)
    GREATHER        reduce using rule 48 (cte -> FLOATVAL .)
    GREATHEREQUAL   reduce using rule 48 (cte -> FLOATVAL .)
    SMALLER         reduce using rule 48 (cte -> FLOATVAL .)
    SMALLEREQUAL    reduce using rule 48 (cte -> FLOATVAL .)
    NOTEQUAL        reduce using rule 48 (cte -> FLOATVAL .)
    CLOSINGPAR      reduce using rule 48 (cte -> FLOATVAL .)
    TO              reduce using rule 48 (cte -> FLOATVAL .)
    CLOSINGBRACKET  reduce using rule 48 (cte -> FLOATVAL .)


state 47

    (2) V -> DIM setType Idv . AS T Arr

    AS              shift and go to state 68


state 48

    (24) Idv -> ID . COMA Idv
    (25) Idv -> ID .

    COMA            shift and go to state 69
    AS              reduce using rule 25 (Idv -> ID .)
    EQUALS          reduce using rule 25 (Idv -> ID .)
    CLOSINGBRACKET  reduce using rule 25 (Idv -> ID .)


state 49

    (1) PROGRAMA -> PROGRAM V M S END .

    $end            reduce using rule 1 (PROGRAMA -> PROGRAM V M S END .)


state 50

    (10) S -> SUBPROCEDURE ID . TWOPOINTS M RETURN S

    TWOPOINTS       shift and go to state 70


state 51

    (16) E -> LET setType Idv . EQUALS Ex

    EQUALS          shift and go to state 71


state 52

    (17) E -> DIM setType Idv . AS T Arr

    AS              shift and go to state 72


state 53

    (18) E -> IF EL THEN . F Esf EIF
    (14) F -> . E F
    (15) F -> . empty
    (16) E -> . LET setType Idv EQUALS Ex
    (17) E -> . DIM setType Idv AS T Arr
    (18) E -> . IF EL THEN F Esf EIF
    (19) E -> . FOR ID EQUALS EA TO Ex F NEXT ID
    (20) E -> . WHILE OPENPAR EL CLOSINGPAR F WEND
    (21) E -> . GOSUB ID
    (22) E -> . INPUT ES COMA IDEx
    (23) E -> . PRINT Ex
    (68) empty -> .

    LET             shift and go to state 10
    DIM             shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    GOSUB           shift and go to state 15
    INPUT           shift and go to state 16
    PRINT           shift and go to state 17
    ELSE            reduce using rule 68 (empty -> .)
    EIF             reduce using rule 68 (empty -> .)

    F                              shift and go to state 73
    E                              shift and go to state 9
    empty                          shift and go to state 24

state 54

    (44) N -> OPENPAR . EA CLOSINGPAR
    (36) EA -> . P PLUS EA
    (37) EA -> . P MINUS EA
    (38) EA -> . P
    (39) P -> . N MULTIPLY P
    (40) P -> . N DIVIDE P
    (41) P -> . N
    (42) N -> . cte
    (43) N -> . ID
    (44) N -> . OPENPAR EA CLOSINGPAR
    (45) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (46) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (47) cte -> . INTVAL
    (48) cte -> . FLOATVAL

    ID              shift and go to state 75
    OPENPAR         shift and go to state 54
    INTVAL          shift and go to state 45
    FLOATVAL        shift and go to state 46

    EA                             shift and go to state 74
    P                              shift and go to state 41
    N                              shift and go to state 43
    cte                            shift and go to state 44

state 55

    (51) EL -> OPENPAR O . CLOSINGPAR Olt

    CLOSINGPAR      shift and go to state 76


state 56

    (57) O -> WORD . EQUALTO WORD

    EQUALTO         shift and go to state 77


state 57

    (58) O -> EA . OPR EA
    (61) O -> EA . OPR ID
    (62) OPR -> . EQUALTO
    (63) OPR -> . GREATHER
    (64) OPR -> . GREATHEREQUAL
    (65) OPR -> . SMALLER
    (66) OPR -> . SMALLEREQUAL
    (67) OPR -> . NOTEQUAL

    EQUALTO         shift and go to state 79
    GREATHER        shift and go to state 80
    GREATHEREQUAL   shift and go to state 81
    SMALLER         shift and go to state 82
    SMALLEREQUAL    shift and go to state 83
    NOTEQUAL        shift and go to state 84

    OPR                            shift and go to state 78

state 58

    (59) O -> ID . OPR ID
    (60) O -> ID . OPR EA
    (43) N -> ID .
    (45) N -> ID . OPENBRACKET INTVAL CLOSINGBRACKET
    (46) N -> ID . OPENBRACKET setType Idv CLOSINGBRACKET
    (62) OPR -> . EQUALTO
    (63) OPR -> . GREATHER
    (64) OPR -> . GREATHEREQUAL
    (65) OPR -> . SMALLER
    (66) OPR -> . SMALLEREQUAL
    (67) OPR -> . NOTEQUAL

  ! shift/reduce conflict for EQUALTO resolved as shift
  ! shift/reduce conflict for GREATHER resolved as shift
  ! shift/reduce conflict for GREATHEREQUAL resolved as shift
  ! shift/reduce conflict for SMALLER resolved as shift
  ! shift/reduce conflict for SMALLEREQUAL resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
    MULTIPLY        reduce using rule 43 (N -> ID .)
    DIVIDE          reduce using rule 43 (N -> ID .)
    PLUS            reduce using rule 43 (N -> ID .)
    MINUS           reduce using rule 43 (N -> ID .)
    CLOSINGPAR      reduce using rule 43 (N -> ID .)
    OPENBRACKET     shift and go to state 62
    EQUALTO         shift and go to state 79
    GREATHER        shift and go to state 80
    GREATHEREQUAL   shift and go to state 81
    SMALLER         shift and go to state 82
    SMALLEREQUAL    shift and go to state 83
    NOTEQUAL        shift and go to state 84

  ! EQUALTO         [ reduce using rule 43 (N -> ID .) ]
  ! GREATHER        [ reduce using rule 43 (N -> ID .) ]
  ! GREATHEREQUAL   [ reduce using rule 43 (N -> ID .) ]
  ! SMALLER         [ reduce using rule 43 (N -> ID .) ]
  ! SMALLEREQUAL    [ reduce using rule 43 (N -> ID .) ]
  ! NOTEQUAL        [ reduce using rule 43 (N -> ID .) ]

    OPR                            shift and go to state 85

state 59

    (19) E -> FOR ID EQUALS . EA TO Ex F NEXT ID
    (36) EA -> . P PLUS EA
    (37) EA -> . P MINUS EA
    (38) EA -> . P
    (39) P -> . N MULTIPLY P
    (40) P -> . N DIVIDE P
    (41) P -> . N
    (42) N -> . cte
    (43) N -> . ID
    (44) N -> . OPENPAR EA CLOSINGPAR
    (45) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (46) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (47) cte -> . INTVAL
    (48) cte -> . FLOATVAL

    ID              shift and go to state 75
    OPENPAR         shift and go to state 54
    INTVAL          shift and go to state 45
    FLOATVAL        shift and go to state 46

    EA                             shift and go to state 86
    P                              shift and go to state 41
    N                              shift and go to state 43
    cte                            shift and go to state 44

state 60

    (20) E -> WHILE OPENPAR EL . CLOSINGPAR F WEND

    CLOSINGPAR      shift and go to state 87


state 61

    (22) E -> INPUT ES COMA . IDEx
    (29) IDEx -> . ID
    (30) IDEx -> . ID OPENBRACKET setType Idv CLOSINGBRACKET

    ID              shift and go to state 89

    IDEx                           shift and go to state 88

state 62

    (45) N -> ID OPENBRACKET . INTVAL CLOSINGBRACKET
    (46) N -> ID OPENBRACKET . setType Idv CLOSINGBRACKET
    (26) setType -> .

    INTVAL          shift and go to state 90
    ID              reduce using rule 26 (setType -> .)

    setType                        shift and go to state 91

state 63

    (36) EA -> P PLUS . EA
    (36) EA -> . P PLUS EA
    (37) EA -> . P MINUS EA
    (38) EA -> . P
    (39) P -> . N MULTIPLY P
    (40) P -> . N DIVIDE P
    (41) P -> . N
    (42) N -> . cte
    (43) N -> . ID
    (44) N -> . OPENPAR EA CLOSINGPAR
    (45) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (46) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (47) cte -> . INTVAL
    (48) cte -> . FLOATVAL

    ID              shift and go to state 75
    OPENPAR         shift and go to state 54
    INTVAL          shift and go to state 45
    FLOATVAL        shift and go to state 46

    P                              shift and go to state 41
    EA                             shift and go to state 92
    N                              shift and go to state 43
    cte                            shift and go to state 44

state 64

    (37) EA -> P MINUS . EA
    (36) EA -> . P PLUS EA
    (37) EA -> . P MINUS EA
    (38) EA -> . P
    (39) P -> . N MULTIPLY P
    (40) P -> . N DIVIDE P
    (41) P -> . N
    (42) N -> . cte
    (43) N -> . ID
    (44) N -> . OPENPAR EA CLOSINGPAR
    (45) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (46) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (47) cte -> . INTVAL
    (48) cte -> . FLOATVAL

    ID              shift and go to state 75
    OPENPAR         shift and go to state 54
    INTVAL          shift and go to state 45
    FLOATVAL        shift and go to state 46

    P                              shift and go to state 41
    EA                             shift and go to state 93
    N                              shift and go to state 43
    cte                            shift and go to state 44

state 65

    (44) N -> OPENPAR EA . CLOSINGPAR
    (58) O -> EA . OPR EA
    (61) O -> EA . OPR ID
    (62) OPR -> . EQUALTO
    (63) OPR -> . GREATHER
    (64) OPR -> . GREATHEREQUAL
    (65) OPR -> . SMALLER
    (66) OPR -> . SMALLEREQUAL
    (67) OPR -> . NOTEQUAL

    CLOSINGPAR      shift and go to state 94
    EQUALTO         shift and go to state 79
    GREATHER        shift and go to state 80
    GREATHEREQUAL   shift and go to state 81
    SMALLER         shift and go to state 82
    SMALLEREQUAL    shift and go to state 83
    NOTEQUAL        shift and go to state 84

    OPR                            shift and go to state 78

state 66

    (39) P -> N MULTIPLY . P
    (39) P -> . N MULTIPLY P
    (40) P -> . N DIVIDE P
    (41) P -> . N
    (42) N -> . cte
    (43) N -> . ID
    (44) N -> . OPENPAR EA CLOSINGPAR
    (45) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (46) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (47) cte -> . INTVAL
    (48) cte -> . FLOATVAL

    ID              shift and go to state 75
    OPENPAR         shift and go to state 54
    INTVAL          shift and go to state 45
    FLOATVAL        shift and go to state 46

    N                              shift and go to state 43
    P                              shift and go to state 95
    cte                            shift and go to state 44

state 67

    (40) P -> N DIVIDE . P
    (39) P -> . N MULTIPLY P
    (40) P -> . N DIVIDE P
    (41) P -> . N
    (42) N -> . cte
    (43) N -> . ID
    (44) N -> . OPENPAR EA CLOSINGPAR
    (45) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (46) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (47) cte -> . INTVAL
    (48) cte -> . FLOATVAL

    ID              shift and go to state 75
    OPENPAR         shift and go to state 54
    INTVAL          shift and go to state 45
    FLOATVAL        shift and go to state 46

    N                              shift and go to state 43
    P                              shift and go to state 96
    cte                            shift and go to state 44

state 68

    (2) V -> DIM setType Idv AS . T Arr
    (7) T -> . INT
    (8) T -> . FLOAT
    (9) T -> . WORD

    INT             shift and go to state 98
    FLOAT           shift and go to state 99
    WORD            shift and go to state 100

    T                              shift and go to state 97

state 69

    (24) Idv -> ID COMA . Idv
    (24) Idv -> . ID COMA Idv
    (25) Idv -> . ID

    ID              shift and go to state 48

    Idv                            shift and go to state 101

state 70

    (10) S -> SUBPROCEDURE ID TWOPOINTS . M RETURN S
    (12) M -> . F M
    (13) M -> . empty
    (14) F -> . E F
    (15) F -> . empty
    (68) empty -> .
    (16) E -> . LET setType Idv EQUALS Ex
    (17) E -> . DIM setType Idv AS T Arr
    (18) E -> . IF EL THEN F Esf EIF
    (19) E -> . FOR ID EQUALS EA TO Ex F NEXT ID
    (20) E -> . WHILE OPENPAR EL CLOSINGPAR F WEND
    (21) E -> . GOSUB ID
    (22) E -> . INPUT ES COMA IDEx
    (23) E -> . PRINT Ex

  ! shift/reduce conflict for LET resolved as shift
  ! shift/reduce conflict for DIM resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for GOSUB resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
    RETURN          reduce using rule 68 (empty -> .)
    LET             shift and go to state 10
    DIM             shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    GOSUB           shift and go to state 15
    INPUT           shift and go to state 16
    PRINT           shift and go to state 17

  ! LET             [ reduce using rule 68 (empty -> .) ]
  ! DIM             [ reduce using rule 68 (empty -> .) ]
  ! IF              [ reduce using rule 68 (empty -> .) ]
  ! FOR             [ reduce using rule 68 (empty -> .) ]
  ! WHILE           [ reduce using rule 68 (empty -> .) ]
  ! GOSUB           [ reduce using rule 68 (empty -> .) ]
  ! INPUT           [ reduce using rule 68 (empty -> .) ]
  ! PRINT           [ reduce using rule 68 (empty -> .) ]

    M                              shift and go to state 102
    F                              shift and go to state 7
    empty                          shift and go to state 8
    E                              shift and go to state 9

state 71

    (16) E -> LET setType Idv EQUALS . Ex
    (31) Ex -> . EA
    (32) Ex -> . ES
    (33) Ex -> . EL
    (34) Ex -> . ID
    (36) EA -> . P PLUS EA
    (37) EA -> . P MINUS EA
    (38) EA -> . P
    (35) ES -> . WORDVAL
    (49) EL -> . TRUE
    (50) EL -> . FALSE
    (51) EL -> . OPENPAR O CLOSINGPAR Olt
    (39) P -> . N MULTIPLY P
    (40) P -> . N DIVIDE P
    (41) P -> . N
    (42) N -> . cte
    (43) N -> . ID
    (44) N -> . OPENPAR EA CLOSINGPAR
    (45) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (46) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (47) cte -> . INTVAL
    (48) cte -> . FLOATVAL

    ID              shift and go to state 40
    WORDVAL         shift and go to state 35
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    OPENPAR         shift and go to state 42
    INTVAL          shift and go to state 45
    FLOATVAL        shift and go to state 46

    Ex                             shift and go to state 103
    EA                             shift and go to state 37
    ES                             shift and go to state 38
    EL                             shift and go to state 39
    P                              shift and go to state 41
    N                              shift and go to state 43
    cte                            shift and go to state 44

state 72

    (17) E -> DIM setType Idv AS . T Arr
    (7) T -> . INT
    (8) T -> . FLOAT
    (9) T -> . WORD

    INT             shift and go to state 98
    FLOAT           shift and go to state 99
    WORD            shift and go to state 100

    T                              shift and go to state 104

state 73

    (18) E -> IF EL THEN F . Esf EIF
    (27) Esf -> . ELSE F
    (28) Esf -> . empty
    (68) empty -> .

    ELSE            shift and go to state 106
    EIF             reduce using rule 68 (empty -> .)

    Esf                            shift and go to state 105
    empty                          shift and go to state 107

state 74

    (44) N -> OPENPAR EA . CLOSINGPAR

    CLOSINGPAR      shift and go to state 94


state 75

    (43) N -> ID .
    (45) N -> ID . OPENBRACKET INTVAL CLOSINGBRACKET
    (46) N -> ID . OPENBRACKET setType Idv CLOSINGBRACKET

    MULTIPLY        reduce using rule 43 (N -> ID .)
    DIVIDE          reduce using rule 43 (N -> ID .)
    PLUS            reduce using rule 43 (N -> ID .)
    MINUS           reduce using rule 43 (N -> ID .)
    CLOSINGPAR      reduce using rule 43 (N -> ID .)
    TO              reduce using rule 43 (N -> ID .)
    LET             reduce using rule 43 (N -> ID .)
    DIM             reduce using rule 43 (N -> ID .)
    IF              reduce using rule 43 (N -> ID .)
    FOR             reduce using rule 43 (N -> ID .)
    WHILE           reduce using rule 43 (N -> ID .)
    GOSUB           reduce using rule 43 (N -> ID .)
    INPUT           reduce using rule 43 (N -> ID .)
    PRINT           reduce using rule 43 (N -> ID .)
    SUBPROCEDURE    reduce using rule 43 (N -> ID .)
    END             reduce using rule 43 (N -> ID .)
    RETURN          reduce using rule 43 (N -> ID .)
    ELSE            reduce using rule 43 (N -> ID .)
    EIF             reduce using rule 43 (N -> ID .)
    WEND            reduce using rule 43 (N -> ID .)
    NEXT            reduce using rule 43 (N -> ID .)
    EQUALTO         reduce using rule 43 (N -> ID .)
    GREATHER        reduce using rule 43 (N -> ID .)
    GREATHEREQUAL   reduce using rule 43 (N -> ID .)
    SMALLER         reduce using rule 43 (N -> ID .)
    SMALLEREQUAL    reduce using rule 43 (N -> ID .)
    NOTEQUAL        reduce using rule 43 (N -> ID .)
    CLOSINGBRACKET  reduce using rule 43 (N -> ID .)
    OPENBRACKET     shift and go to state 62


state 76

    (51) EL -> OPENPAR O CLOSINGPAR . Olt
    (52) Olt -> . OL OPENPAR O CLOSINGPAR Olt
    (53) Olt -> . empty
    (54) OL -> . AND
    (55) OL -> . OR
    (56) OL -> . NOT
    (68) empty -> .

    AND             shift and go to state 111
    OR              shift and go to state 112
    NOT             shift and go to state 113
    THEN            reduce using rule 68 (empty -> .)
    LET             reduce using rule 68 (empty -> .)
    DIM             reduce using rule 68 (empty -> .)
    IF              reduce using rule 68 (empty -> .)
    FOR             reduce using rule 68 (empty -> .)
    WHILE           reduce using rule 68 (empty -> .)
    GOSUB           reduce using rule 68 (empty -> .)
    INPUT           reduce using rule 68 (empty -> .)
    PRINT           reduce using rule 68 (empty -> .)
    SUBPROCEDURE    reduce using rule 68 (empty -> .)
    END             reduce using rule 68 (empty -> .)
    RETURN          reduce using rule 68 (empty -> .)
    ELSE            reduce using rule 68 (empty -> .)
    EIF             reduce using rule 68 (empty -> .)
    WEND            reduce using rule 68 (empty -> .)
    NEXT            reduce using rule 68 (empty -> .)
    CLOSINGPAR      reduce using rule 68 (empty -> .)

    Olt                            shift and go to state 108
    OL                             shift and go to state 109
    empty                          shift and go to state 110

state 77

    (57) O -> WORD EQUALTO . WORD

    WORD            shift and go to state 114


state 78

    (58) O -> EA OPR . EA
    (61) O -> EA OPR . ID
    (36) EA -> . P PLUS EA
    (37) EA -> . P MINUS EA
    (38) EA -> . P
    (39) P -> . N MULTIPLY P
    (40) P -> . N DIVIDE P
    (41) P -> . N
    (42) N -> . cte
    (43) N -> . ID
    (44) N -> . OPENPAR EA CLOSINGPAR
    (45) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (46) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (47) cte -> . INTVAL
    (48) cte -> . FLOATVAL

    ID              shift and go to state 116
    OPENPAR         shift and go to state 54
    INTVAL          shift and go to state 45
    FLOATVAL        shift and go to state 46

    EA                             shift and go to state 115
    P                              shift and go to state 41
    N                              shift and go to state 43
    cte                            shift and go to state 44

state 79

    (62) OPR -> EQUALTO .

    ID              reduce using rule 62 (OPR -> EQUALTO .)
    OPENPAR         reduce using rule 62 (OPR -> EQUALTO .)
    INTVAL          reduce using rule 62 (OPR -> EQUALTO .)
    FLOATVAL        reduce using rule 62 (OPR -> EQUALTO .)


state 80

    (63) OPR -> GREATHER .

    ID              reduce using rule 63 (OPR -> GREATHER .)
    OPENPAR         reduce using rule 63 (OPR -> GREATHER .)
    INTVAL          reduce using rule 63 (OPR -> GREATHER .)
    FLOATVAL        reduce using rule 63 (OPR -> GREATHER .)


state 81

    (64) OPR -> GREATHEREQUAL .

    ID              reduce using rule 64 (OPR -> GREATHEREQUAL .)
    OPENPAR         reduce using rule 64 (OPR -> GREATHEREQUAL .)
    INTVAL          reduce using rule 64 (OPR -> GREATHEREQUAL .)
    FLOATVAL        reduce using rule 64 (OPR -> GREATHEREQUAL .)


state 82

    (65) OPR -> SMALLER .

    ID              reduce using rule 65 (OPR -> SMALLER .)
    OPENPAR         reduce using rule 65 (OPR -> SMALLER .)
    INTVAL          reduce using rule 65 (OPR -> SMALLER .)
    FLOATVAL        reduce using rule 65 (OPR -> SMALLER .)


state 83

    (66) OPR -> SMALLEREQUAL .

    ID              reduce using rule 66 (OPR -> SMALLEREQUAL .)
    OPENPAR         reduce using rule 66 (OPR -> SMALLEREQUAL .)
    INTVAL          reduce using rule 66 (OPR -> SMALLEREQUAL .)
    FLOATVAL        reduce using rule 66 (OPR -> SMALLEREQUAL .)


state 84

    (67) OPR -> NOTEQUAL .

    ID              reduce using rule 67 (OPR -> NOTEQUAL .)
    OPENPAR         reduce using rule 67 (OPR -> NOTEQUAL .)
    INTVAL          reduce using rule 67 (OPR -> NOTEQUAL .)
    FLOATVAL        reduce using rule 67 (OPR -> NOTEQUAL .)


state 85

    (59) O -> ID OPR . ID
    (60) O -> ID OPR . EA
    (36) EA -> . P PLUS EA
    (37) EA -> . P MINUS EA
    (38) EA -> . P
    (39) P -> . N MULTIPLY P
    (40) P -> . N DIVIDE P
    (41) P -> . N
    (42) N -> . cte
    (43) N -> . ID
    (44) N -> . OPENPAR EA CLOSINGPAR
    (45) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (46) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (47) cte -> . INTVAL
    (48) cte -> . FLOATVAL

    ID              shift and go to state 117
    OPENPAR         shift and go to state 54
    INTVAL          shift and go to state 45
    FLOATVAL        shift and go to state 46

    EA                             shift and go to state 118
    P                              shift and go to state 41
    N                              shift and go to state 43
    cte                            shift and go to state 44

state 86

    (19) E -> FOR ID EQUALS EA . TO Ex F NEXT ID

    TO              shift and go to state 119


state 87

    (20) E -> WHILE OPENPAR EL CLOSINGPAR . F WEND
    (14) F -> . E F
    (15) F -> . empty
    (16) E -> . LET setType Idv EQUALS Ex
    (17) E -> . DIM setType Idv AS T Arr
    (18) E -> . IF EL THEN F Esf EIF
    (19) E -> . FOR ID EQUALS EA TO Ex F NEXT ID
    (20) E -> . WHILE OPENPAR EL CLOSINGPAR F WEND
    (21) E -> . GOSUB ID
    (22) E -> . INPUT ES COMA IDEx
    (23) E -> . PRINT Ex
    (68) empty -> .

    LET             shift and go to state 10
    DIM             shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    GOSUB           shift and go to state 15
    INPUT           shift and go to state 16
    PRINT           shift and go to state 17
    WEND            reduce using rule 68 (empty -> .)

    F                              shift and go to state 120
    E                              shift and go to state 9
    empty                          shift and go to state 24

state 88

    (22) E -> INPUT ES COMA IDEx .

    LET             reduce using rule 22 (E -> INPUT ES COMA IDEx .)
    DIM             reduce using rule 22 (E -> INPUT ES COMA IDEx .)
    IF              reduce using rule 22 (E -> INPUT ES COMA IDEx .)
    FOR             reduce using rule 22 (E -> INPUT ES COMA IDEx .)
    WHILE           reduce using rule 22 (E -> INPUT ES COMA IDEx .)
    GOSUB           reduce using rule 22 (E -> INPUT ES COMA IDEx .)
    INPUT           reduce using rule 22 (E -> INPUT ES COMA IDEx .)
    PRINT           reduce using rule 22 (E -> INPUT ES COMA IDEx .)
    SUBPROCEDURE    reduce using rule 22 (E -> INPUT ES COMA IDEx .)
    END             reduce using rule 22 (E -> INPUT ES COMA IDEx .)
    RETURN          reduce using rule 22 (E -> INPUT ES COMA IDEx .)
    ELSE            reduce using rule 22 (E -> INPUT ES COMA IDEx .)
    EIF             reduce using rule 22 (E -> INPUT ES COMA IDEx .)
    WEND            reduce using rule 22 (E -> INPUT ES COMA IDEx .)
    NEXT            reduce using rule 22 (E -> INPUT ES COMA IDEx .)


state 89

    (29) IDEx -> ID .
    (30) IDEx -> ID . OPENBRACKET setType Idv CLOSINGBRACKET

    LET             reduce using rule 29 (IDEx -> ID .)
    DIM             reduce using rule 29 (IDEx -> ID .)
    IF              reduce using rule 29 (IDEx -> ID .)
    FOR             reduce using rule 29 (IDEx -> ID .)
    WHILE           reduce using rule 29 (IDEx -> ID .)
    GOSUB           reduce using rule 29 (IDEx -> ID .)
    INPUT           reduce using rule 29 (IDEx -> ID .)
    PRINT           reduce using rule 29 (IDEx -> ID .)
    SUBPROCEDURE    reduce using rule 29 (IDEx -> ID .)
    END             reduce using rule 29 (IDEx -> ID .)
    RETURN          reduce using rule 29 (IDEx -> ID .)
    ELSE            reduce using rule 29 (IDEx -> ID .)
    EIF             reduce using rule 29 (IDEx -> ID .)
    WEND            reduce using rule 29 (IDEx -> ID .)
    NEXT            reduce using rule 29 (IDEx -> ID .)
    OPENBRACKET     shift and go to state 121


state 90

    (45) N -> ID OPENBRACKET INTVAL . CLOSINGBRACKET

    CLOSINGBRACKET  shift and go to state 122


state 91

    (46) N -> ID OPENBRACKET setType . Idv CLOSINGBRACKET
    (24) Idv -> . ID COMA Idv
    (25) Idv -> . ID

    ID              shift and go to state 48

    Idv                            shift and go to state 123

state 92

    (36) EA -> P PLUS EA .

    LET             reduce using rule 36 (EA -> P PLUS EA .)
    DIM             reduce using rule 36 (EA -> P PLUS EA .)
    IF              reduce using rule 36 (EA -> P PLUS EA .)
    FOR             reduce using rule 36 (EA -> P PLUS EA .)
    WHILE           reduce using rule 36 (EA -> P PLUS EA .)
    GOSUB           reduce using rule 36 (EA -> P PLUS EA .)
    INPUT           reduce using rule 36 (EA -> P PLUS EA .)
    PRINT           reduce using rule 36 (EA -> P PLUS EA .)
    SUBPROCEDURE    reduce using rule 36 (EA -> P PLUS EA .)
    END             reduce using rule 36 (EA -> P PLUS EA .)
    RETURN          reduce using rule 36 (EA -> P PLUS EA .)
    ELSE            reduce using rule 36 (EA -> P PLUS EA .)
    EIF             reduce using rule 36 (EA -> P PLUS EA .)
    WEND            reduce using rule 36 (EA -> P PLUS EA .)
    NEXT            reduce using rule 36 (EA -> P PLUS EA .)
    EQUALTO         reduce using rule 36 (EA -> P PLUS EA .)
    GREATHER        reduce using rule 36 (EA -> P PLUS EA .)
    GREATHEREQUAL   reduce using rule 36 (EA -> P PLUS EA .)
    SMALLER         reduce using rule 36 (EA -> P PLUS EA .)
    SMALLEREQUAL    reduce using rule 36 (EA -> P PLUS EA .)
    NOTEQUAL        reduce using rule 36 (EA -> P PLUS EA .)
    CLOSINGPAR      reduce using rule 36 (EA -> P PLUS EA .)
    TO              reduce using rule 36 (EA -> P PLUS EA .)
    CLOSINGBRACKET  reduce using rule 36 (EA -> P PLUS EA .)


state 93

    (37) EA -> P MINUS EA .

    LET             reduce using rule 37 (EA -> P MINUS EA .)
    DIM             reduce using rule 37 (EA -> P MINUS EA .)
    IF              reduce using rule 37 (EA -> P MINUS EA .)
    FOR             reduce using rule 37 (EA -> P MINUS EA .)
    WHILE           reduce using rule 37 (EA -> P MINUS EA .)
    GOSUB           reduce using rule 37 (EA -> P MINUS EA .)
    INPUT           reduce using rule 37 (EA -> P MINUS EA .)
    PRINT           reduce using rule 37 (EA -> P MINUS EA .)
    SUBPROCEDURE    reduce using rule 37 (EA -> P MINUS EA .)
    END             reduce using rule 37 (EA -> P MINUS EA .)
    RETURN          reduce using rule 37 (EA -> P MINUS EA .)
    ELSE            reduce using rule 37 (EA -> P MINUS EA .)
    EIF             reduce using rule 37 (EA -> P MINUS EA .)
    WEND            reduce using rule 37 (EA -> P MINUS EA .)
    NEXT            reduce using rule 37 (EA -> P MINUS EA .)
    EQUALTO         reduce using rule 37 (EA -> P MINUS EA .)
    GREATHER        reduce using rule 37 (EA -> P MINUS EA .)
    GREATHEREQUAL   reduce using rule 37 (EA -> P MINUS EA .)
    SMALLER         reduce using rule 37 (EA -> P MINUS EA .)
    SMALLEREQUAL    reduce using rule 37 (EA -> P MINUS EA .)
    NOTEQUAL        reduce using rule 37 (EA -> P MINUS EA .)
    CLOSINGPAR      reduce using rule 37 (EA -> P MINUS EA .)
    TO              reduce using rule 37 (EA -> P MINUS EA .)
    CLOSINGBRACKET  reduce using rule 37 (EA -> P MINUS EA .)


state 94

    (44) N -> OPENPAR EA CLOSINGPAR .

    MULTIPLY        reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    DIVIDE          reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    PLUS            reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    MINUS           reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    LET             reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    DIM             reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    IF              reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    FOR             reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    WHILE           reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    GOSUB           reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    INPUT           reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    PRINT           reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    SUBPROCEDURE    reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    END             reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    RETURN          reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    ELSE            reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    EIF             reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    WEND            reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    NEXT            reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    EQUALTO         reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    GREATHER        reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    GREATHEREQUAL   reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    SMALLER         reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    SMALLEREQUAL    reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    NOTEQUAL        reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    CLOSINGPAR      reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    TO              reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    CLOSINGBRACKET  reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)


state 95

    (39) P -> N MULTIPLY P .

    PLUS            reduce using rule 39 (P -> N MULTIPLY P .)
    MINUS           reduce using rule 39 (P -> N MULTIPLY P .)
    LET             reduce using rule 39 (P -> N MULTIPLY P .)
    DIM             reduce using rule 39 (P -> N MULTIPLY P .)
    IF              reduce using rule 39 (P -> N MULTIPLY P .)
    FOR             reduce using rule 39 (P -> N MULTIPLY P .)
    WHILE           reduce using rule 39 (P -> N MULTIPLY P .)
    GOSUB           reduce using rule 39 (P -> N MULTIPLY P .)
    INPUT           reduce using rule 39 (P -> N MULTIPLY P .)
    PRINT           reduce using rule 39 (P -> N MULTIPLY P .)
    SUBPROCEDURE    reduce using rule 39 (P -> N MULTIPLY P .)
    END             reduce using rule 39 (P -> N MULTIPLY P .)
    RETURN          reduce using rule 39 (P -> N MULTIPLY P .)
    ELSE            reduce using rule 39 (P -> N MULTIPLY P .)
    EIF             reduce using rule 39 (P -> N MULTIPLY P .)
    WEND            reduce using rule 39 (P -> N MULTIPLY P .)
    NEXT            reduce using rule 39 (P -> N MULTIPLY P .)
    EQUALTO         reduce using rule 39 (P -> N MULTIPLY P .)
    GREATHER        reduce using rule 39 (P -> N MULTIPLY P .)
    GREATHEREQUAL   reduce using rule 39 (P -> N MULTIPLY P .)
    SMALLER         reduce using rule 39 (P -> N MULTIPLY P .)
    SMALLEREQUAL    reduce using rule 39 (P -> N MULTIPLY P .)
    NOTEQUAL        reduce using rule 39 (P -> N MULTIPLY P .)
    CLOSINGPAR      reduce using rule 39 (P -> N MULTIPLY P .)
    TO              reduce using rule 39 (P -> N MULTIPLY P .)
    CLOSINGBRACKET  reduce using rule 39 (P -> N MULTIPLY P .)


state 96

    (40) P -> N DIVIDE P .

    PLUS            reduce using rule 40 (P -> N DIVIDE P .)
    MINUS           reduce using rule 40 (P -> N DIVIDE P .)
    LET             reduce using rule 40 (P -> N DIVIDE P .)
    DIM             reduce using rule 40 (P -> N DIVIDE P .)
    IF              reduce using rule 40 (P -> N DIVIDE P .)
    FOR             reduce using rule 40 (P -> N DIVIDE P .)
    WHILE           reduce using rule 40 (P -> N DIVIDE P .)
    GOSUB           reduce using rule 40 (P -> N DIVIDE P .)
    INPUT           reduce using rule 40 (P -> N DIVIDE P .)
    PRINT           reduce using rule 40 (P -> N DIVIDE P .)
    SUBPROCEDURE    reduce using rule 40 (P -> N DIVIDE P .)
    END             reduce using rule 40 (P -> N DIVIDE P .)
    RETURN          reduce using rule 40 (P -> N DIVIDE P .)
    ELSE            reduce using rule 40 (P -> N DIVIDE P .)
    EIF             reduce using rule 40 (P -> N DIVIDE P .)
    WEND            reduce using rule 40 (P -> N DIVIDE P .)
    NEXT            reduce using rule 40 (P -> N DIVIDE P .)
    EQUALTO         reduce using rule 40 (P -> N DIVIDE P .)
    GREATHER        reduce using rule 40 (P -> N DIVIDE P .)
    GREATHEREQUAL   reduce using rule 40 (P -> N DIVIDE P .)
    SMALLER         reduce using rule 40 (P -> N DIVIDE P .)
    SMALLEREQUAL    reduce using rule 40 (P -> N DIVIDE P .)
    NOTEQUAL        reduce using rule 40 (P -> N DIVIDE P .)
    CLOSINGPAR      reduce using rule 40 (P -> N DIVIDE P .)
    TO              reduce using rule 40 (P -> N DIVIDE P .)
    CLOSINGBRACKET  reduce using rule 40 (P -> N DIVIDE P .)


state 97

    (2) V -> DIM setType Idv AS T . Arr
    (4) Arr -> . OPENBRACKET EA CLOSINGBRACKET Arr
    (5) Arr -> . OPENBRACKET ID CLOSINGBRACKET Arr
    (6) Arr -> . empty
    (68) empty -> .

    OPENBRACKET     shift and go to state 125
    LET             reduce using rule 68 (empty -> .)
    DIM             reduce using rule 68 (empty -> .)
    IF              reduce using rule 68 (empty -> .)
    FOR             reduce using rule 68 (empty -> .)
    WHILE           reduce using rule 68 (empty -> .)
    GOSUB           reduce using rule 68 (empty -> .)
    INPUT           reduce using rule 68 (empty -> .)
    PRINT           reduce using rule 68 (empty -> .)
    SUBPROCEDURE    reduce using rule 68 (empty -> .)
    END             reduce using rule 68 (empty -> .)

    Arr                            shift and go to state 124
    empty                          shift and go to state 126

state 98

    (7) T -> INT .

    OPENBRACKET     reduce using rule 7 (T -> INT .)
    LET             reduce using rule 7 (T -> INT .)
    DIM             reduce using rule 7 (T -> INT .)
    IF              reduce using rule 7 (T -> INT .)
    FOR             reduce using rule 7 (T -> INT .)
    WHILE           reduce using rule 7 (T -> INT .)
    GOSUB           reduce using rule 7 (T -> INT .)
    INPUT           reduce using rule 7 (T -> INT .)
    PRINT           reduce using rule 7 (T -> INT .)
    SUBPROCEDURE    reduce using rule 7 (T -> INT .)
    END             reduce using rule 7 (T -> INT .)
    RETURN          reduce using rule 7 (T -> INT .)
    ELSE            reduce using rule 7 (T -> INT .)
    EIF             reduce using rule 7 (T -> INT .)
    WEND            reduce using rule 7 (T -> INT .)
    NEXT            reduce using rule 7 (T -> INT .)


state 99

    (8) T -> FLOAT .

    OPENBRACKET     reduce using rule 8 (T -> FLOAT .)
    LET             reduce using rule 8 (T -> FLOAT .)
    DIM             reduce using rule 8 (T -> FLOAT .)
    IF              reduce using rule 8 (T -> FLOAT .)
    FOR             reduce using rule 8 (T -> FLOAT .)
    WHILE           reduce using rule 8 (T -> FLOAT .)
    GOSUB           reduce using rule 8 (T -> FLOAT .)
    INPUT           reduce using rule 8 (T -> FLOAT .)
    PRINT           reduce using rule 8 (T -> FLOAT .)
    SUBPROCEDURE    reduce using rule 8 (T -> FLOAT .)
    END             reduce using rule 8 (T -> FLOAT .)
    RETURN          reduce using rule 8 (T -> FLOAT .)
    ELSE            reduce using rule 8 (T -> FLOAT .)
    EIF             reduce using rule 8 (T -> FLOAT .)
    WEND            reduce using rule 8 (T -> FLOAT .)
    NEXT            reduce using rule 8 (T -> FLOAT .)


state 100

    (9) T -> WORD .

    OPENBRACKET     reduce using rule 9 (T -> WORD .)
    LET             reduce using rule 9 (T -> WORD .)
    DIM             reduce using rule 9 (T -> WORD .)
    IF              reduce using rule 9 (T -> WORD .)
    FOR             reduce using rule 9 (T -> WORD .)
    WHILE           reduce using rule 9 (T -> WORD .)
    GOSUB           reduce using rule 9 (T -> WORD .)
    INPUT           reduce using rule 9 (T -> WORD .)
    PRINT           reduce using rule 9 (T -> WORD .)
    SUBPROCEDURE    reduce using rule 9 (T -> WORD .)
    END             reduce using rule 9 (T -> WORD .)
    RETURN          reduce using rule 9 (T -> WORD .)
    ELSE            reduce using rule 9 (T -> WORD .)
    EIF             reduce using rule 9 (T -> WORD .)
    WEND            reduce using rule 9 (T -> WORD .)
    NEXT            reduce using rule 9 (T -> WORD .)


state 101

    (24) Idv -> ID COMA Idv .

    AS              reduce using rule 24 (Idv -> ID COMA Idv .)
    EQUALS          reduce using rule 24 (Idv -> ID COMA Idv .)
    CLOSINGBRACKET  reduce using rule 24 (Idv -> ID COMA Idv .)


state 102

    (10) S -> SUBPROCEDURE ID TWOPOINTS M . RETURN S

    RETURN          shift and go to state 127


state 103

    (16) E -> LET setType Idv EQUALS Ex .

    LET             reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    DIM             reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    IF              reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    FOR             reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    WHILE           reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    GOSUB           reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    INPUT           reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    PRINT           reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    SUBPROCEDURE    reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    END             reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    RETURN          reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    ELSE            reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    EIF             reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    WEND            reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    NEXT            reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)


state 104

    (17) E -> DIM setType Idv AS T . Arr
    (4) Arr -> . OPENBRACKET EA CLOSINGBRACKET Arr
    (5) Arr -> . OPENBRACKET ID CLOSINGBRACKET Arr
    (6) Arr -> . empty
    (68) empty -> .

    OPENBRACKET     shift and go to state 125
    LET             reduce using rule 68 (empty -> .)
    DIM             reduce using rule 68 (empty -> .)
    IF              reduce using rule 68 (empty -> .)
    FOR             reduce using rule 68 (empty -> .)
    WHILE           reduce using rule 68 (empty -> .)
    GOSUB           reduce using rule 68 (empty -> .)
    INPUT           reduce using rule 68 (empty -> .)
    PRINT           reduce using rule 68 (empty -> .)
    SUBPROCEDURE    reduce using rule 68 (empty -> .)
    END             reduce using rule 68 (empty -> .)
    RETURN          reduce using rule 68 (empty -> .)
    ELSE            reduce using rule 68 (empty -> .)
    EIF             reduce using rule 68 (empty -> .)
    WEND            reduce using rule 68 (empty -> .)
    NEXT            reduce using rule 68 (empty -> .)

    Arr                            shift and go to state 128
    empty                          shift and go to state 126

state 105

    (18) E -> IF EL THEN F Esf . EIF

    EIF             shift and go to state 129


state 106

    (27) Esf -> ELSE . F
    (14) F -> . E F
    (15) F -> . empty
    (16) E -> . LET setType Idv EQUALS Ex
    (17) E -> . DIM setType Idv AS T Arr
    (18) E -> . IF EL THEN F Esf EIF
    (19) E -> . FOR ID EQUALS EA TO Ex F NEXT ID
    (20) E -> . WHILE OPENPAR EL CLOSINGPAR F WEND
    (21) E -> . GOSUB ID
    (22) E -> . INPUT ES COMA IDEx
    (23) E -> . PRINT Ex
    (68) empty -> .

    LET             shift and go to state 10
    DIM             shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    GOSUB           shift and go to state 15
    INPUT           shift and go to state 16
    PRINT           shift and go to state 17
    EIF             reduce using rule 68 (empty -> .)

    F                              shift and go to state 130
    E                              shift and go to state 9
    empty                          shift and go to state 24

state 107

    (28) Esf -> empty .

    EIF             reduce using rule 28 (Esf -> empty .)


state 108

    (51) EL -> OPENPAR O CLOSINGPAR Olt .

    THEN            reduce using rule 51 (EL -> OPENPAR O CLOSINGPAR Olt .)
    LET             reduce using rule 51 (EL -> OPENPAR O CLOSINGPAR Olt .)
    DIM             reduce using rule 51 (EL -> OPENPAR O CLOSINGPAR Olt .)
    IF              reduce using rule 51 (EL -> OPENPAR O CLOSINGPAR Olt .)
    FOR             reduce using rule 51 (EL -> OPENPAR O CLOSINGPAR Olt .)
    WHILE           reduce using rule 51 (EL -> OPENPAR O CLOSINGPAR Olt .)
    GOSUB           reduce using rule 51 (EL -> OPENPAR O CLOSINGPAR Olt .)
    INPUT           reduce using rule 51 (EL -> OPENPAR O CLOSINGPAR Olt .)
    PRINT           reduce using rule 51 (EL -> OPENPAR O CLOSINGPAR Olt .)
    SUBPROCEDURE    reduce using rule 51 (EL -> OPENPAR O CLOSINGPAR Olt .)
    END             reduce using rule 51 (EL -> OPENPAR O CLOSINGPAR Olt .)
    RETURN          reduce using rule 51 (EL -> OPENPAR O CLOSINGPAR Olt .)
    ELSE            reduce using rule 51 (EL -> OPENPAR O CLOSINGPAR Olt .)
    EIF             reduce using rule 51 (EL -> OPENPAR O CLOSINGPAR Olt .)
    WEND            reduce using rule 51 (EL -> OPENPAR O CLOSINGPAR Olt .)
    NEXT            reduce using rule 51 (EL -> OPENPAR O CLOSINGPAR Olt .)
    CLOSINGPAR      reduce using rule 51 (EL -> OPENPAR O CLOSINGPAR Olt .)


state 109

    (52) Olt -> OL . OPENPAR O CLOSINGPAR Olt

    OPENPAR         shift and go to state 131


state 110

    (53) Olt -> empty .

    THEN            reduce using rule 53 (Olt -> empty .)
    LET             reduce using rule 53 (Olt -> empty .)
    DIM             reduce using rule 53 (Olt -> empty .)
    IF              reduce using rule 53 (Olt -> empty .)
    FOR             reduce using rule 53 (Olt -> empty .)
    WHILE           reduce using rule 53 (Olt -> empty .)
    GOSUB           reduce using rule 53 (Olt -> empty .)
    INPUT           reduce using rule 53 (Olt -> empty .)
    PRINT           reduce using rule 53 (Olt -> empty .)
    SUBPROCEDURE    reduce using rule 53 (Olt -> empty .)
    END             reduce using rule 53 (Olt -> empty .)
    RETURN          reduce using rule 53 (Olt -> empty .)
    ELSE            reduce using rule 53 (Olt -> empty .)
    EIF             reduce using rule 53 (Olt -> empty .)
    WEND            reduce using rule 53 (Olt -> empty .)
    NEXT            reduce using rule 53 (Olt -> empty .)
    CLOSINGPAR      reduce using rule 53 (Olt -> empty .)


state 111

    (54) OL -> AND .

    OPENPAR         reduce using rule 54 (OL -> AND .)


state 112

    (55) OL -> OR .

    OPENPAR         reduce using rule 55 (OL -> OR .)


state 113

    (56) OL -> NOT .

    OPENPAR         reduce using rule 56 (OL -> NOT .)


state 114

    (57) O -> WORD EQUALTO WORD .

    CLOSINGPAR      reduce using rule 57 (O -> WORD EQUALTO WORD .)


state 115

    (58) O -> EA OPR EA .

    CLOSINGPAR      reduce using rule 58 (O -> EA OPR EA .)


state 116

    (61) O -> EA OPR ID .
    (43) N -> ID .
    (45) N -> ID . OPENBRACKET INTVAL CLOSINGBRACKET
    (46) N -> ID . OPENBRACKET setType Idv CLOSINGBRACKET

  ! reduce/reduce conflict for CLOSINGPAR resolved using rule 43 (N -> ID .)
    MULTIPLY        reduce using rule 43 (N -> ID .)
    DIVIDE          reduce using rule 43 (N -> ID .)
    PLUS            reduce using rule 43 (N -> ID .)
    MINUS           reduce using rule 43 (N -> ID .)
    CLOSINGPAR      reduce using rule 43 (N -> ID .)
    OPENBRACKET     shift and go to state 62

  ! CLOSINGPAR      [ reduce using rule 61 (O -> EA OPR ID .) ]


state 117

    (59) O -> ID OPR ID .
    (43) N -> ID .
    (45) N -> ID . OPENBRACKET INTVAL CLOSINGBRACKET
    (46) N -> ID . OPENBRACKET setType Idv CLOSINGBRACKET

  ! reduce/reduce conflict for CLOSINGPAR resolved using rule 43 (N -> ID .)
    MULTIPLY        reduce using rule 43 (N -> ID .)
    DIVIDE          reduce using rule 43 (N -> ID .)
    PLUS            reduce using rule 43 (N -> ID .)
    MINUS           reduce using rule 43 (N -> ID .)
    CLOSINGPAR      reduce using rule 43 (N -> ID .)
    OPENBRACKET     shift and go to state 62

  ! CLOSINGPAR      [ reduce using rule 59 (O -> ID OPR ID .) ]


state 118

    (60) O -> ID OPR EA .

    CLOSINGPAR      reduce using rule 60 (O -> ID OPR EA .)


state 119

    (19) E -> FOR ID EQUALS EA TO . Ex F NEXT ID
    (31) Ex -> . EA
    (32) Ex -> . ES
    (33) Ex -> . EL
    (34) Ex -> . ID
    (36) EA -> . P PLUS EA
    (37) EA -> . P MINUS EA
    (38) EA -> . P
    (35) ES -> . WORDVAL
    (49) EL -> . TRUE
    (50) EL -> . FALSE
    (51) EL -> . OPENPAR O CLOSINGPAR Olt
    (39) P -> . N MULTIPLY P
    (40) P -> . N DIVIDE P
    (41) P -> . N
    (42) N -> . cte
    (43) N -> . ID
    (44) N -> . OPENPAR EA CLOSINGPAR
    (45) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (46) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (47) cte -> . INTVAL
    (48) cte -> . FLOATVAL

    ID              shift and go to state 40
    WORDVAL         shift and go to state 35
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    OPENPAR         shift and go to state 42
    INTVAL          shift and go to state 45
    FLOATVAL        shift and go to state 46

    EA                             shift and go to state 37
    Ex                             shift and go to state 132
    ES                             shift and go to state 38
    EL                             shift and go to state 39
    P                              shift and go to state 41
    N                              shift and go to state 43
    cte                            shift and go to state 44

state 120

    (20) E -> WHILE OPENPAR EL CLOSINGPAR F . WEND

    WEND            shift and go to state 133


state 121

    (30) IDEx -> ID OPENBRACKET . setType Idv CLOSINGBRACKET
    (26) setType -> .

    ID              reduce using rule 26 (setType -> .)

    setType                        shift and go to state 134

state 122

    (45) N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .

    MULTIPLY        reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    DIVIDE          reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    PLUS            reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    MINUS           reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    LET             reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    DIM             reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    IF              reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    FOR             reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    WHILE           reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    GOSUB           reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    INPUT           reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    PRINT           reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    SUBPROCEDURE    reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    END             reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    RETURN          reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    ELSE            reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    EIF             reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    WEND            reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    NEXT            reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    EQUALTO         reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    GREATHER        reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    GREATHEREQUAL   reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    SMALLER         reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    SMALLEREQUAL    reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    NOTEQUAL        reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    CLOSINGPAR      reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    TO              reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    CLOSINGBRACKET  reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)


state 123

    (46) N -> ID OPENBRACKET setType Idv . CLOSINGBRACKET

    CLOSINGBRACKET  shift and go to state 135


state 124

    (2) V -> DIM setType Idv AS T Arr .

    LET             reduce using rule 2 (V -> DIM setType Idv AS T Arr .)
    DIM             reduce using rule 2 (V -> DIM setType Idv AS T Arr .)
    IF              reduce using rule 2 (V -> DIM setType Idv AS T Arr .)
    FOR             reduce using rule 2 (V -> DIM setType Idv AS T Arr .)
    WHILE           reduce using rule 2 (V -> DIM setType Idv AS T Arr .)
    GOSUB           reduce using rule 2 (V -> DIM setType Idv AS T Arr .)
    INPUT           reduce using rule 2 (V -> DIM setType Idv AS T Arr .)
    PRINT           reduce using rule 2 (V -> DIM setType Idv AS T Arr .)
    SUBPROCEDURE    reduce using rule 2 (V -> DIM setType Idv AS T Arr .)
    END             reduce using rule 2 (V -> DIM setType Idv AS T Arr .)


state 125

    (4) Arr -> OPENBRACKET . EA CLOSINGBRACKET Arr
    (5) Arr -> OPENBRACKET . ID CLOSINGBRACKET Arr
    (36) EA -> . P PLUS EA
    (37) EA -> . P MINUS EA
    (38) EA -> . P
    (39) P -> . N MULTIPLY P
    (40) P -> . N DIVIDE P
    (41) P -> . N
    (42) N -> . cte
    (43) N -> . ID
    (44) N -> . OPENPAR EA CLOSINGPAR
    (45) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (46) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (47) cte -> . INTVAL
    (48) cte -> . FLOATVAL

    ID              shift and go to state 137
    OPENPAR         shift and go to state 54
    INTVAL          shift and go to state 45
    FLOATVAL        shift and go to state 46

    EA                             shift and go to state 136
    P                              shift and go to state 41
    N                              shift and go to state 43
    cte                            shift and go to state 44

state 126

    (6) Arr -> empty .

    LET             reduce using rule 6 (Arr -> empty .)
    DIM             reduce using rule 6 (Arr -> empty .)
    IF              reduce using rule 6 (Arr -> empty .)
    FOR             reduce using rule 6 (Arr -> empty .)
    WHILE           reduce using rule 6 (Arr -> empty .)
    GOSUB           reduce using rule 6 (Arr -> empty .)
    INPUT           reduce using rule 6 (Arr -> empty .)
    PRINT           reduce using rule 6 (Arr -> empty .)
    SUBPROCEDURE    reduce using rule 6 (Arr -> empty .)
    END             reduce using rule 6 (Arr -> empty .)
    RETURN          reduce using rule 6 (Arr -> empty .)
    ELSE            reduce using rule 6 (Arr -> empty .)
    EIF             reduce using rule 6 (Arr -> empty .)
    WEND            reduce using rule 6 (Arr -> empty .)
    NEXT            reduce using rule 6 (Arr -> empty .)


state 127

    (10) S -> SUBPROCEDURE ID TWOPOINTS M RETURN . S
    (10) S -> . SUBPROCEDURE ID TWOPOINTS M RETURN S
    (11) S -> . empty
    (68) empty -> .

    SUBPROCEDURE    shift and go to state 20
    END             reduce using rule 68 (empty -> .)

    S                              shift and go to state 138
    empty                          shift and go to state 21

state 128

    (17) E -> DIM setType Idv AS T Arr .

    LET             reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    DIM             reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    IF              reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    FOR             reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    WHILE           reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    GOSUB           reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    INPUT           reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    PRINT           reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    SUBPROCEDURE    reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    END             reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    RETURN          reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    ELSE            reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    EIF             reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    WEND            reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    NEXT            reduce using rule 17 (E -> DIM setType Idv AS T Arr .)


state 129

    (18) E -> IF EL THEN F Esf EIF .

    LET             reduce using rule 18 (E -> IF EL THEN F Esf EIF .)
    DIM             reduce using rule 18 (E -> IF EL THEN F Esf EIF .)
    IF              reduce using rule 18 (E -> IF EL THEN F Esf EIF .)
    FOR             reduce using rule 18 (E -> IF EL THEN F Esf EIF .)
    WHILE           reduce using rule 18 (E -> IF EL THEN F Esf EIF .)
    GOSUB           reduce using rule 18 (E -> IF EL THEN F Esf EIF .)
    INPUT           reduce using rule 18 (E -> IF EL THEN F Esf EIF .)
    PRINT           reduce using rule 18 (E -> IF EL THEN F Esf EIF .)
    SUBPROCEDURE    reduce using rule 18 (E -> IF EL THEN F Esf EIF .)
    END             reduce using rule 18 (E -> IF EL THEN F Esf EIF .)
    RETURN          reduce using rule 18 (E -> IF EL THEN F Esf EIF .)
    ELSE            reduce using rule 18 (E -> IF EL THEN F Esf EIF .)
    EIF             reduce using rule 18 (E -> IF EL THEN F Esf EIF .)
    WEND            reduce using rule 18 (E -> IF EL THEN F Esf EIF .)
    NEXT            reduce using rule 18 (E -> IF EL THEN F Esf EIF .)


state 130

    (27) Esf -> ELSE F .

    EIF             reduce using rule 27 (Esf -> ELSE F .)


state 131

    (52) Olt -> OL OPENPAR . O CLOSINGPAR Olt
    (57) O -> . WORD EQUALTO WORD
    (58) O -> . EA OPR EA
    (59) O -> . ID OPR ID
    (60) O -> . ID OPR EA
    (61) O -> . EA OPR ID
    (36) EA -> . P PLUS EA
    (37) EA -> . P MINUS EA
    (38) EA -> . P
    (39) P -> . N MULTIPLY P
    (40) P -> . N DIVIDE P
    (41) P -> . N
    (42) N -> . cte
    (43) N -> . ID
    (44) N -> . OPENPAR EA CLOSINGPAR
    (45) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (46) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (47) cte -> . INTVAL
    (48) cte -> . FLOATVAL

    WORD            shift and go to state 56
    ID              shift and go to state 58
    OPENPAR         shift and go to state 54
    INTVAL          shift and go to state 45
    FLOATVAL        shift and go to state 46

    O                              shift and go to state 139
    EA                             shift and go to state 57
    P                              shift and go to state 41
    N                              shift and go to state 43
    cte                            shift and go to state 44

state 132

    (19) E -> FOR ID EQUALS EA TO Ex . F NEXT ID
    (14) F -> . E F
    (15) F -> . empty
    (16) E -> . LET setType Idv EQUALS Ex
    (17) E -> . DIM setType Idv AS T Arr
    (18) E -> . IF EL THEN F Esf EIF
    (19) E -> . FOR ID EQUALS EA TO Ex F NEXT ID
    (20) E -> . WHILE OPENPAR EL CLOSINGPAR F WEND
    (21) E -> . GOSUB ID
    (22) E -> . INPUT ES COMA IDEx
    (23) E -> . PRINT Ex
    (68) empty -> .

    LET             shift and go to state 10
    DIM             shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    GOSUB           shift and go to state 15
    INPUT           shift and go to state 16
    PRINT           shift and go to state 17
    NEXT            reduce using rule 68 (empty -> .)

    F                              shift and go to state 140
    E                              shift and go to state 9
    empty                          shift and go to state 24

state 133

    (20) E -> WHILE OPENPAR EL CLOSINGPAR F WEND .

    LET             reduce using rule 20 (E -> WHILE OPENPAR EL CLOSINGPAR F WEND .)
    DIM             reduce using rule 20 (E -> WHILE OPENPAR EL CLOSINGPAR F WEND .)
    IF              reduce using rule 20 (E -> WHILE OPENPAR EL CLOSINGPAR F WEND .)
    FOR             reduce using rule 20 (E -> WHILE OPENPAR EL CLOSINGPAR F WEND .)
    WHILE           reduce using rule 20 (E -> WHILE OPENPAR EL CLOSINGPAR F WEND .)
    GOSUB           reduce using rule 20 (E -> WHILE OPENPAR EL CLOSINGPAR F WEND .)
    INPUT           reduce using rule 20 (E -> WHILE OPENPAR EL CLOSINGPAR F WEND .)
    PRINT           reduce using rule 20 (E -> WHILE OPENPAR EL CLOSINGPAR F WEND .)
    SUBPROCEDURE    reduce using rule 20 (E -> WHILE OPENPAR EL CLOSINGPAR F WEND .)
    END             reduce using rule 20 (E -> WHILE OPENPAR EL CLOSINGPAR F WEND .)
    RETURN          reduce using rule 20 (E -> WHILE OPENPAR EL CLOSINGPAR F WEND .)
    ELSE            reduce using rule 20 (E -> WHILE OPENPAR EL CLOSINGPAR F WEND .)
    EIF             reduce using rule 20 (E -> WHILE OPENPAR EL CLOSINGPAR F WEND .)
    WEND            reduce using rule 20 (E -> WHILE OPENPAR EL CLOSINGPAR F WEND .)
    NEXT            reduce using rule 20 (E -> WHILE OPENPAR EL CLOSINGPAR F WEND .)


state 134

    (30) IDEx -> ID OPENBRACKET setType . Idv CLOSINGBRACKET
    (24) Idv -> . ID COMA Idv
    (25) Idv -> . ID

    ID              shift and go to state 48

    Idv                            shift and go to state 141

state 135

    (46) N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .

    MULTIPLY        reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    DIVIDE          reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    PLUS            reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    MINUS           reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    LET             reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    DIM             reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    IF              reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    FOR             reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    WHILE           reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    GOSUB           reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    INPUT           reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    PRINT           reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    SUBPROCEDURE    reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    END             reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    RETURN          reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    ELSE            reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    EIF             reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    WEND            reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    NEXT            reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    EQUALTO         reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    GREATHER        reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    GREATHEREQUAL   reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    SMALLER         reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    SMALLEREQUAL    reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    NOTEQUAL        reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    CLOSINGPAR      reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    TO              reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    CLOSINGBRACKET  reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)


state 136

    (4) Arr -> OPENBRACKET EA . CLOSINGBRACKET Arr

    CLOSINGBRACKET  shift and go to state 142


state 137

    (5) Arr -> OPENBRACKET ID . CLOSINGBRACKET Arr
    (43) N -> ID .
    (45) N -> ID . OPENBRACKET INTVAL CLOSINGBRACKET
    (46) N -> ID . OPENBRACKET setType Idv CLOSINGBRACKET

  ! shift/reduce conflict for CLOSINGBRACKET resolved as shift
    CLOSINGBRACKET  shift and go to state 143
    MULTIPLY        reduce using rule 43 (N -> ID .)
    DIVIDE          reduce using rule 43 (N -> ID .)
    PLUS            reduce using rule 43 (N -> ID .)
    MINUS           reduce using rule 43 (N -> ID .)
    OPENBRACKET     shift and go to state 62

  ! CLOSINGBRACKET  [ reduce using rule 43 (N -> ID .) ]


state 138

    (10) S -> SUBPROCEDURE ID TWOPOINTS M RETURN S .

    END             reduce using rule 10 (S -> SUBPROCEDURE ID TWOPOINTS M RETURN S .)


state 139

    (52) Olt -> OL OPENPAR O . CLOSINGPAR Olt

    CLOSINGPAR      shift and go to state 144


state 140

    (19) E -> FOR ID EQUALS EA TO Ex F . NEXT ID

    NEXT            shift and go to state 145


state 141

    (30) IDEx -> ID OPENBRACKET setType Idv . CLOSINGBRACKET

    CLOSINGBRACKET  shift and go to state 146


state 142

    (4) Arr -> OPENBRACKET EA CLOSINGBRACKET . Arr
    (4) Arr -> . OPENBRACKET EA CLOSINGBRACKET Arr
    (5) Arr -> . OPENBRACKET ID CLOSINGBRACKET Arr
    (6) Arr -> . empty
    (68) empty -> .

    OPENBRACKET     shift and go to state 125
    LET             reduce using rule 68 (empty -> .)
    DIM             reduce using rule 68 (empty -> .)
    IF              reduce using rule 68 (empty -> .)
    FOR             reduce using rule 68 (empty -> .)
    WHILE           reduce using rule 68 (empty -> .)
    GOSUB           reduce using rule 68 (empty -> .)
    INPUT           reduce using rule 68 (empty -> .)
    PRINT           reduce using rule 68 (empty -> .)
    SUBPROCEDURE    reduce using rule 68 (empty -> .)
    END             reduce using rule 68 (empty -> .)
    RETURN          reduce using rule 68 (empty -> .)
    ELSE            reduce using rule 68 (empty -> .)
    EIF             reduce using rule 68 (empty -> .)
    WEND            reduce using rule 68 (empty -> .)
    NEXT            reduce using rule 68 (empty -> .)

    Arr                            shift and go to state 147
    empty                          shift and go to state 126

state 143

    (5) Arr -> OPENBRACKET ID CLOSINGBRACKET . Arr
    (4) Arr -> . OPENBRACKET EA CLOSINGBRACKET Arr
    (5) Arr -> . OPENBRACKET ID CLOSINGBRACKET Arr
    (6) Arr -> . empty
    (68) empty -> .

    OPENBRACKET     shift and go to state 125
    LET             reduce using rule 68 (empty -> .)
    DIM             reduce using rule 68 (empty -> .)
    IF              reduce using rule 68 (empty -> .)
    FOR             reduce using rule 68 (empty -> .)
    WHILE           reduce using rule 68 (empty -> .)
    GOSUB           reduce using rule 68 (empty -> .)
    INPUT           reduce using rule 68 (empty -> .)
    PRINT           reduce using rule 68 (empty -> .)
    SUBPROCEDURE    reduce using rule 68 (empty -> .)
    END             reduce using rule 68 (empty -> .)
    RETURN          reduce using rule 68 (empty -> .)
    ELSE            reduce using rule 68 (empty -> .)
    EIF             reduce using rule 68 (empty -> .)
    WEND            reduce using rule 68 (empty -> .)
    NEXT            reduce using rule 68 (empty -> .)

    Arr                            shift and go to state 148
    empty                          shift and go to state 126

state 144

    (52) Olt -> OL OPENPAR O CLOSINGPAR . Olt
    (52) Olt -> . OL OPENPAR O CLOSINGPAR Olt
    (53) Olt -> . empty
    (54) OL -> . AND
    (55) OL -> . OR
    (56) OL -> . NOT
    (68) empty -> .

    AND             shift and go to state 111
    OR              shift and go to state 112
    NOT             shift and go to state 113
    THEN            reduce using rule 68 (empty -> .)
    LET             reduce using rule 68 (empty -> .)
    DIM             reduce using rule 68 (empty -> .)
    IF              reduce using rule 68 (empty -> .)
    FOR             reduce using rule 68 (empty -> .)
    WHILE           reduce using rule 68 (empty -> .)
    GOSUB           reduce using rule 68 (empty -> .)
    INPUT           reduce using rule 68 (empty -> .)
    PRINT           reduce using rule 68 (empty -> .)
    SUBPROCEDURE    reduce using rule 68 (empty -> .)
    END             reduce using rule 68 (empty -> .)
    RETURN          reduce using rule 68 (empty -> .)
    ELSE            reduce using rule 68 (empty -> .)
    EIF             reduce using rule 68 (empty -> .)
    WEND            reduce using rule 68 (empty -> .)
    NEXT            reduce using rule 68 (empty -> .)
    CLOSINGPAR      reduce using rule 68 (empty -> .)

    OL                             shift and go to state 109
    Olt                            shift and go to state 149
    empty                          shift and go to state 110

state 145

    (19) E -> FOR ID EQUALS EA TO Ex F NEXT . ID

    ID              shift and go to state 150


state 146

    (30) IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .

    LET             reduce using rule 30 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    DIM             reduce using rule 30 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    IF              reduce using rule 30 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    FOR             reduce using rule 30 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    WHILE           reduce using rule 30 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    GOSUB           reduce using rule 30 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    INPUT           reduce using rule 30 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    PRINT           reduce using rule 30 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    SUBPROCEDURE    reduce using rule 30 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    END             reduce using rule 30 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    RETURN          reduce using rule 30 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    ELSE            reduce using rule 30 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    EIF             reduce using rule 30 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    WEND            reduce using rule 30 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    NEXT            reduce using rule 30 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)


state 147

    (4) Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .

    LET             reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    DIM             reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    IF              reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    FOR             reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    WHILE           reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    GOSUB           reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    INPUT           reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    PRINT           reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    SUBPROCEDURE    reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    END             reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    RETURN          reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    ELSE            reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    EIF             reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    WEND            reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    NEXT            reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)


state 148

    (5) Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .

    LET             reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    DIM             reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    IF              reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    FOR             reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    WHILE           reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    GOSUB           reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    INPUT           reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    PRINT           reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    SUBPROCEDURE    reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    END             reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    RETURN          reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    ELSE            reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    EIF             reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    WEND            reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    NEXT            reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)


state 149

    (52) Olt -> OL OPENPAR O CLOSINGPAR Olt .

    THEN            reduce using rule 52 (Olt -> OL OPENPAR O CLOSINGPAR Olt .)
    LET             reduce using rule 52 (Olt -> OL OPENPAR O CLOSINGPAR Olt .)
    DIM             reduce using rule 52 (Olt -> OL OPENPAR O CLOSINGPAR Olt .)
    IF              reduce using rule 52 (Olt -> OL OPENPAR O CLOSINGPAR Olt .)
    FOR             reduce using rule 52 (Olt -> OL OPENPAR O CLOSINGPAR Olt .)
    WHILE           reduce using rule 52 (Olt -> OL OPENPAR O CLOSINGPAR Olt .)
    GOSUB           reduce using rule 52 (Olt -> OL OPENPAR O CLOSINGPAR Olt .)
    INPUT           reduce using rule 52 (Olt -> OL OPENPAR O CLOSINGPAR Olt .)
    PRINT           reduce using rule 52 (Olt -> OL OPENPAR O CLOSINGPAR Olt .)
    SUBPROCEDURE    reduce using rule 52 (Olt -> OL OPENPAR O CLOSINGPAR Olt .)
    END             reduce using rule 52 (Olt -> OL OPENPAR O CLOSINGPAR Olt .)
    RETURN          reduce using rule 52 (Olt -> OL OPENPAR O CLOSINGPAR Olt .)
    ELSE            reduce using rule 52 (Olt -> OL OPENPAR O CLOSINGPAR Olt .)
    EIF             reduce using rule 52 (Olt -> OL OPENPAR O CLOSINGPAR Olt .)
    WEND            reduce using rule 52 (Olt -> OL OPENPAR O CLOSINGPAR Olt .)
    NEXT            reduce using rule 52 (Olt -> OL OPENPAR O CLOSINGPAR Olt .)
    CLOSINGPAR      reduce using rule 52 (Olt -> OL OPENPAR O CLOSINGPAR Olt .)


state 150

    (19) E -> FOR ID EQUALS EA TO Ex F NEXT ID .

    LET             reduce using rule 19 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    DIM             reduce using rule 19 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    IF              reduce using rule 19 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    FOR             reduce using rule 19 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    WHILE           reduce using rule 19 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    GOSUB           reduce using rule 19 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    INPUT           reduce using rule 19 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    PRINT           reduce using rule 19 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    SUBPROCEDURE    reduce using rule 19 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    END             reduce using rule 19 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    RETURN          reduce using rule 19 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    ELSE            reduce using rule 19 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    EIF             reduce using rule 19 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    WEND            reduce using rule 19 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    NEXT            reduce using rule 19 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for DIM in state 2 resolved as shift
WARNING: shift/reduce conflict for LET in state 3 resolved as shift
WARNING: shift/reduce conflict for DIM in state 3 resolved as shift
WARNING: shift/reduce conflict for IF in state 3 resolved as shift
WARNING: shift/reduce conflict for FOR in state 3 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 3 resolved as shift
WARNING: shift/reduce conflict for GOSUB in state 3 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 3 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 3 resolved as shift
WARNING: shift/reduce conflict for LET in state 7 resolved as shift
WARNING: shift/reduce conflict for DIM in state 7 resolved as shift
WARNING: shift/reduce conflict for IF in state 7 resolved as shift
WARNING: shift/reduce conflict for FOR in state 7 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 7 resolved as shift
WARNING: shift/reduce conflict for GOSUB in state 7 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 7 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 7 resolved as shift
WARNING: shift/reduce conflict for LET in state 9 resolved as shift
WARNING: shift/reduce conflict for DIM in state 9 resolved as shift
WARNING: shift/reduce conflict for IF in state 9 resolved as shift
WARNING: shift/reduce conflict for FOR in state 9 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 9 resolved as shift
WARNING: shift/reduce conflict for GOSUB in state 9 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 9 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 9 resolved as shift
WARNING: shift/reduce conflict for EQUALTO in state 58 resolved as shift
WARNING: shift/reduce conflict for GREATHER in state 58 resolved as shift
WARNING: shift/reduce conflict for GREATHEREQUAL in state 58 resolved as shift
WARNING: shift/reduce conflict for SMALLER in state 58 resolved as shift
WARNING: shift/reduce conflict for SMALLEREQUAL in state 58 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 58 resolved as shift
WARNING: shift/reduce conflict for LET in state 70 resolved as shift
WARNING: shift/reduce conflict for DIM in state 70 resolved as shift
WARNING: shift/reduce conflict for IF in state 70 resolved as shift
WARNING: shift/reduce conflict for FOR in state 70 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 70 resolved as shift
WARNING: shift/reduce conflict for GOSUB in state 70 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 70 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 70 resolved as shift
WARNING: shift/reduce conflict for CLOSINGBRACKET in state 137 resolved as shift
WARNING: reduce/reduce conflict in state 8 resolved using rule (M -> empty)
WARNING: rejected rule (F -> empty) in state 8
WARNING: reduce/reduce conflict in state 40 resolved using rule (Ex -> ID)
WARNING: rejected rule (N -> ID) in state 40
WARNING: reduce/reduce conflict in state 116 resolved using rule (N -> ID)
WARNING: rejected rule (O -> EA OPR ID) in state 116
WARNING: reduce/reduce conflict in state 117 resolved using rule (N -> ID)
WARNING: rejected rule (O -> ID OPR ID) in state 117
WARNING: Rule (O -> EA OPR ID) is never reduced
WARNING: Rule (O -> ID OPR ID) is never reduced
