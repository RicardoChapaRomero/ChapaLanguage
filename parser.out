Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT

Grammar

Rule 0     S' -> PROGRAMA
Rule 1     PROGRAMA -> PROGRAM V M S END
Rule 2     V -> DIM setType Idv AS T Arr
Rule 3     V -> empty
Rule 4     Arr -> OPENBRACKET EA CLOSINGBRACKET Arr
Rule 5     Arr -> OPENBRACKET ID CLOSINGBRACKET Arr
Rule 6     Arr -> empty
Rule 7     T -> INT
Rule 8     T -> FLOAT
Rule 9     T -> WORD
Rule 10    S -> SUBPROCEDURE ID TWOPOINTS M RETURN S
Rule 11    S -> empty
Rule 12    M -> F M
Rule 13    M -> empty
Rule 14    F -> E F
Rule 15    F -> empty
Rule 16    E -> LET setType Idv EQUALS Ex
Rule 17    E -> DIM setType Idv AS T Arr
Rule 18    E -> IF EL THEN F Esf EIF
Rule 19    E -> FOR ID EQUALS EA TO Ex F NEXT ID
Rule 20    E -> WHILE OPENPAR EL CLOSINGPAR F WEND
Rule 21    E -> GOSUB ID
Rule 22    E -> INPUT ES COMA IDEx
Rule 23    E -> PRINT Ex
Rule 24    Idv -> ID COMA Idv
Rule 25    Idv -> ID
Rule 26    setType -> <empty>
Rule 27    Esf -> ELSE F
Rule 28    Esf -> empty
Rule 29    IDEx -> ID
Rule 30    IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET
Rule 31    Ex -> EA
Rule 32    Ex -> ES
Rule 33    Ex -> EL
Rule 34    Ex -> ID
Rule 35    ES -> WORDVAL
Rule 36    EA -> P PLUS EA
Rule 37    EA -> P MINUS EA
Rule 38    EA -> P
Rule 39    P -> N MULTIPLY P
Rule 40    P -> N DIVIDE P
Rule 41    P -> N
Rule 42    N -> cte saveID
Rule 43    N -> ID saveID
Rule 44    N -> OPENPAR EA CLOSINGPAR
Rule 45    N -> ID OPENBRACKET INTVAL CLOSINGBRACKET
Rule 46    N -> ID OPENBRACKET setType Idv CLOSINGBRACKET
Rule 47    saveOperator -> <empty>
Rule 48    saveID -> <empty>
Rule 49    solveOperation -> <empty>
Rule 50    cte -> INTVAL
Rule 51    cte -> FLOATVAL
Rule 52    EL -> TRUE
Rule 53    EL -> FALSE
Rule 54    EL -> OPENPAR O CLOSINGPAR Olt
Rule 55    Olt -> OL OPENPAR O CLOSINGPAR Olt
Rule 56    Olt -> empty
Rule 57    OL -> AND
Rule 58    OL -> OR
Rule 59    OL -> NOT
Rule 60    O -> WORD EQUALTO WORD
Rule 61    O -> EA OPR EA
Rule 62    O -> ID OPR ID
Rule 63    O -> ID OPR EA
Rule 64    O -> EA OPR ID
Rule 65    OPR -> EQUALTO
Rule 66    OPR -> GREATHER
Rule 67    OPR -> GREATHEREQUAL
Rule 68    OPR -> SMALLER
Rule 69    OPR -> SMALLEREQUAL
Rule 70    OPR -> NOTEQUAL
Rule 71    empty -> <empty>

Terminals, with rules where they appear

AND                  : 57
AS                   : 2 17
CLOSINGBRACKET       : 4 5 30 45 46
CLOSINGPAR           : 20 44 54 55
COMA                 : 22 24
COMMENT              : 
DIM                  : 2 17
DIVIDE               : 40
EIF                  : 18
ELSE                 : 27
END                  : 1
EQUALS               : 16 19
EQUALTO              : 60 65
FALSE                : 53
FLOAT                : 8
FLOATVAL             : 51
FOR                  : 19
GOSUB                : 21
GREATHER             : 66
GREATHEREQUAL        : 67
ID                   : 5 10 19 19 21 24 25 29 30 34 43 45 46 62 62 63 64
IF                   : 18
INPUT                : 22
INT                  : 7
INTVAL               : 45 50
LET                  : 16
MINUS                : 37
MULTIPLY             : 39
NEXT                 : 19
NOT                  : 59
NOTEQUAL             : 70
OPENBRACKET          : 4 5 30 45 46
OPENPAR              : 20 44 54 55
OR                   : 58
PLUS                 : 36
PRINT                : 23
PROGRAM              : 1
RETURN               : 10
SMALLER              : 68
SMALLEREQUAL         : 69
SUBPROCEDURE         : 10
THEN                 : 18
TO                   : 19
TRUE                 : 52
TWOPOINTS            : 10
WEND                 : 20
WHILE                : 20
WORD                 : 9 60 60
WORDVAL              : 35
error                : 

Nonterminals, with rules where they appear

Arr                  : 2 4 5 17
E                    : 14
EA                   : 4 19 31 36 37 44 61 61 63 64
EL                   : 18 20 33
ES                   : 22 32
Esf                  : 18
Ex                   : 16 19 23
F                    : 12 14 18 19 20 27
IDEx                 : 22
Idv                  : 2 16 17 24 30 46
M                    : 1 10 12
N                    : 39 40 41
O                    : 54 55
OL                   : 55
OPR                  : 61 62 63 64
Olt                  : 54 55
P                    : 36 37 38 39 40
PROGRAMA             : 0
S                    : 1 10
T                    : 2 17
V                    : 1
cte                  : 42
empty                : 3 6 11 13 15 28 56
saveID               : 42 43
saveOperator         : 
setType              : 2 16 17 30 46
solveOperation       : 

Parsing method: LALR

state 0

    (0) S' -> . PROGRAMA
    (1) PROGRAMA -> . PROGRAM V M S END

    PROGRAM         shift and go to state 2

    PROGRAMA                       shift and go to state 1

state 1

    (0) S' -> PROGRAMA .



state 2

    (1) PROGRAMA -> PROGRAM . V M S END
    (2) V -> . DIM setType Idv AS T Arr
    (3) V -> . empty
    (71) empty -> .

  ! shift/reduce conflict for DIM resolved as shift
    DIM             shift and go to state 4
    LET             reduce using rule 71 (empty -> .)
    IF              reduce using rule 71 (empty -> .)
    FOR             reduce using rule 71 (empty -> .)
    WHILE           reduce using rule 71 (empty -> .)
    GOSUB           reduce using rule 71 (empty -> .)
    INPUT           reduce using rule 71 (empty -> .)
    PRINT           reduce using rule 71 (empty -> .)
    SUBPROCEDURE    reduce using rule 71 (empty -> .)
    END             reduce using rule 71 (empty -> .)

  ! DIM             [ reduce using rule 71 (empty -> .) ]

    V                              shift and go to state 3
    empty                          shift and go to state 5

state 3

    (1) PROGRAMA -> PROGRAM V . M S END
    (12) M -> . F M
    (13) M -> . empty
    (14) F -> . E F
    (15) F -> . empty
    (71) empty -> .
    (16) E -> . LET setType Idv EQUALS Ex
    (17) E -> . DIM setType Idv AS T Arr
    (18) E -> . IF EL THEN F Esf EIF
    (19) E -> . FOR ID EQUALS EA TO Ex F NEXT ID
    (20) E -> . WHILE OPENPAR EL CLOSINGPAR F WEND
    (21) E -> . GOSUB ID
    (22) E -> . INPUT ES COMA IDEx
    (23) E -> . PRINT Ex

  ! shift/reduce conflict for LET resolved as shift
  ! shift/reduce conflict for DIM resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for GOSUB resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
    SUBPROCEDURE    reduce using rule 71 (empty -> .)
    END             reduce using rule 71 (empty -> .)
    LET             shift and go to state 10
    DIM             shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    GOSUB           shift and go to state 15
    INPUT           shift and go to state 16
    PRINT           shift and go to state 17

  ! LET             [ reduce using rule 71 (empty -> .) ]
  ! DIM             [ reduce using rule 71 (empty -> .) ]
  ! IF              [ reduce using rule 71 (empty -> .) ]
  ! FOR             [ reduce using rule 71 (empty -> .) ]
  ! WHILE           [ reduce using rule 71 (empty -> .) ]
  ! GOSUB           [ reduce using rule 71 (empty -> .) ]
  ! INPUT           [ reduce using rule 71 (empty -> .) ]
  ! PRINT           [ reduce using rule 71 (empty -> .) ]

    M                              shift and go to state 6
    F                              shift and go to state 7
    empty                          shift and go to state 8
    E                              shift and go to state 9

state 4

    (2) V -> DIM . setType Idv AS T Arr
    (26) setType -> .

    ID              reduce using rule 26 (setType -> .)

    setType                        shift and go to state 18

state 5

    (3) V -> empty .

    LET             reduce using rule 3 (V -> empty .)
    DIM             reduce using rule 3 (V -> empty .)
    IF              reduce using rule 3 (V -> empty .)
    FOR             reduce using rule 3 (V -> empty .)
    WHILE           reduce using rule 3 (V -> empty .)
    GOSUB           reduce using rule 3 (V -> empty .)
    INPUT           reduce using rule 3 (V -> empty .)
    PRINT           reduce using rule 3 (V -> empty .)
    SUBPROCEDURE    reduce using rule 3 (V -> empty .)
    END             reduce using rule 3 (V -> empty .)


state 6

    (1) PROGRAMA -> PROGRAM V M . S END
    (10) S -> . SUBPROCEDURE ID TWOPOINTS M RETURN S
    (11) S -> . empty
    (71) empty -> .

    SUBPROCEDURE    shift and go to state 20
    END             reduce using rule 71 (empty -> .)

    S                              shift and go to state 19
    empty                          shift and go to state 21

state 7

    (12) M -> F . M
    (12) M -> . F M
    (13) M -> . empty
    (14) F -> . E F
    (15) F -> . empty
    (71) empty -> .
    (16) E -> . LET setType Idv EQUALS Ex
    (17) E -> . DIM setType Idv AS T Arr
    (18) E -> . IF EL THEN F Esf EIF
    (19) E -> . FOR ID EQUALS EA TO Ex F NEXT ID
    (20) E -> . WHILE OPENPAR EL CLOSINGPAR F WEND
    (21) E -> . GOSUB ID
    (22) E -> . INPUT ES COMA IDEx
    (23) E -> . PRINT Ex

  ! shift/reduce conflict for LET resolved as shift
  ! shift/reduce conflict for DIM resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for GOSUB resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
    SUBPROCEDURE    reduce using rule 71 (empty -> .)
    END             reduce using rule 71 (empty -> .)
    RETURN          reduce using rule 71 (empty -> .)
    LET             shift and go to state 10
    DIM             shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    GOSUB           shift and go to state 15
    INPUT           shift and go to state 16
    PRINT           shift and go to state 17

  ! LET             [ reduce using rule 71 (empty -> .) ]
  ! DIM             [ reduce using rule 71 (empty -> .) ]
  ! IF              [ reduce using rule 71 (empty -> .) ]
  ! FOR             [ reduce using rule 71 (empty -> .) ]
  ! WHILE           [ reduce using rule 71 (empty -> .) ]
  ! GOSUB           [ reduce using rule 71 (empty -> .) ]
  ! INPUT           [ reduce using rule 71 (empty -> .) ]
  ! PRINT           [ reduce using rule 71 (empty -> .) ]

    F                              shift and go to state 7
    M                              shift and go to state 22
    empty                          shift and go to state 8
    E                              shift and go to state 9

state 8

    (13) M -> empty .
    (15) F -> empty .

  ! reduce/reduce conflict for SUBPROCEDURE resolved using rule 13 (M -> empty .)
  ! reduce/reduce conflict for END resolved using rule 13 (M -> empty .)
  ! reduce/reduce conflict for RETURN resolved using rule 13 (M -> empty .)
    SUBPROCEDURE    reduce using rule 13 (M -> empty .)
    END             reduce using rule 13 (M -> empty .)
    RETURN          reduce using rule 13 (M -> empty .)
    LET             reduce using rule 15 (F -> empty .)
    DIM             reduce using rule 15 (F -> empty .)
    IF              reduce using rule 15 (F -> empty .)
    FOR             reduce using rule 15 (F -> empty .)
    WHILE           reduce using rule 15 (F -> empty .)
    GOSUB           reduce using rule 15 (F -> empty .)
    INPUT           reduce using rule 15 (F -> empty .)
    PRINT           reduce using rule 15 (F -> empty .)

  ! SUBPROCEDURE    [ reduce using rule 15 (F -> empty .) ]
  ! END             [ reduce using rule 15 (F -> empty .) ]
  ! RETURN          [ reduce using rule 15 (F -> empty .) ]


state 9

    (14) F -> E . F
    (14) F -> . E F
    (15) F -> . empty
    (16) E -> . LET setType Idv EQUALS Ex
    (17) E -> . DIM setType Idv AS T Arr
    (18) E -> . IF EL THEN F Esf EIF
    (19) E -> . FOR ID EQUALS EA TO Ex F NEXT ID
    (20) E -> . WHILE OPENPAR EL CLOSINGPAR F WEND
    (21) E -> . GOSUB ID
    (22) E -> . INPUT ES COMA IDEx
    (23) E -> . PRINT Ex
    (71) empty -> .

  ! shift/reduce conflict for LET resolved as shift
  ! shift/reduce conflict for DIM resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for GOSUB resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
    LET             shift and go to state 10
    DIM             shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    GOSUB           shift and go to state 15
    INPUT           shift and go to state 16
    PRINT           shift and go to state 17
    SUBPROCEDURE    reduce using rule 71 (empty -> .)
    END             reduce using rule 71 (empty -> .)
    RETURN          reduce using rule 71 (empty -> .)
    ELSE            reduce using rule 71 (empty -> .)
    EIF             reduce using rule 71 (empty -> .)
    WEND            reduce using rule 71 (empty -> .)
    NEXT            reduce using rule 71 (empty -> .)

  ! LET             [ reduce using rule 71 (empty -> .) ]
  ! DIM             [ reduce using rule 71 (empty -> .) ]
  ! IF              [ reduce using rule 71 (empty -> .) ]
  ! FOR             [ reduce using rule 71 (empty -> .) ]
  ! WHILE           [ reduce using rule 71 (empty -> .) ]
  ! GOSUB           [ reduce using rule 71 (empty -> .) ]
  ! INPUT           [ reduce using rule 71 (empty -> .) ]
  ! PRINT           [ reduce using rule 71 (empty -> .) ]

    E                              shift and go to state 9
    F                              shift and go to state 23
    empty                          shift and go to state 24

state 10

    (16) E -> LET . setType Idv EQUALS Ex
    (26) setType -> .

    ID              reduce using rule 26 (setType -> .)

    setType                        shift and go to state 25

state 11

    (17) E -> DIM . setType Idv AS T Arr
    (26) setType -> .

    ID              reduce using rule 26 (setType -> .)

    setType                        shift and go to state 26

state 12

    (18) E -> IF . EL THEN F Esf EIF
    (52) EL -> . TRUE
    (53) EL -> . FALSE
    (54) EL -> . OPENPAR O CLOSINGPAR Olt

    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    OPENPAR         shift and go to state 30

    EL                             shift and go to state 27

state 13

    (19) E -> FOR . ID EQUALS EA TO Ex F NEXT ID

    ID              shift and go to state 31


state 14

    (20) E -> WHILE . OPENPAR EL CLOSINGPAR F WEND

    OPENPAR         shift and go to state 32


state 15

    (21) E -> GOSUB . ID

    ID              shift and go to state 33


state 16

    (22) E -> INPUT . ES COMA IDEx
    (35) ES -> . WORDVAL

    WORDVAL         shift and go to state 35

    ES                             shift and go to state 34

state 17

    (23) E -> PRINT . Ex
    (31) Ex -> . EA
    (32) Ex -> . ES
    (33) Ex -> . EL
    (34) Ex -> . ID
    (36) EA -> . P PLUS EA
    (37) EA -> . P MINUS EA
    (38) EA -> . P
    (35) ES -> . WORDVAL
    (52) EL -> . TRUE
    (53) EL -> . FALSE
    (54) EL -> . OPENPAR O CLOSINGPAR Olt
    (39) P -> . N MULTIPLY P
    (40) P -> . N DIVIDE P
    (41) P -> . N
    (42) N -> . cte saveID
    (43) N -> . ID saveID
    (44) N -> . OPENPAR EA CLOSINGPAR
    (45) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (46) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (50) cte -> . INTVAL
    (51) cte -> . FLOATVAL

    ID              shift and go to state 40
    WORDVAL         shift and go to state 35
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    OPENPAR         shift and go to state 42
    INTVAL          shift and go to state 45
    FLOATVAL        shift and go to state 46

    Ex                             shift and go to state 36
    EA                             shift and go to state 37
    ES                             shift and go to state 38
    EL                             shift and go to state 39
    P                              shift and go to state 41
    N                              shift and go to state 43
    cte                            shift and go to state 44

state 18

    (2) V -> DIM setType . Idv AS T Arr
    (24) Idv -> . ID COMA Idv
    (25) Idv -> . ID

    ID              shift and go to state 48

    Idv                            shift and go to state 47

state 19

    (1) PROGRAMA -> PROGRAM V M S . END

    END             shift and go to state 49


state 20

    (10) S -> SUBPROCEDURE . ID TWOPOINTS M RETURN S

    ID              shift and go to state 50


state 21

    (11) S -> empty .

    END             reduce using rule 11 (S -> empty .)


state 22

    (12) M -> F M .

    SUBPROCEDURE    reduce using rule 12 (M -> F M .)
    END             reduce using rule 12 (M -> F M .)
    RETURN          reduce using rule 12 (M -> F M .)


state 23

    (14) F -> E F .

    LET             reduce using rule 14 (F -> E F .)
    DIM             reduce using rule 14 (F -> E F .)
    IF              reduce using rule 14 (F -> E F .)
    FOR             reduce using rule 14 (F -> E F .)
    WHILE           reduce using rule 14 (F -> E F .)
    GOSUB           reduce using rule 14 (F -> E F .)
    INPUT           reduce using rule 14 (F -> E F .)
    PRINT           reduce using rule 14 (F -> E F .)
    SUBPROCEDURE    reduce using rule 14 (F -> E F .)
    END             reduce using rule 14 (F -> E F .)
    RETURN          reduce using rule 14 (F -> E F .)
    ELSE            reduce using rule 14 (F -> E F .)
    EIF             reduce using rule 14 (F -> E F .)
    WEND            reduce using rule 14 (F -> E F .)
    NEXT            reduce using rule 14 (F -> E F .)


state 24

    (15) F -> empty .

    LET             reduce using rule 15 (F -> empty .)
    DIM             reduce using rule 15 (F -> empty .)
    IF              reduce using rule 15 (F -> empty .)
    FOR             reduce using rule 15 (F -> empty .)
    WHILE           reduce using rule 15 (F -> empty .)
    GOSUB           reduce using rule 15 (F -> empty .)
    INPUT           reduce using rule 15 (F -> empty .)
    PRINT           reduce using rule 15 (F -> empty .)
    SUBPROCEDURE    reduce using rule 15 (F -> empty .)
    END             reduce using rule 15 (F -> empty .)
    RETURN          reduce using rule 15 (F -> empty .)
    ELSE            reduce using rule 15 (F -> empty .)
    EIF             reduce using rule 15 (F -> empty .)
    WEND            reduce using rule 15 (F -> empty .)
    NEXT            reduce using rule 15 (F -> empty .)


state 25

    (16) E -> LET setType . Idv EQUALS Ex
    (24) Idv -> . ID COMA Idv
    (25) Idv -> . ID

    ID              shift and go to state 48

    Idv                            shift and go to state 51

state 26

    (17) E -> DIM setType . Idv AS T Arr
    (24) Idv -> . ID COMA Idv
    (25) Idv -> . ID

    ID              shift and go to state 48

    Idv                            shift and go to state 52

state 27

    (18) E -> IF EL . THEN F Esf EIF

    THEN            shift and go to state 53


state 28

    (52) EL -> TRUE .

    THEN            reduce using rule 52 (EL -> TRUE .)
    LET             reduce using rule 52 (EL -> TRUE .)
    DIM             reduce using rule 52 (EL -> TRUE .)
    IF              reduce using rule 52 (EL -> TRUE .)
    FOR             reduce using rule 52 (EL -> TRUE .)
    WHILE           reduce using rule 52 (EL -> TRUE .)
    GOSUB           reduce using rule 52 (EL -> TRUE .)
    INPUT           reduce using rule 52 (EL -> TRUE .)
    PRINT           reduce using rule 52 (EL -> TRUE .)
    SUBPROCEDURE    reduce using rule 52 (EL -> TRUE .)
    END             reduce using rule 52 (EL -> TRUE .)
    RETURN          reduce using rule 52 (EL -> TRUE .)
    ELSE            reduce using rule 52 (EL -> TRUE .)
    EIF             reduce using rule 52 (EL -> TRUE .)
    WEND            reduce using rule 52 (EL -> TRUE .)
    NEXT            reduce using rule 52 (EL -> TRUE .)
    CLOSINGPAR      reduce using rule 52 (EL -> TRUE .)


state 29

    (53) EL -> FALSE .

    THEN            reduce using rule 53 (EL -> FALSE .)
    LET             reduce using rule 53 (EL -> FALSE .)
    DIM             reduce using rule 53 (EL -> FALSE .)
    IF              reduce using rule 53 (EL -> FALSE .)
    FOR             reduce using rule 53 (EL -> FALSE .)
    WHILE           reduce using rule 53 (EL -> FALSE .)
    GOSUB           reduce using rule 53 (EL -> FALSE .)
    INPUT           reduce using rule 53 (EL -> FALSE .)
    PRINT           reduce using rule 53 (EL -> FALSE .)
    SUBPROCEDURE    reduce using rule 53 (EL -> FALSE .)
    END             reduce using rule 53 (EL -> FALSE .)
    RETURN          reduce using rule 53 (EL -> FALSE .)
    ELSE            reduce using rule 53 (EL -> FALSE .)
    EIF             reduce using rule 53 (EL -> FALSE .)
    WEND            reduce using rule 53 (EL -> FALSE .)
    NEXT            reduce using rule 53 (EL -> FALSE .)
    CLOSINGPAR      reduce using rule 53 (EL -> FALSE .)


state 30

    (54) EL -> OPENPAR . O CLOSINGPAR Olt
    (60) O -> . WORD EQUALTO WORD
    (61) O -> . EA OPR EA
    (62) O -> . ID OPR ID
    (63) O -> . ID OPR EA
    (64) O -> . EA OPR ID
    (36) EA -> . P PLUS EA
    (37) EA -> . P MINUS EA
    (38) EA -> . P
    (39) P -> . N MULTIPLY P
    (40) P -> . N DIVIDE P
    (41) P -> . N
    (42) N -> . cte saveID
    (43) N -> . ID saveID
    (44) N -> . OPENPAR EA CLOSINGPAR
    (45) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (46) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (50) cte -> . INTVAL
    (51) cte -> . FLOATVAL

    WORD            shift and go to state 56
    ID              shift and go to state 58
    OPENPAR         shift and go to state 54
    INTVAL          shift and go to state 45
    FLOATVAL        shift and go to state 46

    O                              shift and go to state 55
    EA                             shift and go to state 57
    P                              shift and go to state 41
    N                              shift and go to state 43
    cte                            shift and go to state 44

state 31

    (19) E -> FOR ID . EQUALS EA TO Ex F NEXT ID

    EQUALS          shift and go to state 59


state 32

    (20) E -> WHILE OPENPAR . EL CLOSINGPAR F WEND
    (52) EL -> . TRUE
    (53) EL -> . FALSE
    (54) EL -> . OPENPAR O CLOSINGPAR Olt

    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    OPENPAR         shift and go to state 30

    EL                             shift and go to state 60

state 33

    (21) E -> GOSUB ID .

    LET             reduce using rule 21 (E -> GOSUB ID .)
    DIM             reduce using rule 21 (E -> GOSUB ID .)
    IF              reduce using rule 21 (E -> GOSUB ID .)
    FOR             reduce using rule 21 (E -> GOSUB ID .)
    WHILE           reduce using rule 21 (E -> GOSUB ID .)
    GOSUB           reduce using rule 21 (E -> GOSUB ID .)
    INPUT           reduce using rule 21 (E -> GOSUB ID .)
    PRINT           reduce using rule 21 (E -> GOSUB ID .)
    SUBPROCEDURE    reduce using rule 21 (E -> GOSUB ID .)
    END             reduce using rule 21 (E -> GOSUB ID .)
    RETURN          reduce using rule 21 (E -> GOSUB ID .)
    ELSE            reduce using rule 21 (E -> GOSUB ID .)
    EIF             reduce using rule 21 (E -> GOSUB ID .)
    WEND            reduce using rule 21 (E -> GOSUB ID .)
    NEXT            reduce using rule 21 (E -> GOSUB ID .)


state 34

    (22) E -> INPUT ES . COMA IDEx

    COMA            shift and go to state 61


state 35

    (35) ES -> WORDVAL .

    COMA            reduce using rule 35 (ES -> WORDVAL .)
    LET             reduce using rule 35 (ES -> WORDVAL .)
    DIM             reduce using rule 35 (ES -> WORDVAL .)
    IF              reduce using rule 35 (ES -> WORDVAL .)
    FOR             reduce using rule 35 (ES -> WORDVAL .)
    WHILE           reduce using rule 35 (ES -> WORDVAL .)
    GOSUB           reduce using rule 35 (ES -> WORDVAL .)
    INPUT           reduce using rule 35 (ES -> WORDVAL .)
    PRINT           reduce using rule 35 (ES -> WORDVAL .)
    SUBPROCEDURE    reduce using rule 35 (ES -> WORDVAL .)
    END             reduce using rule 35 (ES -> WORDVAL .)
    RETURN          reduce using rule 35 (ES -> WORDVAL .)
    ELSE            reduce using rule 35 (ES -> WORDVAL .)
    EIF             reduce using rule 35 (ES -> WORDVAL .)
    WEND            reduce using rule 35 (ES -> WORDVAL .)
    NEXT            reduce using rule 35 (ES -> WORDVAL .)


state 36

    (23) E -> PRINT Ex .

    LET             reduce using rule 23 (E -> PRINT Ex .)
    DIM             reduce using rule 23 (E -> PRINT Ex .)
    IF              reduce using rule 23 (E -> PRINT Ex .)
    FOR             reduce using rule 23 (E -> PRINT Ex .)
    WHILE           reduce using rule 23 (E -> PRINT Ex .)
    GOSUB           reduce using rule 23 (E -> PRINT Ex .)
    INPUT           reduce using rule 23 (E -> PRINT Ex .)
    PRINT           reduce using rule 23 (E -> PRINT Ex .)
    SUBPROCEDURE    reduce using rule 23 (E -> PRINT Ex .)
    END             reduce using rule 23 (E -> PRINT Ex .)
    RETURN          reduce using rule 23 (E -> PRINT Ex .)
    ELSE            reduce using rule 23 (E -> PRINT Ex .)
    EIF             reduce using rule 23 (E -> PRINT Ex .)
    WEND            reduce using rule 23 (E -> PRINT Ex .)
    NEXT            reduce using rule 23 (E -> PRINT Ex .)


state 37

    (31) Ex -> EA .

    LET             reduce using rule 31 (Ex -> EA .)
    DIM             reduce using rule 31 (Ex -> EA .)
    IF              reduce using rule 31 (Ex -> EA .)
    FOR             reduce using rule 31 (Ex -> EA .)
    WHILE           reduce using rule 31 (Ex -> EA .)
    GOSUB           reduce using rule 31 (Ex -> EA .)
    INPUT           reduce using rule 31 (Ex -> EA .)
    PRINT           reduce using rule 31 (Ex -> EA .)
    SUBPROCEDURE    reduce using rule 31 (Ex -> EA .)
    END             reduce using rule 31 (Ex -> EA .)
    RETURN          reduce using rule 31 (Ex -> EA .)
    ELSE            reduce using rule 31 (Ex -> EA .)
    EIF             reduce using rule 31 (Ex -> EA .)
    WEND            reduce using rule 31 (Ex -> EA .)
    NEXT            reduce using rule 31 (Ex -> EA .)


state 38

    (32) Ex -> ES .

    LET             reduce using rule 32 (Ex -> ES .)
    DIM             reduce using rule 32 (Ex -> ES .)
    IF              reduce using rule 32 (Ex -> ES .)
    FOR             reduce using rule 32 (Ex -> ES .)
    WHILE           reduce using rule 32 (Ex -> ES .)
    GOSUB           reduce using rule 32 (Ex -> ES .)
    INPUT           reduce using rule 32 (Ex -> ES .)
    PRINT           reduce using rule 32 (Ex -> ES .)
    SUBPROCEDURE    reduce using rule 32 (Ex -> ES .)
    END             reduce using rule 32 (Ex -> ES .)
    RETURN          reduce using rule 32 (Ex -> ES .)
    ELSE            reduce using rule 32 (Ex -> ES .)
    EIF             reduce using rule 32 (Ex -> ES .)
    WEND            reduce using rule 32 (Ex -> ES .)
    NEXT            reduce using rule 32 (Ex -> ES .)


state 39

    (33) Ex -> EL .

    LET             reduce using rule 33 (Ex -> EL .)
    DIM             reduce using rule 33 (Ex -> EL .)
    IF              reduce using rule 33 (Ex -> EL .)
    FOR             reduce using rule 33 (Ex -> EL .)
    WHILE           reduce using rule 33 (Ex -> EL .)
    GOSUB           reduce using rule 33 (Ex -> EL .)
    INPUT           reduce using rule 33 (Ex -> EL .)
    PRINT           reduce using rule 33 (Ex -> EL .)
    SUBPROCEDURE    reduce using rule 33 (Ex -> EL .)
    END             reduce using rule 33 (Ex -> EL .)
    RETURN          reduce using rule 33 (Ex -> EL .)
    ELSE            reduce using rule 33 (Ex -> EL .)
    EIF             reduce using rule 33 (Ex -> EL .)
    WEND            reduce using rule 33 (Ex -> EL .)
    NEXT            reduce using rule 33 (Ex -> EL .)


state 40

    (34) Ex -> ID .
    (43) N -> ID . saveID
    (45) N -> ID . OPENBRACKET INTVAL CLOSINGBRACKET
    (46) N -> ID . OPENBRACKET setType Idv CLOSINGBRACKET
    (48) saveID -> .

  ! reduce/reduce conflict for LET resolved using rule 34 (Ex -> ID .)
  ! reduce/reduce conflict for DIM resolved using rule 34 (Ex -> ID .)
  ! reduce/reduce conflict for IF resolved using rule 34 (Ex -> ID .)
  ! reduce/reduce conflict for FOR resolved using rule 34 (Ex -> ID .)
  ! reduce/reduce conflict for WHILE resolved using rule 34 (Ex -> ID .)
  ! reduce/reduce conflict for GOSUB resolved using rule 34 (Ex -> ID .)
  ! reduce/reduce conflict for INPUT resolved using rule 34 (Ex -> ID .)
  ! reduce/reduce conflict for PRINT resolved using rule 34 (Ex -> ID .)
  ! reduce/reduce conflict for SUBPROCEDURE resolved using rule 34 (Ex -> ID .)
  ! reduce/reduce conflict for END resolved using rule 34 (Ex -> ID .)
  ! reduce/reduce conflict for RETURN resolved using rule 34 (Ex -> ID .)
  ! reduce/reduce conflict for ELSE resolved using rule 34 (Ex -> ID .)
  ! reduce/reduce conflict for EIF resolved using rule 34 (Ex -> ID .)
  ! reduce/reduce conflict for WEND resolved using rule 34 (Ex -> ID .)
  ! reduce/reduce conflict for NEXT resolved using rule 34 (Ex -> ID .)
    LET             reduce using rule 34 (Ex -> ID .)
    DIM             reduce using rule 34 (Ex -> ID .)
    IF              reduce using rule 34 (Ex -> ID .)
    FOR             reduce using rule 34 (Ex -> ID .)
    WHILE           reduce using rule 34 (Ex -> ID .)
    GOSUB           reduce using rule 34 (Ex -> ID .)
    INPUT           reduce using rule 34 (Ex -> ID .)
    PRINT           reduce using rule 34 (Ex -> ID .)
    SUBPROCEDURE    reduce using rule 34 (Ex -> ID .)
    END             reduce using rule 34 (Ex -> ID .)
    RETURN          reduce using rule 34 (Ex -> ID .)
    ELSE            reduce using rule 34 (Ex -> ID .)
    EIF             reduce using rule 34 (Ex -> ID .)
    WEND            reduce using rule 34 (Ex -> ID .)
    NEXT            reduce using rule 34 (Ex -> ID .)
    OPENBRACKET     shift and go to state 63
    MULTIPLY        reduce using rule 48 (saveID -> .)
    DIVIDE          reduce using rule 48 (saveID -> .)
    PLUS            reduce using rule 48 (saveID -> .)
    MINUS           reduce using rule 48 (saveID -> .)

  ! LET             [ reduce using rule 48 (saveID -> .) ]
  ! DIM             [ reduce using rule 48 (saveID -> .) ]
  ! IF              [ reduce using rule 48 (saveID -> .) ]
  ! FOR             [ reduce using rule 48 (saveID -> .) ]
  ! WHILE           [ reduce using rule 48 (saveID -> .) ]
  ! GOSUB           [ reduce using rule 48 (saveID -> .) ]
  ! INPUT           [ reduce using rule 48 (saveID -> .) ]
  ! PRINT           [ reduce using rule 48 (saveID -> .) ]
  ! SUBPROCEDURE    [ reduce using rule 48 (saveID -> .) ]
  ! END             [ reduce using rule 48 (saveID -> .) ]
  ! RETURN          [ reduce using rule 48 (saveID -> .) ]
  ! ELSE            [ reduce using rule 48 (saveID -> .) ]
  ! EIF             [ reduce using rule 48 (saveID -> .) ]
  ! WEND            [ reduce using rule 48 (saveID -> .) ]
  ! NEXT            [ reduce using rule 48 (saveID -> .) ]

    saveID                         shift and go to state 62

state 41

    (36) EA -> P . PLUS EA
    (37) EA -> P . MINUS EA
    (38) EA -> P .

    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    LET             reduce using rule 38 (EA -> P .)
    DIM             reduce using rule 38 (EA -> P .)
    IF              reduce using rule 38 (EA -> P .)
    FOR             reduce using rule 38 (EA -> P .)
    WHILE           reduce using rule 38 (EA -> P .)
    GOSUB           reduce using rule 38 (EA -> P .)
    INPUT           reduce using rule 38 (EA -> P .)
    PRINT           reduce using rule 38 (EA -> P .)
    SUBPROCEDURE    reduce using rule 38 (EA -> P .)
    END             reduce using rule 38 (EA -> P .)
    RETURN          reduce using rule 38 (EA -> P .)
    ELSE            reduce using rule 38 (EA -> P .)
    EIF             reduce using rule 38 (EA -> P .)
    WEND            reduce using rule 38 (EA -> P .)
    NEXT            reduce using rule 38 (EA -> P .)
    EQUALTO         reduce using rule 38 (EA -> P .)
    GREATHER        reduce using rule 38 (EA -> P .)
    GREATHEREQUAL   reduce using rule 38 (EA -> P .)
    SMALLER         reduce using rule 38 (EA -> P .)
    SMALLEREQUAL    reduce using rule 38 (EA -> P .)
    NOTEQUAL        reduce using rule 38 (EA -> P .)
    CLOSINGPAR      reduce using rule 38 (EA -> P .)
    TO              reduce using rule 38 (EA -> P .)
    CLOSINGBRACKET  reduce using rule 38 (EA -> P .)


state 42

    (54) EL -> OPENPAR . O CLOSINGPAR Olt
    (44) N -> OPENPAR . EA CLOSINGPAR
    (60) O -> . WORD EQUALTO WORD
    (61) O -> . EA OPR EA
    (62) O -> . ID OPR ID
    (63) O -> . ID OPR EA
    (64) O -> . EA OPR ID
    (36) EA -> . P PLUS EA
    (37) EA -> . P MINUS EA
    (38) EA -> . P
    (39) P -> . N MULTIPLY P
    (40) P -> . N DIVIDE P
    (41) P -> . N
    (42) N -> . cte saveID
    (43) N -> . ID saveID
    (44) N -> . OPENPAR EA CLOSINGPAR
    (45) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (46) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (50) cte -> . INTVAL
    (51) cte -> . FLOATVAL

    WORD            shift and go to state 56
    ID              shift and go to state 58
    OPENPAR         shift and go to state 54
    INTVAL          shift and go to state 45
    FLOATVAL        shift and go to state 46

    O                              shift and go to state 55
    EA                             shift and go to state 66
    P                              shift and go to state 41
    N                              shift and go to state 43
    cte                            shift and go to state 44

state 43

    (39) P -> N . MULTIPLY P
    (40) P -> N . DIVIDE P
    (41) P -> N .

    MULTIPLY        shift and go to state 67
    DIVIDE          shift and go to state 68
    PLUS            reduce using rule 41 (P -> N .)
    MINUS           reduce using rule 41 (P -> N .)
    LET             reduce using rule 41 (P -> N .)
    DIM             reduce using rule 41 (P -> N .)
    IF              reduce using rule 41 (P -> N .)
    FOR             reduce using rule 41 (P -> N .)
    WHILE           reduce using rule 41 (P -> N .)
    GOSUB           reduce using rule 41 (P -> N .)
    INPUT           reduce using rule 41 (P -> N .)
    PRINT           reduce using rule 41 (P -> N .)
    SUBPROCEDURE    reduce using rule 41 (P -> N .)
    END             reduce using rule 41 (P -> N .)
    RETURN          reduce using rule 41 (P -> N .)
    ELSE            reduce using rule 41 (P -> N .)
    EIF             reduce using rule 41 (P -> N .)
    WEND            reduce using rule 41 (P -> N .)
    NEXT            reduce using rule 41 (P -> N .)
    EQUALTO         reduce using rule 41 (P -> N .)
    GREATHER        reduce using rule 41 (P -> N .)
    GREATHEREQUAL   reduce using rule 41 (P -> N .)
    SMALLER         reduce using rule 41 (P -> N .)
    SMALLEREQUAL    reduce using rule 41 (P -> N .)
    NOTEQUAL        reduce using rule 41 (P -> N .)
    CLOSINGPAR      reduce using rule 41 (P -> N .)
    TO              reduce using rule 41 (P -> N .)
    CLOSINGBRACKET  reduce using rule 41 (P -> N .)


state 44

    (42) N -> cte . saveID
    (48) saveID -> .

    MULTIPLY        reduce using rule 48 (saveID -> .)
    DIVIDE          reduce using rule 48 (saveID -> .)
    PLUS            reduce using rule 48 (saveID -> .)
    MINUS           reduce using rule 48 (saveID -> .)
    LET             reduce using rule 48 (saveID -> .)
    DIM             reduce using rule 48 (saveID -> .)
    IF              reduce using rule 48 (saveID -> .)
    FOR             reduce using rule 48 (saveID -> .)
    WHILE           reduce using rule 48 (saveID -> .)
    GOSUB           reduce using rule 48 (saveID -> .)
    INPUT           reduce using rule 48 (saveID -> .)
    PRINT           reduce using rule 48 (saveID -> .)
    SUBPROCEDURE    reduce using rule 48 (saveID -> .)
    END             reduce using rule 48 (saveID -> .)
    RETURN          reduce using rule 48 (saveID -> .)
    ELSE            reduce using rule 48 (saveID -> .)
    EIF             reduce using rule 48 (saveID -> .)
    WEND            reduce using rule 48 (saveID -> .)
    NEXT            reduce using rule 48 (saveID -> .)
    EQUALTO         reduce using rule 48 (saveID -> .)
    GREATHER        reduce using rule 48 (saveID -> .)
    GREATHEREQUAL   reduce using rule 48 (saveID -> .)
    SMALLER         reduce using rule 48 (saveID -> .)
    SMALLEREQUAL    reduce using rule 48 (saveID -> .)
    NOTEQUAL        reduce using rule 48 (saveID -> .)
    CLOSINGPAR      reduce using rule 48 (saveID -> .)
    TO              reduce using rule 48 (saveID -> .)
    CLOSINGBRACKET  reduce using rule 48 (saveID -> .)

    saveID                         shift and go to state 69

state 45

    (50) cte -> INTVAL .

    MULTIPLY        reduce using rule 50 (cte -> INTVAL .)
    DIVIDE          reduce using rule 50 (cte -> INTVAL .)
    PLUS            reduce using rule 50 (cte -> INTVAL .)
    MINUS           reduce using rule 50 (cte -> INTVAL .)
    LET             reduce using rule 50 (cte -> INTVAL .)
    DIM             reduce using rule 50 (cte -> INTVAL .)
    IF              reduce using rule 50 (cte -> INTVAL .)
    FOR             reduce using rule 50 (cte -> INTVAL .)
    WHILE           reduce using rule 50 (cte -> INTVAL .)
    GOSUB           reduce using rule 50 (cte -> INTVAL .)
    INPUT           reduce using rule 50 (cte -> INTVAL .)
    PRINT           reduce using rule 50 (cte -> INTVAL .)
    SUBPROCEDURE    reduce using rule 50 (cte -> INTVAL .)
    END             reduce using rule 50 (cte -> INTVAL .)
    RETURN          reduce using rule 50 (cte -> INTVAL .)
    ELSE            reduce using rule 50 (cte -> INTVAL .)
    EIF             reduce using rule 50 (cte -> INTVAL .)
    WEND            reduce using rule 50 (cte -> INTVAL .)
    NEXT            reduce using rule 50 (cte -> INTVAL .)
    EQUALTO         reduce using rule 50 (cte -> INTVAL .)
    GREATHER        reduce using rule 50 (cte -> INTVAL .)
    GREATHEREQUAL   reduce using rule 50 (cte -> INTVAL .)
    SMALLER         reduce using rule 50 (cte -> INTVAL .)
    SMALLEREQUAL    reduce using rule 50 (cte -> INTVAL .)
    NOTEQUAL        reduce using rule 50 (cte -> INTVAL .)
    CLOSINGPAR      reduce using rule 50 (cte -> INTVAL .)
    TO              reduce using rule 50 (cte -> INTVAL .)
    CLOSINGBRACKET  reduce using rule 50 (cte -> INTVAL .)


state 46

    (51) cte -> FLOATVAL .

    MULTIPLY        reduce using rule 51 (cte -> FLOATVAL .)
    DIVIDE          reduce using rule 51 (cte -> FLOATVAL .)
    PLUS            reduce using rule 51 (cte -> FLOATVAL .)
    MINUS           reduce using rule 51 (cte -> FLOATVAL .)
    LET             reduce using rule 51 (cte -> FLOATVAL .)
    DIM             reduce using rule 51 (cte -> FLOATVAL .)
    IF              reduce using rule 51 (cte -> FLOATVAL .)
    FOR             reduce using rule 51 (cte -> FLOATVAL .)
    WHILE           reduce using rule 51 (cte -> FLOATVAL .)
    GOSUB           reduce using rule 51 (cte -> FLOATVAL .)
    INPUT           reduce using rule 51 (cte -> FLOATVAL .)
    PRINT           reduce using rule 51 (cte -> FLOATVAL .)
    SUBPROCEDURE    reduce using rule 51 (cte -> FLOATVAL .)
    END             reduce using rule 51 (cte -> FLOATVAL .)
    RETURN          reduce using rule 51 (cte -> FLOATVAL .)
    ELSE            reduce using rule 51 (cte -> FLOATVAL .)
    EIF             reduce using rule 51 (cte -> FLOATVAL .)
    WEND            reduce using rule 51 (cte -> FLOATVAL .)
    NEXT            reduce using rule 51 (cte -> FLOATVAL .)
    EQUALTO         reduce using rule 51 (cte -> FLOATVAL .)
    GREATHER        reduce using rule 51 (cte -> FLOATVAL .)
    GREATHEREQUAL   reduce using rule 51 (cte -> FLOATVAL .)
    SMALLER         reduce using rule 51 (cte -> FLOATVAL .)
    SMALLEREQUAL    reduce using rule 51 (cte -> FLOATVAL .)
    NOTEQUAL        reduce using rule 51 (cte -> FLOATVAL .)
    CLOSINGPAR      reduce using rule 51 (cte -> FLOATVAL .)
    TO              reduce using rule 51 (cte -> FLOATVAL .)
    CLOSINGBRACKET  reduce using rule 51 (cte -> FLOATVAL .)


state 47

    (2) V -> DIM setType Idv . AS T Arr

    AS              shift and go to state 70


state 48

    (24) Idv -> ID . COMA Idv
    (25) Idv -> ID .

    COMA            shift and go to state 71
    AS              reduce using rule 25 (Idv -> ID .)
    EQUALS          reduce using rule 25 (Idv -> ID .)
    CLOSINGBRACKET  reduce using rule 25 (Idv -> ID .)


state 49

    (1) PROGRAMA -> PROGRAM V M S END .

    $end            reduce using rule 1 (PROGRAMA -> PROGRAM V M S END .)


state 50

    (10) S -> SUBPROCEDURE ID . TWOPOINTS M RETURN S

    TWOPOINTS       shift and go to state 72


state 51

    (16) E -> LET setType Idv . EQUALS Ex

    EQUALS          shift and go to state 73


state 52

    (17) E -> DIM setType Idv . AS T Arr

    AS              shift and go to state 74


state 53

    (18) E -> IF EL THEN . F Esf EIF
    (14) F -> . E F
    (15) F -> . empty
    (16) E -> . LET setType Idv EQUALS Ex
    (17) E -> . DIM setType Idv AS T Arr
    (18) E -> . IF EL THEN F Esf EIF
    (19) E -> . FOR ID EQUALS EA TO Ex F NEXT ID
    (20) E -> . WHILE OPENPAR EL CLOSINGPAR F WEND
    (21) E -> . GOSUB ID
    (22) E -> . INPUT ES COMA IDEx
    (23) E -> . PRINT Ex
    (71) empty -> .

    LET             shift and go to state 10
    DIM             shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    GOSUB           shift and go to state 15
    INPUT           shift and go to state 16
    PRINT           shift and go to state 17
    ELSE            reduce using rule 71 (empty -> .)
    EIF             reduce using rule 71 (empty -> .)

    F                              shift and go to state 75
    E                              shift and go to state 9
    empty                          shift and go to state 24

state 54

    (44) N -> OPENPAR . EA CLOSINGPAR
    (36) EA -> . P PLUS EA
    (37) EA -> . P MINUS EA
    (38) EA -> . P
    (39) P -> . N MULTIPLY P
    (40) P -> . N DIVIDE P
    (41) P -> . N
    (42) N -> . cte saveID
    (43) N -> . ID saveID
    (44) N -> . OPENPAR EA CLOSINGPAR
    (45) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (46) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (50) cte -> . INTVAL
    (51) cte -> . FLOATVAL

    ID              shift and go to state 77
    OPENPAR         shift and go to state 54
    INTVAL          shift and go to state 45
    FLOATVAL        shift and go to state 46

    EA                             shift and go to state 76
    P                              shift and go to state 41
    N                              shift and go to state 43
    cte                            shift and go to state 44

state 55

    (54) EL -> OPENPAR O . CLOSINGPAR Olt

    CLOSINGPAR      shift and go to state 78


state 56

    (60) O -> WORD . EQUALTO WORD

    EQUALTO         shift and go to state 79


state 57

    (61) O -> EA . OPR EA
    (64) O -> EA . OPR ID
    (65) OPR -> . EQUALTO
    (66) OPR -> . GREATHER
    (67) OPR -> . GREATHEREQUAL
    (68) OPR -> . SMALLER
    (69) OPR -> . SMALLEREQUAL
    (70) OPR -> . NOTEQUAL

    EQUALTO         shift and go to state 81
    GREATHER        shift and go to state 82
    GREATHEREQUAL   shift and go to state 83
    SMALLER         shift and go to state 84
    SMALLEREQUAL    shift and go to state 85
    NOTEQUAL        shift and go to state 86

    OPR                            shift and go to state 80

state 58

    (62) O -> ID . OPR ID
    (63) O -> ID . OPR EA
    (43) N -> ID . saveID
    (45) N -> ID . OPENBRACKET INTVAL CLOSINGBRACKET
    (46) N -> ID . OPENBRACKET setType Idv CLOSINGBRACKET
    (65) OPR -> . EQUALTO
    (66) OPR -> . GREATHER
    (67) OPR -> . GREATHEREQUAL
    (68) OPR -> . SMALLER
    (69) OPR -> . SMALLEREQUAL
    (70) OPR -> . NOTEQUAL
    (48) saveID -> .

  ! shift/reduce conflict for EQUALTO resolved as shift
  ! shift/reduce conflict for GREATHER resolved as shift
  ! shift/reduce conflict for GREATHEREQUAL resolved as shift
  ! shift/reduce conflict for SMALLER resolved as shift
  ! shift/reduce conflict for SMALLEREQUAL resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
    OPENBRACKET     shift and go to state 63
    EQUALTO         shift and go to state 81
    GREATHER        shift and go to state 82
    GREATHEREQUAL   shift and go to state 83
    SMALLER         shift and go to state 84
    SMALLEREQUAL    shift and go to state 85
    NOTEQUAL        shift and go to state 86
    MULTIPLY        reduce using rule 48 (saveID -> .)
    DIVIDE          reduce using rule 48 (saveID -> .)
    PLUS            reduce using rule 48 (saveID -> .)
    MINUS           reduce using rule 48 (saveID -> .)
    CLOSINGPAR      reduce using rule 48 (saveID -> .)

  ! EQUALTO         [ reduce using rule 48 (saveID -> .) ]
  ! GREATHER        [ reduce using rule 48 (saveID -> .) ]
  ! GREATHEREQUAL   [ reduce using rule 48 (saveID -> .) ]
  ! SMALLER         [ reduce using rule 48 (saveID -> .) ]
  ! SMALLEREQUAL    [ reduce using rule 48 (saveID -> .) ]
  ! NOTEQUAL        [ reduce using rule 48 (saveID -> .) ]

    OPR                            shift and go to state 87
    saveID                         shift and go to state 62

state 59

    (19) E -> FOR ID EQUALS . EA TO Ex F NEXT ID
    (36) EA -> . P PLUS EA
    (37) EA -> . P MINUS EA
    (38) EA -> . P
    (39) P -> . N MULTIPLY P
    (40) P -> . N DIVIDE P
    (41) P -> . N
    (42) N -> . cte saveID
    (43) N -> . ID saveID
    (44) N -> . OPENPAR EA CLOSINGPAR
    (45) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (46) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (50) cte -> . INTVAL
    (51) cte -> . FLOATVAL

    ID              shift and go to state 77
    OPENPAR         shift and go to state 54
    INTVAL          shift and go to state 45
    FLOATVAL        shift and go to state 46

    EA                             shift and go to state 88
    P                              shift and go to state 41
    N                              shift and go to state 43
    cte                            shift and go to state 44

state 60

    (20) E -> WHILE OPENPAR EL . CLOSINGPAR F WEND

    CLOSINGPAR      shift and go to state 89


state 61

    (22) E -> INPUT ES COMA . IDEx
    (29) IDEx -> . ID
    (30) IDEx -> . ID OPENBRACKET setType Idv CLOSINGBRACKET

    ID              shift and go to state 91

    IDEx                           shift and go to state 90

state 62

    (43) N -> ID saveID .

    MULTIPLY        reduce using rule 43 (N -> ID saveID .)
    DIVIDE          reduce using rule 43 (N -> ID saveID .)
    PLUS            reduce using rule 43 (N -> ID saveID .)
    MINUS           reduce using rule 43 (N -> ID saveID .)
    LET             reduce using rule 43 (N -> ID saveID .)
    DIM             reduce using rule 43 (N -> ID saveID .)
    IF              reduce using rule 43 (N -> ID saveID .)
    FOR             reduce using rule 43 (N -> ID saveID .)
    WHILE           reduce using rule 43 (N -> ID saveID .)
    GOSUB           reduce using rule 43 (N -> ID saveID .)
    INPUT           reduce using rule 43 (N -> ID saveID .)
    PRINT           reduce using rule 43 (N -> ID saveID .)
    SUBPROCEDURE    reduce using rule 43 (N -> ID saveID .)
    END             reduce using rule 43 (N -> ID saveID .)
    RETURN          reduce using rule 43 (N -> ID saveID .)
    ELSE            reduce using rule 43 (N -> ID saveID .)
    EIF             reduce using rule 43 (N -> ID saveID .)
    WEND            reduce using rule 43 (N -> ID saveID .)
    NEXT            reduce using rule 43 (N -> ID saveID .)
    EQUALTO         reduce using rule 43 (N -> ID saveID .)
    GREATHER        reduce using rule 43 (N -> ID saveID .)
    GREATHEREQUAL   reduce using rule 43 (N -> ID saveID .)
    SMALLER         reduce using rule 43 (N -> ID saveID .)
    SMALLEREQUAL    reduce using rule 43 (N -> ID saveID .)
    NOTEQUAL        reduce using rule 43 (N -> ID saveID .)
    CLOSINGPAR      reduce using rule 43 (N -> ID saveID .)
    TO              reduce using rule 43 (N -> ID saveID .)
    CLOSINGBRACKET  reduce using rule 43 (N -> ID saveID .)


state 63

    (45) N -> ID OPENBRACKET . INTVAL CLOSINGBRACKET
    (46) N -> ID OPENBRACKET . setType Idv CLOSINGBRACKET
    (26) setType -> .

    INTVAL          shift and go to state 92
    ID              reduce using rule 26 (setType -> .)

    setType                        shift and go to state 93

state 64

    (36) EA -> P PLUS . EA
    (36) EA -> . P PLUS EA
    (37) EA -> . P MINUS EA
    (38) EA -> . P
    (39) P -> . N MULTIPLY P
    (40) P -> . N DIVIDE P
    (41) P -> . N
    (42) N -> . cte saveID
    (43) N -> . ID saveID
    (44) N -> . OPENPAR EA CLOSINGPAR
    (45) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (46) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (50) cte -> . INTVAL
    (51) cte -> . FLOATVAL

    ID              shift and go to state 77
    OPENPAR         shift and go to state 54
    INTVAL          shift and go to state 45
    FLOATVAL        shift and go to state 46

    P                              shift and go to state 41
    EA                             shift and go to state 94
    N                              shift and go to state 43
    cte                            shift and go to state 44

state 65

    (37) EA -> P MINUS . EA
    (36) EA -> . P PLUS EA
    (37) EA -> . P MINUS EA
    (38) EA -> . P
    (39) P -> . N MULTIPLY P
    (40) P -> . N DIVIDE P
    (41) P -> . N
    (42) N -> . cte saveID
    (43) N -> . ID saveID
    (44) N -> . OPENPAR EA CLOSINGPAR
    (45) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (46) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (50) cte -> . INTVAL
    (51) cte -> . FLOATVAL

    ID              shift and go to state 77
    OPENPAR         shift and go to state 54
    INTVAL          shift and go to state 45
    FLOATVAL        shift and go to state 46

    P                              shift and go to state 41
    EA                             shift and go to state 95
    N                              shift and go to state 43
    cte                            shift and go to state 44

state 66

    (44) N -> OPENPAR EA . CLOSINGPAR
    (61) O -> EA . OPR EA
    (64) O -> EA . OPR ID
    (65) OPR -> . EQUALTO
    (66) OPR -> . GREATHER
    (67) OPR -> . GREATHEREQUAL
    (68) OPR -> . SMALLER
    (69) OPR -> . SMALLEREQUAL
    (70) OPR -> . NOTEQUAL

    CLOSINGPAR      shift and go to state 96
    EQUALTO         shift and go to state 81
    GREATHER        shift and go to state 82
    GREATHEREQUAL   shift and go to state 83
    SMALLER         shift and go to state 84
    SMALLEREQUAL    shift and go to state 85
    NOTEQUAL        shift and go to state 86

    OPR                            shift and go to state 80

state 67

    (39) P -> N MULTIPLY . P
    (39) P -> . N MULTIPLY P
    (40) P -> . N DIVIDE P
    (41) P -> . N
    (42) N -> . cte saveID
    (43) N -> . ID saveID
    (44) N -> . OPENPAR EA CLOSINGPAR
    (45) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (46) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (50) cte -> . INTVAL
    (51) cte -> . FLOATVAL

    ID              shift and go to state 77
    OPENPAR         shift and go to state 54
    INTVAL          shift and go to state 45
    FLOATVAL        shift and go to state 46

    N                              shift and go to state 43
    P                              shift and go to state 97
    cte                            shift and go to state 44

state 68

    (40) P -> N DIVIDE . P
    (39) P -> . N MULTIPLY P
    (40) P -> . N DIVIDE P
    (41) P -> . N
    (42) N -> . cte saveID
    (43) N -> . ID saveID
    (44) N -> . OPENPAR EA CLOSINGPAR
    (45) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (46) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (50) cte -> . INTVAL
    (51) cte -> . FLOATVAL

    ID              shift and go to state 77
    OPENPAR         shift and go to state 54
    INTVAL          shift and go to state 45
    FLOATVAL        shift and go to state 46

    N                              shift and go to state 43
    P                              shift and go to state 98
    cte                            shift and go to state 44

state 69

    (42) N -> cte saveID .

    MULTIPLY        reduce using rule 42 (N -> cte saveID .)
    DIVIDE          reduce using rule 42 (N -> cte saveID .)
    PLUS            reduce using rule 42 (N -> cte saveID .)
    MINUS           reduce using rule 42 (N -> cte saveID .)
    LET             reduce using rule 42 (N -> cte saveID .)
    DIM             reduce using rule 42 (N -> cte saveID .)
    IF              reduce using rule 42 (N -> cte saveID .)
    FOR             reduce using rule 42 (N -> cte saveID .)
    WHILE           reduce using rule 42 (N -> cte saveID .)
    GOSUB           reduce using rule 42 (N -> cte saveID .)
    INPUT           reduce using rule 42 (N -> cte saveID .)
    PRINT           reduce using rule 42 (N -> cte saveID .)
    SUBPROCEDURE    reduce using rule 42 (N -> cte saveID .)
    END             reduce using rule 42 (N -> cte saveID .)
    RETURN          reduce using rule 42 (N -> cte saveID .)
    ELSE            reduce using rule 42 (N -> cte saveID .)
    EIF             reduce using rule 42 (N -> cte saveID .)
    WEND            reduce using rule 42 (N -> cte saveID .)
    NEXT            reduce using rule 42 (N -> cte saveID .)
    EQUALTO         reduce using rule 42 (N -> cte saveID .)
    GREATHER        reduce using rule 42 (N -> cte saveID .)
    GREATHEREQUAL   reduce using rule 42 (N -> cte saveID .)
    SMALLER         reduce using rule 42 (N -> cte saveID .)
    SMALLEREQUAL    reduce using rule 42 (N -> cte saveID .)
    NOTEQUAL        reduce using rule 42 (N -> cte saveID .)
    CLOSINGPAR      reduce using rule 42 (N -> cte saveID .)
    TO              reduce using rule 42 (N -> cte saveID .)
    CLOSINGBRACKET  reduce using rule 42 (N -> cte saveID .)


state 70

    (2) V -> DIM setType Idv AS . T Arr
    (7) T -> . INT
    (8) T -> . FLOAT
    (9) T -> . WORD

    INT             shift and go to state 100
    FLOAT           shift and go to state 101
    WORD            shift and go to state 102

    T                              shift and go to state 99

state 71

    (24) Idv -> ID COMA . Idv
    (24) Idv -> . ID COMA Idv
    (25) Idv -> . ID

    ID              shift and go to state 48

    Idv                            shift and go to state 103

state 72

    (10) S -> SUBPROCEDURE ID TWOPOINTS . M RETURN S
    (12) M -> . F M
    (13) M -> . empty
    (14) F -> . E F
    (15) F -> . empty
    (71) empty -> .
    (16) E -> . LET setType Idv EQUALS Ex
    (17) E -> . DIM setType Idv AS T Arr
    (18) E -> . IF EL THEN F Esf EIF
    (19) E -> . FOR ID EQUALS EA TO Ex F NEXT ID
    (20) E -> . WHILE OPENPAR EL CLOSINGPAR F WEND
    (21) E -> . GOSUB ID
    (22) E -> . INPUT ES COMA IDEx
    (23) E -> . PRINT Ex

  ! shift/reduce conflict for LET resolved as shift
  ! shift/reduce conflict for DIM resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for GOSUB resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
    RETURN          reduce using rule 71 (empty -> .)
    LET             shift and go to state 10
    DIM             shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    GOSUB           shift and go to state 15
    INPUT           shift and go to state 16
    PRINT           shift and go to state 17

  ! LET             [ reduce using rule 71 (empty -> .) ]
  ! DIM             [ reduce using rule 71 (empty -> .) ]
  ! IF              [ reduce using rule 71 (empty -> .) ]
  ! FOR             [ reduce using rule 71 (empty -> .) ]
  ! WHILE           [ reduce using rule 71 (empty -> .) ]
  ! GOSUB           [ reduce using rule 71 (empty -> .) ]
  ! INPUT           [ reduce using rule 71 (empty -> .) ]
  ! PRINT           [ reduce using rule 71 (empty -> .) ]

    M                              shift and go to state 104
    F                              shift and go to state 7
    empty                          shift and go to state 8
    E                              shift and go to state 9

state 73

    (16) E -> LET setType Idv EQUALS . Ex
    (31) Ex -> . EA
    (32) Ex -> . ES
    (33) Ex -> . EL
    (34) Ex -> . ID
    (36) EA -> . P PLUS EA
    (37) EA -> . P MINUS EA
    (38) EA -> . P
    (35) ES -> . WORDVAL
    (52) EL -> . TRUE
    (53) EL -> . FALSE
    (54) EL -> . OPENPAR O CLOSINGPAR Olt
    (39) P -> . N MULTIPLY P
    (40) P -> . N DIVIDE P
    (41) P -> . N
    (42) N -> . cte saveID
    (43) N -> . ID saveID
    (44) N -> . OPENPAR EA CLOSINGPAR
    (45) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (46) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (50) cte -> . INTVAL
    (51) cte -> . FLOATVAL

    ID              shift and go to state 40
    WORDVAL         shift and go to state 35
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    OPENPAR         shift and go to state 42
    INTVAL          shift and go to state 45
    FLOATVAL        shift and go to state 46

    Ex                             shift and go to state 105
    EA                             shift and go to state 37
    ES                             shift and go to state 38
    EL                             shift and go to state 39
    P                              shift and go to state 41
    N                              shift and go to state 43
    cte                            shift and go to state 44

state 74

    (17) E -> DIM setType Idv AS . T Arr
    (7) T -> . INT
    (8) T -> . FLOAT
    (9) T -> . WORD

    INT             shift and go to state 100
    FLOAT           shift and go to state 101
    WORD            shift and go to state 102

    T                              shift and go to state 106

state 75

    (18) E -> IF EL THEN F . Esf EIF
    (27) Esf -> . ELSE F
    (28) Esf -> . empty
    (71) empty -> .

    ELSE            shift and go to state 108
    EIF             reduce using rule 71 (empty -> .)

    Esf                            shift and go to state 107
    empty                          shift and go to state 109

state 76

    (44) N -> OPENPAR EA . CLOSINGPAR

    CLOSINGPAR      shift and go to state 96


state 77

    (43) N -> ID . saveID
    (45) N -> ID . OPENBRACKET INTVAL CLOSINGBRACKET
    (46) N -> ID . OPENBRACKET setType Idv CLOSINGBRACKET
    (48) saveID -> .

    OPENBRACKET     shift and go to state 63
    MULTIPLY        reduce using rule 48 (saveID -> .)
    DIVIDE          reduce using rule 48 (saveID -> .)
    PLUS            reduce using rule 48 (saveID -> .)
    MINUS           reduce using rule 48 (saveID -> .)
    CLOSINGPAR      reduce using rule 48 (saveID -> .)
    TO              reduce using rule 48 (saveID -> .)
    LET             reduce using rule 48 (saveID -> .)
    DIM             reduce using rule 48 (saveID -> .)
    IF              reduce using rule 48 (saveID -> .)
    FOR             reduce using rule 48 (saveID -> .)
    WHILE           reduce using rule 48 (saveID -> .)
    GOSUB           reduce using rule 48 (saveID -> .)
    INPUT           reduce using rule 48 (saveID -> .)
    PRINT           reduce using rule 48 (saveID -> .)
    SUBPROCEDURE    reduce using rule 48 (saveID -> .)
    END             reduce using rule 48 (saveID -> .)
    RETURN          reduce using rule 48 (saveID -> .)
    ELSE            reduce using rule 48 (saveID -> .)
    EIF             reduce using rule 48 (saveID -> .)
    WEND            reduce using rule 48 (saveID -> .)
    NEXT            reduce using rule 48 (saveID -> .)
    EQUALTO         reduce using rule 48 (saveID -> .)
    GREATHER        reduce using rule 48 (saveID -> .)
    GREATHEREQUAL   reduce using rule 48 (saveID -> .)
    SMALLER         reduce using rule 48 (saveID -> .)
    SMALLEREQUAL    reduce using rule 48 (saveID -> .)
    NOTEQUAL        reduce using rule 48 (saveID -> .)
    CLOSINGBRACKET  reduce using rule 48 (saveID -> .)

    saveID                         shift and go to state 62

state 78

    (54) EL -> OPENPAR O CLOSINGPAR . Olt
    (55) Olt -> . OL OPENPAR O CLOSINGPAR Olt
    (56) Olt -> . empty
    (57) OL -> . AND
    (58) OL -> . OR
    (59) OL -> . NOT
    (71) empty -> .

    AND             shift and go to state 113
    OR              shift and go to state 114
    NOT             shift and go to state 115
    THEN            reduce using rule 71 (empty -> .)
    LET             reduce using rule 71 (empty -> .)
    DIM             reduce using rule 71 (empty -> .)
    IF              reduce using rule 71 (empty -> .)
    FOR             reduce using rule 71 (empty -> .)
    WHILE           reduce using rule 71 (empty -> .)
    GOSUB           reduce using rule 71 (empty -> .)
    INPUT           reduce using rule 71 (empty -> .)
    PRINT           reduce using rule 71 (empty -> .)
    SUBPROCEDURE    reduce using rule 71 (empty -> .)
    END             reduce using rule 71 (empty -> .)
    RETURN          reduce using rule 71 (empty -> .)
    ELSE            reduce using rule 71 (empty -> .)
    EIF             reduce using rule 71 (empty -> .)
    WEND            reduce using rule 71 (empty -> .)
    NEXT            reduce using rule 71 (empty -> .)
    CLOSINGPAR      reduce using rule 71 (empty -> .)

    Olt                            shift and go to state 110
    OL                             shift and go to state 111
    empty                          shift and go to state 112

state 79

    (60) O -> WORD EQUALTO . WORD

    WORD            shift and go to state 116


state 80

    (61) O -> EA OPR . EA
    (64) O -> EA OPR . ID
    (36) EA -> . P PLUS EA
    (37) EA -> . P MINUS EA
    (38) EA -> . P
    (39) P -> . N MULTIPLY P
    (40) P -> . N DIVIDE P
    (41) P -> . N
    (42) N -> . cte saveID
    (43) N -> . ID saveID
    (44) N -> . OPENPAR EA CLOSINGPAR
    (45) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (46) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (50) cte -> . INTVAL
    (51) cte -> . FLOATVAL

    ID              shift and go to state 118
    OPENPAR         shift and go to state 54
    INTVAL          shift and go to state 45
    FLOATVAL        shift and go to state 46

    EA                             shift and go to state 117
    P                              shift and go to state 41
    N                              shift and go to state 43
    cte                            shift and go to state 44

state 81

    (65) OPR -> EQUALTO .

    ID              reduce using rule 65 (OPR -> EQUALTO .)
    OPENPAR         reduce using rule 65 (OPR -> EQUALTO .)
    INTVAL          reduce using rule 65 (OPR -> EQUALTO .)
    FLOATVAL        reduce using rule 65 (OPR -> EQUALTO .)


state 82

    (66) OPR -> GREATHER .

    ID              reduce using rule 66 (OPR -> GREATHER .)
    OPENPAR         reduce using rule 66 (OPR -> GREATHER .)
    INTVAL          reduce using rule 66 (OPR -> GREATHER .)
    FLOATVAL        reduce using rule 66 (OPR -> GREATHER .)


state 83

    (67) OPR -> GREATHEREQUAL .

    ID              reduce using rule 67 (OPR -> GREATHEREQUAL .)
    OPENPAR         reduce using rule 67 (OPR -> GREATHEREQUAL .)
    INTVAL          reduce using rule 67 (OPR -> GREATHEREQUAL .)
    FLOATVAL        reduce using rule 67 (OPR -> GREATHEREQUAL .)


state 84

    (68) OPR -> SMALLER .

    ID              reduce using rule 68 (OPR -> SMALLER .)
    OPENPAR         reduce using rule 68 (OPR -> SMALLER .)
    INTVAL          reduce using rule 68 (OPR -> SMALLER .)
    FLOATVAL        reduce using rule 68 (OPR -> SMALLER .)


state 85

    (69) OPR -> SMALLEREQUAL .

    ID              reduce using rule 69 (OPR -> SMALLEREQUAL .)
    OPENPAR         reduce using rule 69 (OPR -> SMALLEREQUAL .)
    INTVAL          reduce using rule 69 (OPR -> SMALLEREQUAL .)
    FLOATVAL        reduce using rule 69 (OPR -> SMALLEREQUAL .)


state 86

    (70) OPR -> NOTEQUAL .

    ID              reduce using rule 70 (OPR -> NOTEQUAL .)
    OPENPAR         reduce using rule 70 (OPR -> NOTEQUAL .)
    INTVAL          reduce using rule 70 (OPR -> NOTEQUAL .)
    FLOATVAL        reduce using rule 70 (OPR -> NOTEQUAL .)


state 87

    (62) O -> ID OPR . ID
    (63) O -> ID OPR . EA
    (36) EA -> . P PLUS EA
    (37) EA -> . P MINUS EA
    (38) EA -> . P
    (39) P -> . N MULTIPLY P
    (40) P -> . N DIVIDE P
    (41) P -> . N
    (42) N -> . cte saveID
    (43) N -> . ID saveID
    (44) N -> . OPENPAR EA CLOSINGPAR
    (45) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (46) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (50) cte -> . INTVAL
    (51) cte -> . FLOATVAL

    ID              shift and go to state 119
    OPENPAR         shift and go to state 54
    INTVAL          shift and go to state 45
    FLOATVAL        shift and go to state 46

    EA                             shift and go to state 120
    P                              shift and go to state 41
    N                              shift and go to state 43
    cte                            shift and go to state 44

state 88

    (19) E -> FOR ID EQUALS EA . TO Ex F NEXT ID

    TO              shift and go to state 121


state 89

    (20) E -> WHILE OPENPAR EL CLOSINGPAR . F WEND
    (14) F -> . E F
    (15) F -> . empty
    (16) E -> . LET setType Idv EQUALS Ex
    (17) E -> . DIM setType Idv AS T Arr
    (18) E -> . IF EL THEN F Esf EIF
    (19) E -> . FOR ID EQUALS EA TO Ex F NEXT ID
    (20) E -> . WHILE OPENPAR EL CLOSINGPAR F WEND
    (21) E -> . GOSUB ID
    (22) E -> . INPUT ES COMA IDEx
    (23) E -> . PRINT Ex
    (71) empty -> .

    LET             shift and go to state 10
    DIM             shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    GOSUB           shift and go to state 15
    INPUT           shift and go to state 16
    PRINT           shift and go to state 17
    WEND            reduce using rule 71 (empty -> .)

    F                              shift and go to state 122
    E                              shift and go to state 9
    empty                          shift and go to state 24

state 90

    (22) E -> INPUT ES COMA IDEx .

    LET             reduce using rule 22 (E -> INPUT ES COMA IDEx .)
    DIM             reduce using rule 22 (E -> INPUT ES COMA IDEx .)
    IF              reduce using rule 22 (E -> INPUT ES COMA IDEx .)
    FOR             reduce using rule 22 (E -> INPUT ES COMA IDEx .)
    WHILE           reduce using rule 22 (E -> INPUT ES COMA IDEx .)
    GOSUB           reduce using rule 22 (E -> INPUT ES COMA IDEx .)
    INPUT           reduce using rule 22 (E -> INPUT ES COMA IDEx .)
    PRINT           reduce using rule 22 (E -> INPUT ES COMA IDEx .)
    SUBPROCEDURE    reduce using rule 22 (E -> INPUT ES COMA IDEx .)
    END             reduce using rule 22 (E -> INPUT ES COMA IDEx .)
    RETURN          reduce using rule 22 (E -> INPUT ES COMA IDEx .)
    ELSE            reduce using rule 22 (E -> INPUT ES COMA IDEx .)
    EIF             reduce using rule 22 (E -> INPUT ES COMA IDEx .)
    WEND            reduce using rule 22 (E -> INPUT ES COMA IDEx .)
    NEXT            reduce using rule 22 (E -> INPUT ES COMA IDEx .)


state 91

    (29) IDEx -> ID .
    (30) IDEx -> ID . OPENBRACKET setType Idv CLOSINGBRACKET

    LET             reduce using rule 29 (IDEx -> ID .)
    DIM             reduce using rule 29 (IDEx -> ID .)
    IF              reduce using rule 29 (IDEx -> ID .)
    FOR             reduce using rule 29 (IDEx -> ID .)
    WHILE           reduce using rule 29 (IDEx -> ID .)
    GOSUB           reduce using rule 29 (IDEx -> ID .)
    INPUT           reduce using rule 29 (IDEx -> ID .)
    PRINT           reduce using rule 29 (IDEx -> ID .)
    SUBPROCEDURE    reduce using rule 29 (IDEx -> ID .)
    END             reduce using rule 29 (IDEx -> ID .)
    RETURN          reduce using rule 29 (IDEx -> ID .)
    ELSE            reduce using rule 29 (IDEx -> ID .)
    EIF             reduce using rule 29 (IDEx -> ID .)
    WEND            reduce using rule 29 (IDEx -> ID .)
    NEXT            reduce using rule 29 (IDEx -> ID .)
    OPENBRACKET     shift and go to state 123


state 92

    (45) N -> ID OPENBRACKET INTVAL . CLOSINGBRACKET

    CLOSINGBRACKET  shift and go to state 124


state 93

    (46) N -> ID OPENBRACKET setType . Idv CLOSINGBRACKET
    (24) Idv -> . ID COMA Idv
    (25) Idv -> . ID

    ID              shift and go to state 48

    Idv                            shift and go to state 125

state 94

    (36) EA -> P PLUS EA .

    LET             reduce using rule 36 (EA -> P PLUS EA .)
    DIM             reduce using rule 36 (EA -> P PLUS EA .)
    IF              reduce using rule 36 (EA -> P PLUS EA .)
    FOR             reduce using rule 36 (EA -> P PLUS EA .)
    WHILE           reduce using rule 36 (EA -> P PLUS EA .)
    GOSUB           reduce using rule 36 (EA -> P PLUS EA .)
    INPUT           reduce using rule 36 (EA -> P PLUS EA .)
    PRINT           reduce using rule 36 (EA -> P PLUS EA .)
    SUBPROCEDURE    reduce using rule 36 (EA -> P PLUS EA .)
    END             reduce using rule 36 (EA -> P PLUS EA .)
    RETURN          reduce using rule 36 (EA -> P PLUS EA .)
    ELSE            reduce using rule 36 (EA -> P PLUS EA .)
    EIF             reduce using rule 36 (EA -> P PLUS EA .)
    WEND            reduce using rule 36 (EA -> P PLUS EA .)
    NEXT            reduce using rule 36 (EA -> P PLUS EA .)
    EQUALTO         reduce using rule 36 (EA -> P PLUS EA .)
    GREATHER        reduce using rule 36 (EA -> P PLUS EA .)
    GREATHEREQUAL   reduce using rule 36 (EA -> P PLUS EA .)
    SMALLER         reduce using rule 36 (EA -> P PLUS EA .)
    SMALLEREQUAL    reduce using rule 36 (EA -> P PLUS EA .)
    NOTEQUAL        reduce using rule 36 (EA -> P PLUS EA .)
    CLOSINGPAR      reduce using rule 36 (EA -> P PLUS EA .)
    TO              reduce using rule 36 (EA -> P PLUS EA .)
    CLOSINGBRACKET  reduce using rule 36 (EA -> P PLUS EA .)


state 95

    (37) EA -> P MINUS EA .

    LET             reduce using rule 37 (EA -> P MINUS EA .)
    DIM             reduce using rule 37 (EA -> P MINUS EA .)
    IF              reduce using rule 37 (EA -> P MINUS EA .)
    FOR             reduce using rule 37 (EA -> P MINUS EA .)
    WHILE           reduce using rule 37 (EA -> P MINUS EA .)
    GOSUB           reduce using rule 37 (EA -> P MINUS EA .)
    INPUT           reduce using rule 37 (EA -> P MINUS EA .)
    PRINT           reduce using rule 37 (EA -> P MINUS EA .)
    SUBPROCEDURE    reduce using rule 37 (EA -> P MINUS EA .)
    END             reduce using rule 37 (EA -> P MINUS EA .)
    RETURN          reduce using rule 37 (EA -> P MINUS EA .)
    ELSE            reduce using rule 37 (EA -> P MINUS EA .)
    EIF             reduce using rule 37 (EA -> P MINUS EA .)
    WEND            reduce using rule 37 (EA -> P MINUS EA .)
    NEXT            reduce using rule 37 (EA -> P MINUS EA .)
    EQUALTO         reduce using rule 37 (EA -> P MINUS EA .)
    GREATHER        reduce using rule 37 (EA -> P MINUS EA .)
    GREATHEREQUAL   reduce using rule 37 (EA -> P MINUS EA .)
    SMALLER         reduce using rule 37 (EA -> P MINUS EA .)
    SMALLEREQUAL    reduce using rule 37 (EA -> P MINUS EA .)
    NOTEQUAL        reduce using rule 37 (EA -> P MINUS EA .)
    CLOSINGPAR      reduce using rule 37 (EA -> P MINUS EA .)
    TO              reduce using rule 37 (EA -> P MINUS EA .)
    CLOSINGBRACKET  reduce using rule 37 (EA -> P MINUS EA .)


state 96

    (44) N -> OPENPAR EA CLOSINGPAR .

    MULTIPLY        reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    DIVIDE          reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    PLUS            reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    MINUS           reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    LET             reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    DIM             reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    IF              reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    FOR             reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    WHILE           reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    GOSUB           reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    INPUT           reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    PRINT           reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    SUBPROCEDURE    reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    END             reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    RETURN          reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    ELSE            reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    EIF             reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    WEND            reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    NEXT            reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    EQUALTO         reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    GREATHER        reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    GREATHEREQUAL   reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    SMALLER         reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    SMALLEREQUAL    reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    NOTEQUAL        reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    CLOSINGPAR      reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    TO              reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    CLOSINGBRACKET  reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)


state 97

    (39) P -> N MULTIPLY P .

    PLUS            reduce using rule 39 (P -> N MULTIPLY P .)
    MINUS           reduce using rule 39 (P -> N MULTIPLY P .)
    LET             reduce using rule 39 (P -> N MULTIPLY P .)
    DIM             reduce using rule 39 (P -> N MULTIPLY P .)
    IF              reduce using rule 39 (P -> N MULTIPLY P .)
    FOR             reduce using rule 39 (P -> N MULTIPLY P .)
    WHILE           reduce using rule 39 (P -> N MULTIPLY P .)
    GOSUB           reduce using rule 39 (P -> N MULTIPLY P .)
    INPUT           reduce using rule 39 (P -> N MULTIPLY P .)
    PRINT           reduce using rule 39 (P -> N MULTIPLY P .)
    SUBPROCEDURE    reduce using rule 39 (P -> N MULTIPLY P .)
    END             reduce using rule 39 (P -> N MULTIPLY P .)
    RETURN          reduce using rule 39 (P -> N MULTIPLY P .)
    ELSE            reduce using rule 39 (P -> N MULTIPLY P .)
    EIF             reduce using rule 39 (P -> N MULTIPLY P .)
    WEND            reduce using rule 39 (P -> N MULTIPLY P .)
    NEXT            reduce using rule 39 (P -> N MULTIPLY P .)
    EQUALTO         reduce using rule 39 (P -> N MULTIPLY P .)
    GREATHER        reduce using rule 39 (P -> N MULTIPLY P .)
    GREATHEREQUAL   reduce using rule 39 (P -> N MULTIPLY P .)
    SMALLER         reduce using rule 39 (P -> N MULTIPLY P .)
    SMALLEREQUAL    reduce using rule 39 (P -> N MULTIPLY P .)
    NOTEQUAL        reduce using rule 39 (P -> N MULTIPLY P .)
    CLOSINGPAR      reduce using rule 39 (P -> N MULTIPLY P .)
    TO              reduce using rule 39 (P -> N MULTIPLY P .)
    CLOSINGBRACKET  reduce using rule 39 (P -> N MULTIPLY P .)


state 98

    (40) P -> N DIVIDE P .

    PLUS            reduce using rule 40 (P -> N DIVIDE P .)
    MINUS           reduce using rule 40 (P -> N DIVIDE P .)
    LET             reduce using rule 40 (P -> N DIVIDE P .)
    DIM             reduce using rule 40 (P -> N DIVIDE P .)
    IF              reduce using rule 40 (P -> N DIVIDE P .)
    FOR             reduce using rule 40 (P -> N DIVIDE P .)
    WHILE           reduce using rule 40 (P -> N DIVIDE P .)
    GOSUB           reduce using rule 40 (P -> N DIVIDE P .)
    INPUT           reduce using rule 40 (P -> N DIVIDE P .)
    PRINT           reduce using rule 40 (P -> N DIVIDE P .)
    SUBPROCEDURE    reduce using rule 40 (P -> N DIVIDE P .)
    END             reduce using rule 40 (P -> N DIVIDE P .)
    RETURN          reduce using rule 40 (P -> N DIVIDE P .)
    ELSE            reduce using rule 40 (P -> N DIVIDE P .)
    EIF             reduce using rule 40 (P -> N DIVIDE P .)
    WEND            reduce using rule 40 (P -> N DIVIDE P .)
    NEXT            reduce using rule 40 (P -> N DIVIDE P .)
    EQUALTO         reduce using rule 40 (P -> N DIVIDE P .)
    GREATHER        reduce using rule 40 (P -> N DIVIDE P .)
    GREATHEREQUAL   reduce using rule 40 (P -> N DIVIDE P .)
    SMALLER         reduce using rule 40 (P -> N DIVIDE P .)
    SMALLEREQUAL    reduce using rule 40 (P -> N DIVIDE P .)
    NOTEQUAL        reduce using rule 40 (P -> N DIVIDE P .)
    CLOSINGPAR      reduce using rule 40 (P -> N DIVIDE P .)
    TO              reduce using rule 40 (P -> N DIVIDE P .)
    CLOSINGBRACKET  reduce using rule 40 (P -> N DIVIDE P .)


state 99

    (2) V -> DIM setType Idv AS T . Arr
    (4) Arr -> . OPENBRACKET EA CLOSINGBRACKET Arr
    (5) Arr -> . OPENBRACKET ID CLOSINGBRACKET Arr
    (6) Arr -> . empty
    (71) empty -> .

    OPENBRACKET     shift and go to state 127
    LET             reduce using rule 71 (empty -> .)
    DIM             reduce using rule 71 (empty -> .)
    IF              reduce using rule 71 (empty -> .)
    FOR             reduce using rule 71 (empty -> .)
    WHILE           reduce using rule 71 (empty -> .)
    GOSUB           reduce using rule 71 (empty -> .)
    INPUT           reduce using rule 71 (empty -> .)
    PRINT           reduce using rule 71 (empty -> .)
    SUBPROCEDURE    reduce using rule 71 (empty -> .)
    END             reduce using rule 71 (empty -> .)

    Arr                            shift and go to state 126
    empty                          shift and go to state 128

state 100

    (7) T -> INT .

    OPENBRACKET     reduce using rule 7 (T -> INT .)
    LET             reduce using rule 7 (T -> INT .)
    DIM             reduce using rule 7 (T -> INT .)
    IF              reduce using rule 7 (T -> INT .)
    FOR             reduce using rule 7 (T -> INT .)
    WHILE           reduce using rule 7 (T -> INT .)
    GOSUB           reduce using rule 7 (T -> INT .)
    INPUT           reduce using rule 7 (T -> INT .)
    PRINT           reduce using rule 7 (T -> INT .)
    SUBPROCEDURE    reduce using rule 7 (T -> INT .)
    END             reduce using rule 7 (T -> INT .)
    RETURN          reduce using rule 7 (T -> INT .)
    ELSE            reduce using rule 7 (T -> INT .)
    EIF             reduce using rule 7 (T -> INT .)
    WEND            reduce using rule 7 (T -> INT .)
    NEXT            reduce using rule 7 (T -> INT .)


state 101

    (8) T -> FLOAT .

    OPENBRACKET     reduce using rule 8 (T -> FLOAT .)
    LET             reduce using rule 8 (T -> FLOAT .)
    DIM             reduce using rule 8 (T -> FLOAT .)
    IF              reduce using rule 8 (T -> FLOAT .)
    FOR             reduce using rule 8 (T -> FLOAT .)
    WHILE           reduce using rule 8 (T -> FLOAT .)
    GOSUB           reduce using rule 8 (T -> FLOAT .)
    INPUT           reduce using rule 8 (T -> FLOAT .)
    PRINT           reduce using rule 8 (T -> FLOAT .)
    SUBPROCEDURE    reduce using rule 8 (T -> FLOAT .)
    END             reduce using rule 8 (T -> FLOAT .)
    RETURN          reduce using rule 8 (T -> FLOAT .)
    ELSE            reduce using rule 8 (T -> FLOAT .)
    EIF             reduce using rule 8 (T -> FLOAT .)
    WEND            reduce using rule 8 (T -> FLOAT .)
    NEXT            reduce using rule 8 (T -> FLOAT .)


state 102

    (9) T -> WORD .

    OPENBRACKET     reduce using rule 9 (T -> WORD .)
    LET             reduce using rule 9 (T -> WORD .)
    DIM             reduce using rule 9 (T -> WORD .)
    IF              reduce using rule 9 (T -> WORD .)
    FOR             reduce using rule 9 (T -> WORD .)
    WHILE           reduce using rule 9 (T -> WORD .)
    GOSUB           reduce using rule 9 (T -> WORD .)
    INPUT           reduce using rule 9 (T -> WORD .)
    PRINT           reduce using rule 9 (T -> WORD .)
    SUBPROCEDURE    reduce using rule 9 (T -> WORD .)
    END             reduce using rule 9 (T -> WORD .)
    RETURN          reduce using rule 9 (T -> WORD .)
    ELSE            reduce using rule 9 (T -> WORD .)
    EIF             reduce using rule 9 (T -> WORD .)
    WEND            reduce using rule 9 (T -> WORD .)
    NEXT            reduce using rule 9 (T -> WORD .)


state 103

    (24) Idv -> ID COMA Idv .

    AS              reduce using rule 24 (Idv -> ID COMA Idv .)
    EQUALS          reduce using rule 24 (Idv -> ID COMA Idv .)
    CLOSINGBRACKET  reduce using rule 24 (Idv -> ID COMA Idv .)


state 104

    (10) S -> SUBPROCEDURE ID TWOPOINTS M . RETURN S

    RETURN          shift and go to state 129


state 105

    (16) E -> LET setType Idv EQUALS Ex .

    LET             reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    DIM             reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    IF              reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    FOR             reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    WHILE           reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    GOSUB           reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    INPUT           reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    PRINT           reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    SUBPROCEDURE    reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    END             reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    RETURN          reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    ELSE            reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    EIF             reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    WEND            reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    NEXT            reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)


state 106

    (17) E -> DIM setType Idv AS T . Arr
    (4) Arr -> . OPENBRACKET EA CLOSINGBRACKET Arr
    (5) Arr -> . OPENBRACKET ID CLOSINGBRACKET Arr
    (6) Arr -> . empty
    (71) empty -> .

    OPENBRACKET     shift and go to state 127
    LET             reduce using rule 71 (empty -> .)
    DIM             reduce using rule 71 (empty -> .)
    IF              reduce using rule 71 (empty -> .)
    FOR             reduce using rule 71 (empty -> .)
    WHILE           reduce using rule 71 (empty -> .)
    GOSUB           reduce using rule 71 (empty -> .)
    INPUT           reduce using rule 71 (empty -> .)
    PRINT           reduce using rule 71 (empty -> .)
    SUBPROCEDURE    reduce using rule 71 (empty -> .)
    END             reduce using rule 71 (empty -> .)
    RETURN          reduce using rule 71 (empty -> .)
    ELSE            reduce using rule 71 (empty -> .)
    EIF             reduce using rule 71 (empty -> .)
    WEND            reduce using rule 71 (empty -> .)
    NEXT            reduce using rule 71 (empty -> .)

    Arr                            shift and go to state 130
    empty                          shift and go to state 128

state 107

    (18) E -> IF EL THEN F Esf . EIF

    EIF             shift and go to state 131


state 108

    (27) Esf -> ELSE . F
    (14) F -> . E F
    (15) F -> . empty
    (16) E -> . LET setType Idv EQUALS Ex
    (17) E -> . DIM setType Idv AS T Arr
    (18) E -> . IF EL THEN F Esf EIF
    (19) E -> . FOR ID EQUALS EA TO Ex F NEXT ID
    (20) E -> . WHILE OPENPAR EL CLOSINGPAR F WEND
    (21) E -> . GOSUB ID
    (22) E -> . INPUT ES COMA IDEx
    (23) E -> . PRINT Ex
    (71) empty -> .

    LET             shift and go to state 10
    DIM             shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    GOSUB           shift and go to state 15
    INPUT           shift and go to state 16
    PRINT           shift and go to state 17
    EIF             reduce using rule 71 (empty -> .)

    F                              shift and go to state 132
    E                              shift and go to state 9
    empty                          shift and go to state 24

state 109

    (28) Esf -> empty .

    EIF             reduce using rule 28 (Esf -> empty .)


state 110

    (54) EL -> OPENPAR O CLOSINGPAR Olt .

    THEN            reduce using rule 54 (EL -> OPENPAR O CLOSINGPAR Olt .)
    LET             reduce using rule 54 (EL -> OPENPAR O CLOSINGPAR Olt .)
    DIM             reduce using rule 54 (EL -> OPENPAR O CLOSINGPAR Olt .)
    IF              reduce using rule 54 (EL -> OPENPAR O CLOSINGPAR Olt .)
    FOR             reduce using rule 54 (EL -> OPENPAR O CLOSINGPAR Olt .)
    WHILE           reduce using rule 54 (EL -> OPENPAR O CLOSINGPAR Olt .)
    GOSUB           reduce using rule 54 (EL -> OPENPAR O CLOSINGPAR Olt .)
    INPUT           reduce using rule 54 (EL -> OPENPAR O CLOSINGPAR Olt .)
    PRINT           reduce using rule 54 (EL -> OPENPAR O CLOSINGPAR Olt .)
    SUBPROCEDURE    reduce using rule 54 (EL -> OPENPAR O CLOSINGPAR Olt .)
    END             reduce using rule 54 (EL -> OPENPAR O CLOSINGPAR Olt .)
    RETURN          reduce using rule 54 (EL -> OPENPAR O CLOSINGPAR Olt .)
    ELSE            reduce using rule 54 (EL -> OPENPAR O CLOSINGPAR Olt .)
    EIF             reduce using rule 54 (EL -> OPENPAR O CLOSINGPAR Olt .)
    WEND            reduce using rule 54 (EL -> OPENPAR O CLOSINGPAR Olt .)
    NEXT            reduce using rule 54 (EL -> OPENPAR O CLOSINGPAR Olt .)
    CLOSINGPAR      reduce using rule 54 (EL -> OPENPAR O CLOSINGPAR Olt .)


state 111

    (55) Olt -> OL . OPENPAR O CLOSINGPAR Olt

    OPENPAR         shift and go to state 133


state 112

    (56) Olt -> empty .

    THEN            reduce using rule 56 (Olt -> empty .)
    LET             reduce using rule 56 (Olt -> empty .)
    DIM             reduce using rule 56 (Olt -> empty .)
    IF              reduce using rule 56 (Olt -> empty .)
    FOR             reduce using rule 56 (Olt -> empty .)
    WHILE           reduce using rule 56 (Olt -> empty .)
    GOSUB           reduce using rule 56 (Olt -> empty .)
    INPUT           reduce using rule 56 (Olt -> empty .)
    PRINT           reduce using rule 56 (Olt -> empty .)
    SUBPROCEDURE    reduce using rule 56 (Olt -> empty .)
    END             reduce using rule 56 (Olt -> empty .)
    RETURN          reduce using rule 56 (Olt -> empty .)
    ELSE            reduce using rule 56 (Olt -> empty .)
    EIF             reduce using rule 56 (Olt -> empty .)
    WEND            reduce using rule 56 (Olt -> empty .)
    NEXT            reduce using rule 56 (Olt -> empty .)
    CLOSINGPAR      reduce using rule 56 (Olt -> empty .)


state 113

    (57) OL -> AND .

    OPENPAR         reduce using rule 57 (OL -> AND .)


state 114

    (58) OL -> OR .

    OPENPAR         reduce using rule 58 (OL -> OR .)


state 115

    (59) OL -> NOT .

    OPENPAR         reduce using rule 59 (OL -> NOT .)


state 116

    (60) O -> WORD EQUALTO WORD .

    CLOSINGPAR      reduce using rule 60 (O -> WORD EQUALTO WORD .)


state 117

    (61) O -> EA OPR EA .

    CLOSINGPAR      reduce using rule 61 (O -> EA OPR EA .)


state 118

    (64) O -> EA OPR ID .
    (43) N -> ID . saveID
    (45) N -> ID . OPENBRACKET INTVAL CLOSINGBRACKET
    (46) N -> ID . OPENBRACKET setType Idv CLOSINGBRACKET
    (48) saveID -> .

  ! reduce/reduce conflict for CLOSINGPAR resolved using rule 48 (saveID -> .)
    OPENBRACKET     shift and go to state 63
    MULTIPLY        reduce using rule 48 (saveID -> .)
    DIVIDE          reduce using rule 48 (saveID -> .)
    PLUS            reduce using rule 48 (saveID -> .)
    MINUS           reduce using rule 48 (saveID -> .)
    CLOSINGPAR      reduce using rule 48 (saveID -> .)

  ! CLOSINGPAR      [ reduce using rule 64 (O -> EA OPR ID .) ]

    saveID                         shift and go to state 62

state 119

    (62) O -> ID OPR ID .
    (43) N -> ID . saveID
    (45) N -> ID . OPENBRACKET INTVAL CLOSINGBRACKET
    (46) N -> ID . OPENBRACKET setType Idv CLOSINGBRACKET
    (48) saveID -> .

  ! reduce/reduce conflict for CLOSINGPAR resolved using rule 48 (saveID -> .)
    OPENBRACKET     shift and go to state 63
    MULTIPLY        reduce using rule 48 (saveID -> .)
    DIVIDE          reduce using rule 48 (saveID -> .)
    PLUS            reduce using rule 48 (saveID -> .)
    MINUS           reduce using rule 48 (saveID -> .)
    CLOSINGPAR      reduce using rule 48 (saveID -> .)

  ! CLOSINGPAR      [ reduce using rule 62 (O -> ID OPR ID .) ]

    saveID                         shift and go to state 62

state 120

    (63) O -> ID OPR EA .

    CLOSINGPAR      reduce using rule 63 (O -> ID OPR EA .)


state 121

    (19) E -> FOR ID EQUALS EA TO . Ex F NEXT ID
    (31) Ex -> . EA
    (32) Ex -> . ES
    (33) Ex -> . EL
    (34) Ex -> . ID
    (36) EA -> . P PLUS EA
    (37) EA -> . P MINUS EA
    (38) EA -> . P
    (35) ES -> . WORDVAL
    (52) EL -> . TRUE
    (53) EL -> . FALSE
    (54) EL -> . OPENPAR O CLOSINGPAR Olt
    (39) P -> . N MULTIPLY P
    (40) P -> . N DIVIDE P
    (41) P -> . N
    (42) N -> . cte saveID
    (43) N -> . ID saveID
    (44) N -> . OPENPAR EA CLOSINGPAR
    (45) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (46) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (50) cte -> . INTVAL
    (51) cte -> . FLOATVAL

    ID              shift and go to state 40
    WORDVAL         shift and go to state 35
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    OPENPAR         shift and go to state 42
    INTVAL          shift and go to state 45
    FLOATVAL        shift and go to state 46

    EA                             shift and go to state 37
    Ex                             shift and go to state 134
    ES                             shift and go to state 38
    EL                             shift and go to state 39
    P                              shift and go to state 41
    N                              shift and go to state 43
    cte                            shift and go to state 44

state 122

    (20) E -> WHILE OPENPAR EL CLOSINGPAR F . WEND

    WEND            shift and go to state 135


state 123

    (30) IDEx -> ID OPENBRACKET . setType Idv CLOSINGBRACKET
    (26) setType -> .

    ID              reduce using rule 26 (setType -> .)

    setType                        shift and go to state 136

state 124

    (45) N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .

    MULTIPLY        reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    DIVIDE          reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    PLUS            reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    MINUS           reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    LET             reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    DIM             reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    IF              reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    FOR             reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    WHILE           reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    GOSUB           reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    INPUT           reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    PRINT           reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    SUBPROCEDURE    reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    END             reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    RETURN          reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    ELSE            reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    EIF             reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    WEND            reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    NEXT            reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    EQUALTO         reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    GREATHER        reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    GREATHEREQUAL   reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    SMALLER         reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    SMALLEREQUAL    reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    NOTEQUAL        reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    CLOSINGPAR      reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    TO              reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    CLOSINGBRACKET  reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)


state 125

    (46) N -> ID OPENBRACKET setType Idv . CLOSINGBRACKET

    CLOSINGBRACKET  shift and go to state 137


state 126

    (2) V -> DIM setType Idv AS T Arr .

    LET             reduce using rule 2 (V -> DIM setType Idv AS T Arr .)
    DIM             reduce using rule 2 (V -> DIM setType Idv AS T Arr .)
    IF              reduce using rule 2 (V -> DIM setType Idv AS T Arr .)
    FOR             reduce using rule 2 (V -> DIM setType Idv AS T Arr .)
    WHILE           reduce using rule 2 (V -> DIM setType Idv AS T Arr .)
    GOSUB           reduce using rule 2 (V -> DIM setType Idv AS T Arr .)
    INPUT           reduce using rule 2 (V -> DIM setType Idv AS T Arr .)
    PRINT           reduce using rule 2 (V -> DIM setType Idv AS T Arr .)
    SUBPROCEDURE    reduce using rule 2 (V -> DIM setType Idv AS T Arr .)
    END             reduce using rule 2 (V -> DIM setType Idv AS T Arr .)


state 127

    (4) Arr -> OPENBRACKET . EA CLOSINGBRACKET Arr
    (5) Arr -> OPENBRACKET . ID CLOSINGBRACKET Arr
    (36) EA -> . P PLUS EA
    (37) EA -> . P MINUS EA
    (38) EA -> . P
    (39) P -> . N MULTIPLY P
    (40) P -> . N DIVIDE P
    (41) P -> . N
    (42) N -> . cte saveID
    (43) N -> . ID saveID
    (44) N -> . OPENPAR EA CLOSINGPAR
    (45) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (46) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (50) cte -> . INTVAL
    (51) cte -> . FLOATVAL

    ID              shift and go to state 139
    OPENPAR         shift and go to state 54
    INTVAL          shift and go to state 45
    FLOATVAL        shift and go to state 46

    EA                             shift and go to state 138
    P                              shift and go to state 41
    N                              shift and go to state 43
    cte                            shift and go to state 44

state 128

    (6) Arr -> empty .

    LET             reduce using rule 6 (Arr -> empty .)
    DIM             reduce using rule 6 (Arr -> empty .)
    IF              reduce using rule 6 (Arr -> empty .)
    FOR             reduce using rule 6 (Arr -> empty .)
    WHILE           reduce using rule 6 (Arr -> empty .)
    GOSUB           reduce using rule 6 (Arr -> empty .)
    INPUT           reduce using rule 6 (Arr -> empty .)
    PRINT           reduce using rule 6 (Arr -> empty .)
    SUBPROCEDURE    reduce using rule 6 (Arr -> empty .)
    END             reduce using rule 6 (Arr -> empty .)
    RETURN          reduce using rule 6 (Arr -> empty .)
    ELSE            reduce using rule 6 (Arr -> empty .)
    EIF             reduce using rule 6 (Arr -> empty .)
    WEND            reduce using rule 6 (Arr -> empty .)
    NEXT            reduce using rule 6 (Arr -> empty .)


state 129

    (10) S -> SUBPROCEDURE ID TWOPOINTS M RETURN . S
    (10) S -> . SUBPROCEDURE ID TWOPOINTS M RETURN S
    (11) S -> . empty
    (71) empty -> .

    SUBPROCEDURE    shift and go to state 20
    END             reduce using rule 71 (empty -> .)

    S                              shift and go to state 140
    empty                          shift and go to state 21

state 130

    (17) E -> DIM setType Idv AS T Arr .

    LET             reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    DIM             reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    IF              reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    FOR             reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    WHILE           reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    GOSUB           reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    INPUT           reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    PRINT           reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    SUBPROCEDURE    reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    END             reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    RETURN          reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    ELSE            reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    EIF             reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    WEND            reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    NEXT            reduce using rule 17 (E -> DIM setType Idv AS T Arr .)


state 131

    (18) E -> IF EL THEN F Esf EIF .

    LET             reduce using rule 18 (E -> IF EL THEN F Esf EIF .)
    DIM             reduce using rule 18 (E -> IF EL THEN F Esf EIF .)
    IF              reduce using rule 18 (E -> IF EL THEN F Esf EIF .)
    FOR             reduce using rule 18 (E -> IF EL THEN F Esf EIF .)
    WHILE           reduce using rule 18 (E -> IF EL THEN F Esf EIF .)
    GOSUB           reduce using rule 18 (E -> IF EL THEN F Esf EIF .)
    INPUT           reduce using rule 18 (E -> IF EL THEN F Esf EIF .)
    PRINT           reduce using rule 18 (E -> IF EL THEN F Esf EIF .)
    SUBPROCEDURE    reduce using rule 18 (E -> IF EL THEN F Esf EIF .)
    END             reduce using rule 18 (E -> IF EL THEN F Esf EIF .)
    RETURN          reduce using rule 18 (E -> IF EL THEN F Esf EIF .)
    ELSE            reduce using rule 18 (E -> IF EL THEN F Esf EIF .)
    EIF             reduce using rule 18 (E -> IF EL THEN F Esf EIF .)
    WEND            reduce using rule 18 (E -> IF EL THEN F Esf EIF .)
    NEXT            reduce using rule 18 (E -> IF EL THEN F Esf EIF .)


state 132

    (27) Esf -> ELSE F .

    EIF             reduce using rule 27 (Esf -> ELSE F .)


state 133

    (55) Olt -> OL OPENPAR . O CLOSINGPAR Olt
    (60) O -> . WORD EQUALTO WORD
    (61) O -> . EA OPR EA
    (62) O -> . ID OPR ID
    (63) O -> . ID OPR EA
    (64) O -> . EA OPR ID
    (36) EA -> . P PLUS EA
    (37) EA -> . P MINUS EA
    (38) EA -> . P
    (39) P -> . N MULTIPLY P
    (40) P -> . N DIVIDE P
    (41) P -> . N
    (42) N -> . cte saveID
    (43) N -> . ID saveID
    (44) N -> . OPENPAR EA CLOSINGPAR
    (45) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (46) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (50) cte -> . INTVAL
    (51) cte -> . FLOATVAL

    WORD            shift and go to state 56
    ID              shift and go to state 58
    OPENPAR         shift and go to state 54
    INTVAL          shift and go to state 45
    FLOATVAL        shift and go to state 46

    O                              shift and go to state 141
    EA                             shift and go to state 57
    P                              shift and go to state 41
    N                              shift and go to state 43
    cte                            shift and go to state 44

state 134

    (19) E -> FOR ID EQUALS EA TO Ex . F NEXT ID
    (14) F -> . E F
    (15) F -> . empty
    (16) E -> . LET setType Idv EQUALS Ex
    (17) E -> . DIM setType Idv AS T Arr
    (18) E -> . IF EL THEN F Esf EIF
    (19) E -> . FOR ID EQUALS EA TO Ex F NEXT ID
    (20) E -> . WHILE OPENPAR EL CLOSINGPAR F WEND
    (21) E -> . GOSUB ID
    (22) E -> . INPUT ES COMA IDEx
    (23) E -> . PRINT Ex
    (71) empty -> .

    LET             shift and go to state 10
    DIM             shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    GOSUB           shift and go to state 15
    INPUT           shift and go to state 16
    PRINT           shift and go to state 17
    NEXT            reduce using rule 71 (empty -> .)

    F                              shift and go to state 142
    E                              shift and go to state 9
    empty                          shift and go to state 24

state 135

    (20) E -> WHILE OPENPAR EL CLOSINGPAR F WEND .

    LET             reduce using rule 20 (E -> WHILE OPENPAR EL CLOSINGPAR F WEND .)
    DIM             reduce using rule 20 (E -> WHILE OPENPAR EL CLOSINGPAR F WEND .)
    IF              reduce using rule 20 (E -> WHILE OPENPAR EL CLOSINGPAR F WEND .)
    FOR             reduce using rule 20 (E -> WHILE OPENPAR EL CLOSINGPAR F WEND .)
    WHILE           reduce using rule 20 (E -> WHILE OPENPAR EL CLOSINGPAR F WEND .)
    GOSUB           reduce using rule 20 (E -> WHILE OPENPAR EL CLOSINGPAR F WEND .)
    INPUT           reduce using rule 20 (E -> WHILE OPENPAR EL CLOSINGPAR F WEND .)
    PRINT           reduce using rule 20 (E -> WHILE OPENPAR EL CLOSINGPAR F WEND .)
    SUBPROCEDURE    reduce using rule 20 (E -> WHILE OPENPAR EL CLOSINGPAR F WEND .)
    END             reduce using rule 20 (E -> WHILE OPENPAR EL CLOSINGPAR F WEND .)
    RETURN          reduce using rule 20 (E -> WHILE OPENPAR EL CLOSINGPAR F WEND .)
    ELSE            reduce using rule 20 (E -> WHILE OPENPAR EL CLOSINGPAR F WEND .)
    EIF             reduce using rule 20 (E -> WHILE OPENPAR EL CLOSINGPAR F WEND .)
    WEND            reduce using rule 20 (E -> WHILE OPENPAR EL CLOSINGPAR F WEND .)
    NEXT            reduce using rule 20 (E -> WHILE OPENPAR EL CLOSINGPAR F WEND .)


state 136

    (30) IDEx -> ID OPENBRACKET setType . Idv CLOSINGBRACKET
    (24) Idv -> . ID COMA Idv
    (25) Idv -> . ID

    ID              shift and go to state 48

    Idv                            shift and go to state 143

state 137

    (46) N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .

    MULTIPLY        reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    DIVIDE          reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    PLUS            reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    MINUS           reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    LET             reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    DIM             reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    IF              reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    FOR             reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    WHILE           reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    GOSUB           reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    INPUT           reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    PRINT           reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    SUBPROCEDURE    reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    END             reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    RETURN          reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    ELSE            reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    EIF             reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    WEND            reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    NEXT            reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    EQUALTO         reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    GREATHER        reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    GREATHEREQUAL   reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    SMALLER         reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    SMALLEREQUAL    reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    NOTEQUAL        reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    CLOSINGPAR      reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    TO              reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    CLOSINGBRACKET  reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)


state 138

    (4) Arr -> OPENBRACKET EA . CLOSINGBRACKET Arr

    CLOSINGBRACKET  shift and go to state 144


state 139

    (5) Arr -> OPENBRACKET ID . CLOSINGBRACKET Arr
    (43) N -> ID . saveID
    (45) N -> ID . OPENBRACKET INTVAL CLOSINGBRACKET
    (46) N -> ID . OPENBRACKET setType Idv CLOSINGBRACKET
    (48) saveID -> .

  ! shift/reduce conflict for CLOSINGBRACKET resolved as shift
    CLOSINGBRACKET  shift and go to state 145
    OPENBRACKET     shift and go to state 63
    MULTIPLY        reduce using rule 48 (saveID -> .)
    DIVIDE          reduce using rule 48 (saveID -> .)
    PLUS            reduce using rule 48 (saveID -> .)
    MINUS           reduce using rule 48 (saveID -> .)

  ! CLOSINGBRACKET  [ reduce using rule 48 (saveID -> .) ]

    saveID                         shift and go to state 62

state 140

    (10) S -> SUBPROCEDURE ID TWOPOINTS M RETURN S .

    END             reduce using rule 10 (S -> SUBPROCEDURE ID TWOPOINTS M RETURN S .)


state 141

    (55) Olt -> OL OPENPAR O . CLOSINGPAR Olt

    CLOSINGPAR      shift and go to state 146


state 142

    (19) E -> FOR ID EQUALS EA TO Ex F . NEXT ID

    NEXT            shift and go to state 147


state 143

    (30) IDEx -> ID OPENBRACKET setType Idv . CLOSINGBRACKET

    CLOSINGBRACKET  shift and go to state 148


state 144

    (4) Arr -> OPENBRACKET EA CLOSINGBRACKET . Arr
    (4) Arr -> . OPENBRACKET EA CLOSINGBRACKET Arr
    (5) Arr -> . OPENBRACKET ID CLOSINGBRACKET Arr
    (6) Arr -> . empty
    (71) empty -> .

    OPENBRACKET     shift and go to state 127
    LET             reduce using rule 71 (empty -> .)
    DIM             reduce using rule 71 (empty -> .)
    IF              reduce using rule 71 (empty -> .)
    FOR             reduce using rule 71 (empty -> .)
    WHILE           reduce using rule 71 (empty -> .)
    GOSUB           reduce using rule 71 (empty -> .)
    INPUT           reduce using rule 71 (empty -> .)
    PRINT           reduce using rule 71 (empty -> .)
    SUBPROCEDURE    reduce using rule 71 (empty -> .)
    END             reduce using rule 71 (empty -> .)
    RETURN          reduce using rule 71 (empty -> .)
    ELSE            reduce using rule 71 (empty -> .)
    EIF             reduce using rule 71 (empty -> .)
    WEND            reduce using rule 71 (empty -> .)
    NEXT            reduce using rule 71 (empty -> .)

    Arr                            shift and go to state 149
    empty                          shift and go to state 128

state 145

    (5) Arr -> OPENBRACKET ID CLOSINGBRACKET . Arr
    (4) Arr -> . OPENBRACKET EA CLOSINGBRACKET Arr
    (5) Arr -> . OPENBRACKET ID CLOSINGBRACKET Arr
    (6) Arr -> . empty
    (71) empty -> .

    OPENBRACKET     shift and go to state 127
    LET             reduce using rule 71 (empty -> .)
    DIM             reduce using rule 71 (empty -> .)
    IF              reduce using rule 71 (empty -> .)
    FOR             reduce using rule 71 (empty -> .)
    WHILE           reduce using rule 71 (empty -> .)
    GOSUB           reduce using rule 71 (empty -> .)
    INPUT           reduce using rule 71 (empty -> .)
    PRINT           reduce using rule 71 (empty -> .)
    SUBPROCEDURE    reduce using rule 71 (empty -> .)
    END             reduce using rule 71 (empty -> .)
    RETURN          reduce using rule 71 (empty -> .)
    ELSE            reduce using rule 71 (empty -> .)
    EIF             reduce using rule 71 (empty -> .)
    WEND            reduce using rule 71 (empty -> .)
    NEXT            reduce using rule 71 (empty -> .)

    Arr                            shift and go to state 150
    empty                          shift and go to state 128

state 146

    (55) Olt -> OL OPENPAR O CLOSINGPAR . Olt
    (55) Olt -> . OL OPENPAR O CLOSINGPAR Olt
    (56) Olt -> . empty
    (57) OL -> . AND
    (58) OL -> . OR
    (59) OL -> . NOT
    (71) empty -> .

    AND             shift and go to state 113
    OR              shift and go to state 114
    NOT             shift and go to state 115
    THEN            reduce using rule 71 (empty -> .)
    LET             reduce using rule 71 (empty -> .)
    DIM             reduce using rule 71 (empty -> .)
    IF              reduce using rule 71 (empty -> .)
    FOR             reduce using rule 71 (empty -> .)
    WHILE           reduce using rule 71 (empty -> .)
    GOSUB           reduce using rule 71 (empty -> .)
    INPUT           reduce using rule 71 (empty -> .)
    PRINT           reduce using rule 71 (empty -> .)
    SUBPROCEDURE    reduce using rule 71 (empty -> .)
    END             reduce using rule 71 (empty -> .)
    RETURN          reduce using rule 71 (empty -> .)
    ELSE            reduce using rule 71 (empty -> .)
    EIF             reduce using rule 71 (empty -> .)
    WEND            reduce using rule 71 (empty -> .)
    NEXT            reduce using rule 71 (empty -> .)
    CLOSINGPAR      reduce using rule 71 (empty -> .)

    OL                             shift and go to state 111
    Olt                            shift and go to state 151
    empty                          shift and go to state 112

state 147

    (19) E -> FOR ID EQUALS EA TO Ex F NEXT . ID

    ID              shift and go to state 152


state 148

    (30) IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .

    LET             reduce using rule 30 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    DIM             reduce using rule 30 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    IF              reduce using rule 30 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    FOR             reduce using rule 30 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    WHILE           reduce using rule 30 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    GOSUB           reduce using rule 30 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    INPUT           reduce using rule 30 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    PRINT           reduce using rule 30 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    SUBPROCEDURE    reduce using rule 30 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    END             reduce using rule 30 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    RETURN          reduce using rule 30 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    ELSE            reduce using rule 30 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    EIF             reduce using rule 30 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    WEND            reduce using rule 30 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    NEXT            reduce using rule 30 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)


state 149

    (4) Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .

    LET             reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    DIM             reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    IF              reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    FOR             reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    WHILE           reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    GOSUB           reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    INPUT           reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    PRINT           reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    SUBPROCEDURE    reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    END             reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    RETURN          reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    ELSE            reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    EIF             reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    WEND            reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    NEXT            reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)


state 150

    (5) Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .

    LET             reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    DIM             reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    IF              reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    FOR             reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    WHILE           reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    GOSUB           reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    INPUT           reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    PRINT           reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    SUBPROCEDURE    reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    END             reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    RETURN          reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    ELSE            reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    EIF             reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    WEND            reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    NEXT            reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)


state 151

    (55) Olt -> OL OPENPAR O CLOSINGPAR Olt .

    THEN            reduce using rule 55 (Olt -> OL OPENPAR O CLOSINGPAR Olt .)
    LET             reduce using rule 55 (Olt -> OL OPENPAR O CLOSINGPAR Olt .)
    DIM             reduce using rule 55 (Olt -> OL OPENPAR O CLOSINGPAR Olt .)
    IF              reduce using rule 55 (Olt -> OL OPENPAR O CLOSINGPAR Olt .)
    FOR             reduce using rule 55 (Olt -> OL OPENPAR O CLOSINGPAR Olt .)
    WHILE           reduce using rule 55 (Olt -> OL OPENPAR O CLOSINGPAR Olt .)
    GOSUB           reduce using rule 55 (Olt -> OL OPENPAR O CLOSINGPAR Olt .)
    INPUT           reduce using rule 55 (Olt -> OL OPENPAR O CLOSINGPAR Olt .)
    PRINT           reduce using rule 55 (Olt -> OL OPENPAR O CLOSINGPAR Olt .)
    SUBPROCEDURE    reduce using rule 55 (Olt -> OL OPENPAR O CLOSINGPAR Olt .)
    END             reduce using rule 55 (Olt -> OL OPENPAR O CLOSINGPAR Olt .)
    RETURN          reduce using rule 55 (Olt -> OL OPENPAR O CLOSINGPAR Olt .)
    ELSE            reduce using rule 55 (Olt -> OL OPENPAR O CLOSINGPAR Olt .)
    EIF             reduce using rule 55 (Olt -> OL OPENPAR O CLOSINGPAR Olt .)
    WEND            reduce using rule 55 (Olt -> OL OPENPAR O CLOSINGPAR Olt .)
    NEXT            reduce using rule 55 (Olt -> OL OPENPAR O CLOSINGPAR Olt .)
    CLOSINGPAR      reduce using rule 55 (Olt -> OL OPENPAR O CLOSINGPAR Olt .)


state 152

    (19) E -> FOR ID EQUALS EA TO Ex F NEXT ID .

    LET             reduce using rule 19 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    DIM             reduce using rule 19 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    IF              reduce using rule 19 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    FOR             reduce using rule 19 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    WHILE           reduce using rule 19 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    GOSUB           reduce using rule 19 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    INPUT           reduce using rule 19 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    PRINT           reduce using rule 19 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    SUBPROCEDURE    reduce using rule 19 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    END             reduce using rule 19 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    RETURN          reduce using rule 19 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    ELSE            reduce using rule 19 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    EIF             reduce using rule 19 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    WEND            reduce using rule 19 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    NEXT            reduce using rule 19 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for DIM in state 2 resolved as shift
WARNING: shift/reduce conflict for LET in state 3 resolved as shift
WARNING: shift/reduce conflict for DIM in state 3 resolved as shift
WARNING: shift/reduce conflict for IF in state 3 resolved as shift
WARNING: shift/reduce conflict for FOR in state 3 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 3 resolved as shift
WARNING: shift/reduce conflict for GOSUB in state 3 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 3 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 3 resolved as shift
WARNING: shift/reduce conflict for LET in state 7 resolved as shift
WARNING: shift/reduce conflict for DIM in state 7 resolved as shift
WARNING: shift/reduce conflict for IF in state 7 resolved as shift
WARNING: shift/reduce conflict for FOR in state 7 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 7 resolved as shift
WARNING: shift/reduce conflict for GOSUB in state 7 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 7 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 7 resolved as shift
WARNING: shift/reduce conflict for LET in state 9 resolved as shift
WARNING: shift/reduce conflict for DIM in state 9 resolved as shift
WARNING: shift/reduce conflict for IF in state 9 resolved as shift
WARNING: shift/reduce conflict for FOR in state 9 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 9 resolved as shift
WARNING: shift/reduce conflict for GOSUB in state 9 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 9 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 9 resolved as shift
WARNING: shift/reduce conflict for EQUALTO in state 58 resolved as shift
WARNING: shift/reduce conflict for GREATHER in state 58 resolved as shift
WARNING: shift/reduce conflict for GREATHEREQUAL in state 58 resolved as shift
WARNING: shift/reduce conflict for SMALLER in state 58 resolved as shift
WARNING: shift/reduce conflict for SMALLEREQUAL in state 58 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 58 resolved as shift
WARNING: shift/reduce conflict for LET in state 72 resolved as shift
WARNING: shift/reduce conflict for DIM in state 72 resolved as shift
WARNING: shift/reduce conflict for IF in state 72 resolved as shift
WARNING: shift/reduce conflict for FOR in state 72 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 72 resolved as shift
WARNING: shift/reduce conflict for GOSUB in state 72 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 72 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 72 resolved as shift
WARNING: shift/reduce conflict for CLOSINGBRACKET in state 139 resolved as shift
WARNING: reduce/reduce conflict in state 8 resolved using rule (M -> empty)
WARNING: rejected rule (F -> empty) in state 8
WARNING: reduce/reduce conflict in state 40 resolved using rule (Ex -> ID)
WARNING: rejected rule (saveID -> <empty>) in state 40
WARNING: reduce/reduce conflict in state 118 resolved using rule (saveID -> <empty>)
WARNING: rejected rule (O -> EA OPR ID) in state 118
WARNING: reduce/reduce conflict in state 119 resolved using rule (saveID -> <empty>)
WARNING: rejected rule (O -> ID OPR ID) in state 119
WARNING: Rule (O -> EA OPR ID) is never reduced
WARNING: Rule (O -> ID OPR ID) is never reduced
