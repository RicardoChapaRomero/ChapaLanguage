Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT
    WORDVAL

Grammar

Rule 0     S' -> PROGRAMA
Rule 1     PROGRAMA -> PROGRAM V M endProgram S END
Rule 2     endProgram -> <empty>
Rule 3     V -> DIM setType Idv AS T Arr
Rule 4     V -> empty
Rule 5     Arr -> OPENBRACKET arr_space CLOSINGBRACKET
Rule 6     Arr -> empty
Rule 7     arr_space -> arr_index COMA arr_space
Rule 8     arr_space -> arr_index
Rule 9     arr_index -> INTVAL
Rule 10    arr_index -> ID
Rule 11    T -> INT
Rule 12    T -> FLOAT
Rule 13    T -> WORD
Rule 14    S -> SUBPROCEDURE ID fillSub TWOPOINTS M RETURN endProcedure S
Rule 15    S -> empty
Rule 16    fillSub -> <empty>
Rule 17    endProcedure -> <empty>
Rule 18    M -> F
Rule 19    F -> E F
Rule 20    F -> empty
Rule 21    E -> LET setType IdLet EQUALS EA
Rule 22    E -> DIM setType Idv AS T Arr
Rule 23    E -> IF EL THEN first_conditional F Esf EIF final_conditional
Rule 24    E -> FOR ID EQUALS EA for_assignation TO EA for_conditional DO for_save_conditional F NEXT ID for_conditional_end
Rule 25    E -> WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional
Rule 26    E -> REPEAT while_first_conditional F UNTIL EL repeat_conditional
Rule 27    E -> GOSUB ID
Rule 28    E -> INPUT IDEx
Rule 29    E -> PRINT EA
Rule 30    for_assignation -> <empty>
Rule 31    for_conditional -> <empty>
Rule 32    for_save_conditional -> <empty>
Rule 33    for_conditional_end -> <empty>
Rule 34    repeat_conditional -> <empty>
Rule 35    while_first_conditional -> <empty>
Rule 36    while_second_conditional -> <empty>
Rule 37    while_final_conditional -> <empty>
Rule 38    first_conditional -> <empty>
Rule 39    second_conditional -> <empty>
Rule 40    final_conditional -> <empty>
Rule 41    Esf -> ELSE second_conditional F
Rule 42    Esf -> empty
Rule 43    IdLet -> ID
Rule 44    IdLet -> ID Arr
Rule 45    Idv -> ID COMA Idv
Rule 46    Idv -> ID
Rule 47    setType -> <empty>
Rule 48    IDEx -> ID
Rule 49    IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET
Rule 50    EA -> EA PLUS P
Rule 51    EA -> EA MINUS P
Rule 52    EA -> P
Rule 53    P -> P MULTIPLY N
Rule 54    P -> P DIVIDE N
Rule 55    P -> N
Rule 56    N -> ID Arr saveID
Rule 57    N -> cte saveID
Rule 58    N -> ID saveID
Rule 59    N -> OPENPAR EA CLOSINGPAR
Rule 60    saveID -> <empty>
Rule 61    cte -> FLOATVAL
Rule 62    cte -> INTVAL
Rule 63    cte -> MINUS INTVAL
Rule 64    cte -> MINUS FLOATVAL
Rule 65    EL -> TRUE
Rule 66    EL -> FALSE
Rule 67    EL -> OPENPAR O CLOSINGPAR
Rule 68    EL -> OPENPAR O CLOSINGPAR OL EL
Rule 69    OL -> AND
Rule 70    OL -> OR
Rule 71    OL -> NOT
Rule 72    O -> EA GREATHER EA
Rule 73    O -> EA GREATHEREQUAL EA
Rule 74    O -> EA SMALLER EA
Rule 75    O -> EA SMALLEREQUAL EA
Rule 76    O -> EA NOTEQUAL EA
Rule 77    O -> EA EQUALTO EA
Rule 78    O -> EA error EA
Rule 79    empty -> <empty>

Terminals, with rules where they appear

AND                  : 69
AS                   : 3 22
CLOSINGBRACKET       : 5 49
CLOSINGPAR           : 59 67 68
COMA                 : 7 45
COMMENT              : 
DIM                  : 3 22
DIVIDE               : 54
DO                   : 24 25
EIF                  : 23
ELSE                 : 41
END                  : 1
EQUALS               : 21 24
EQUALTO              : 77
FALSE                : 66
FLOAT                : 12
FLOATVAL             : 61 64
FOR                  : 24
GOSUB                : 27
GREATHER             : 72
GREATHEREQUAL        : 73
ID                   : 10 14 24 24 27 43 44 45 46 48 49 56 58
IF                   : 23
INPUT                : 28
INT                  : 11
INTVAL               : 9 62 63
LET                  : 21
MINUS                : 51 63 64
MULTIPLY             : 53
NEXT                 : 24
NOT                  : 71
NOTEQUAL             : 76
OPENBRACKET          : 5 49
OPENPAR              : 59 67 68
OR                   : 70
PLUS                 : 50
PRINT                : 29
PROGRAM              : 1
REPEAT               : 26
RETURN               : 14
SMALLER              : 74
SMALLEREQUAL         : 75
SUBPROCEDURE         : 14
THEN                 : 23
TO                   : 24
TRUE                 : 65
TWOPOINTS            : 14
UNTIL                : 26
WEND                 : 25
WHILE                : 25
WORD                 : 13
WORDVAL              : 
error                : 78

Nonterminals, with rules where they appear

Arr                  : 3 22 44 56
E                    : 19
EA                   : 21 24 24 29 50 51 59 72 72 73 73 74 74 75 75 76 76 77 77 78 78
EL                   : 23 25 26 68
Esf                  : 23
F                    : 18 19 23 24 25 26 41
IDEx                 : 28
IdLet                : 21
Idv                  : 3 22 45 49
M                    : 1 14
N                    : 53 54 55
O                    : 67 68
OL                   : 68
P                    : 50 51 52 53 54
PROGRAMA             : 0
S                    : 1 14
T                    : 3 22
V                    : 1
arr_index            : 7 8
arr_space            : 5 7
cte                  : 57
empty                : 4 6 15 20 42
endProcedure         : 14
endProgram           : 1
fillSub              : 14
final_conditional    : 23
first_conditional    : 23
for_assignation      : 24
for_conditional      : 24
for_conditional_end  : 24
for_save_conditional : 24
repeat_conditional   : 26
saveID               : 56 57 58
second_conditional   : 41
setType              : 3 21 22 49
while_final_conditional : 25
while_first_conditional : 25 26
while_second_conditional : 25

Parsing method: LALR

state 0

    (0) S' -> . PROGRAMA
    (1) PROGRAMA -> . PROGRAM V M endProgram S END

    PROGRAM         shift and go to state 2

    PROGRAMA                       shift and go to state 1

state 1

    (0) S' -> PROGRAMA .



state 2

    (1) PROGRAMA -> PROGRAM . V M endProgram S END
    (3) V -> . DIM setType Idv AS T Arr
    (4) V -> . empty
    (79) empty -> .

  ! shift/reduce conflict for DIM resolved as shift
    DIM             shift and go to state 4
    LET             reduce using rule 79 (empty -> .)
    IF              reduce using rule 79 (empty -> .)
    FOR             reduce using rule 79 (empty -> .)
    WHILE           reduce using rule 79 (empty -> .)
    REPEAT          reduce using rule 79 (empty -> .)
    GOSUB           reduce using rule 79 (empty -> .)
    INPUT           reduce using rule 79 (empty -> .)
    PRINT           reduce using rule 79 (empty -> .)
    SUBPROCEDURE    reduce using rule 79 (empty -> .)
    END             reduce using rule 79 (empty -> .)

  ! DIM             [ reduce using rule 79 (empty -> .) ]

    V                              shift and go to state 3
    empty                          shift and go to state 5

state 3

    (1) PROGRAMA -> PROGRAM V . M endProgram S END
    (18) M -> . F
    (19) F -> . E F
    (20) F -> . empty
    (21) E -> . LET setType IdLet EQUALS EA
    (22) E -> . DIM setType Idv AS T Arr
    (23) E -> . IF EL THEN first_conditional F Esf EIF final_conditional
    (24) E -> . FOR ID EQUALS EA for_assignation TO EA for_conditional DO for_save_conditional F NEXT ID for_conditional_end
    (25) E -> . WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional
    (26) E -> . REPEAT while_first_conditional F UNTIL EL repeat_conditional
    (27) E -> . GOSUB ID
    (28) E -> . INPUT IDEx
    (29) E -> . PRINT EA
    (79) empty -> .

    LET             shift and go to state 10
    DIM             shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    REPEAT          shift and go to state 15
    GOSUB           shift and go to state 16
    INPUT           shift and go to state 17
    PRINT           shift and go to state 18
    SUBPROCEDURE    reduce using rule 79 (empty -> .)
    END             reduce using rule 79 (empty -> .)

    M                              shift and go to state 6
    F                              shift and go to state 7
    E                              shift and go to state 8
    empty                          shift and go to state 9

state 4

    (3) V -> DIM . setType Idv AS T Arr
    (47) setType -> .

    ID              reduce using rule 47 (setType -> .)

    setType                        shift and go to state 19

state 5

    (4) V -> empty .

    LET             reduce using rule 4 (V -> empty .)
    DIM             reduce using rule 4 (V -> empty .)
    IF              reduce using rule 4 (V -> empty .)
    FOR             reduce using rule 4 (V -> empty .)
    WHILE           reduce using rule 4 (V -> empty .)
    REPEAT          reduce using rule 4 (V -> empty .)
    GOSUB           reduce using rule 4 (V -> empty .)
    INPUT           reduce using rule 4 (V -> empty .)
    PRINT           reduce using rule 4 (V -> empty .)
    SUBPROCEDURE    reduce using rule 4 (V -> empty .)
    END             reduce using rule 4 (V -> empty .)


state 6

    (1) PROGRAMA -> PROGRAM V M . endProgram S END
    (2) endProgram -> .

    SUBPROCEDURE    reduce using rule 2 (endProgram -> .)
    END             reduce using rule 2 (endProgram -> .)

    endProgram                     shift and go to state 20

state 7

    (18) M -> F .

    SUBPROCEDURE    reduce using rule 18 (M -> F .)
    END             reduce using rule 18 (M -> F .)
    RETURN          reduce using rule 18 (M -> F .)


state 8

    (19) F -> E . F
    (19) F -> . E F
    (20) F -> . empty
    (21) E -> . LET setType IdLet EQUALS EA
    (22) E -> . DIM setType Idv AS T Arr
    (23) E -> . IF EL THEN first_conditional F Esf EIF final_conditional
    (24) E -> . FOR ID EQUALS EA for_assignation TO EA for_conditional DO for_save_conditional F NEXT ID for_conditional_end
    (25) E -> . WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional
    (26) E -> . REPEAT while_first_conditional F UNTIL EL repeat_conditional
    (27) E -> . GOSUB ID
    (28) E -> . INPUT IDEx
    (29) E -> . PRINT EA
    (79) empty -> .

    LET             shift and go to state 10
    DIM             shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    REPEAT          shift and go to state 15
    GOSUB           shift and go to state 16
    INPUT           shift and go to state 17
    PRINT           shift and go to state 18
    SUBPROCEDURE    reduce using rule 79 (empty -> .)
    END             reduce using rule 79 (empty -> .)
    UNTIL           reduce using rule 79 (empty -> .)
    ELSE            reduce using rule 79 (empty -> .)
    EIF             reduce using rule 79 (empty -> .)
    WEND            reduce using rule 79 (empty -> .)
    RETURN          reduce using rule 79 (empty -> .)
    NEXT            reduce using rule 79 (empty -> .)

    E                              shift and go to state 8
    F                              shift and go to state 21
    empty                          shift and go to state 9

state 9

    (20) F -> empty .

    SUBPROCEDURE    reduce using rule 20 (F -> empty .)
    END             reduce using rule 20 (F -> empty .)
    UNTIL           reduce using rule 20 (F -> empty .)
    ELSE            reduce using rule 20 (F -> empty .)
    EIF             reduce using rule 20 (F -> empty .)
    WEND            reduce using rule 20 (F -> empty .)
    RETURN          reduce using rule 20 (F -> empty .)
    NEXT            reduce using rule 20 (F -> empty .)


state 10

    (21) E -> LET . setType IdLet EQUALS EA
    (47) setType -> .

    ID              reduce using rule 47 (setType -> .)

    setType                        shift and go to state 22

state 11

    (22) E -> DIM . setType Idv AS T Arr
    (47) setType -> .

    ID              reduce using rule 47 (setType -> .)

    setType                        shift and go to state 23

state 12

    (23) E -> IF . EL THEN first_conditional F Esf EIF final_conditional
    (65) EL -> . TRUE
    (66) EL -> . FALSE
    (67) EL -> . OPENPAR O CLOSINGPAR
    (68) EL -> . OPENPAR O CLOSINGPAR OL EL

    TRUE            shift and go to state 25
    FALSE           shift and go to state 26
    OPENPAR         shift and go to state 27

    EL                             shift and go to state 24

state 13

    (24) E -> FOR . ID EQUALS EA for_assignation TO EA for_conditional DO for_save_conditional F NEXT ID for_conditional_end

    ID              shift and go to state 28


state 14

    (25) E -> WHILE . while_first_conditional EL DO while_second_conditional F WEND while_final_conditional
    (35) while_first_conditional -> .

    TRUE            reduce using rule 35 (while_first_conditional -> .)
    FALSE           reduce using rule 35 (while_first_conditional -> .)
    OPENPAR         reduce using rule 35 (while_first_conditional -> .)

    while_first_conditional        shift and go to state 29

state 15

    (26) E -> REPEAT . while_first_conditional F UNTIL EL repeat_conditional
    (35) while_first_conditional -> .

    LET             reduce using rule 35 (while_first_conditional -> .)
    DIM             reduce using rule 35 (while_first_conditional -> .)
    IF              reduce using rule 35 (while_first_conditional -> .)
    FOR             reduce using rule 35 (while_first_conditional -> .)
    WHILE           reduce using rule 35 (while_first_conditional -> .)
    REPEAT          reduce using rule 35 (while_first_conditional -> .)
    GOSUB           reduce using rule 35 (while_first_conditional -> .)
    INPUT           reduce using rule 35 (while_first_conditional -> .)
    PRINT           reduce using rule 35 (while_first_conditional -> .)
    UNTIL           reduce using rule 35 (while_first_conditional -> .)

    while_first_conditional        shift and go to state 30

state 16

    (27) E -> GOSUB . ID

    ID              shift and go to state 31


state 17

    (28) E -> INPUT . IDEx
    (48) IDEx -> . ID
    (49) IDEx -> . ID OPENBRACKET setType Idv CLOSINGBRACKET

    ID              shift and go to state 33

    IDEx                           shift and go to state 32

state 18

    (29) E -> PRINT . EA
    (50) EA -> . EA PLUS P
    (51) EA -> . EA MINUS P
    (52) EA -> . P
    (53) P -> . P MULTIPLY N
    (54) P -> . P DIVIDE N
    (55) P -> . N
    (56) N -> . ID Arr saveID
    (57) N -> . cte saveID
    (58) N -> . ID saveID
    (59) N -> . OPENPAR EA CLOSINGPAR
    (61) cte -> . FLOATVAL
    (62) cte -> . INTVAL
    (63) cte -> . MINUS INTVAL
    (64) cte -> . MINUS FLOATVAL

    ID              shift and go to state 38
    OPENPAR         shift and go to state 40
    FLOATVAL        shift and go to state 41
    INTVAL          shift and go to state 42
    MINUS           shift and go to state 36

    EA                             shift and go to state 34
    P                              shift and go to state 35
    N                              shift and go to state 37
    cte                            shift and go to state 39

state 19

    (3) V -> DIM setType . Idv AS T Arr
    (45) Idv -> . ID COMA Idv
    (46) Idv -> . ID

    ID              shift and go to state 44

    Idv                            shift and go to state 43

state 20

    (1) PROGRAMA -> PROGRAM V M endProgram . S END
    (14) S -> . SUBPROCEDURE ID fillSub TWOPOINTS M RETURN endProcedure S
    (15) S -> . empty
    (79) empty -> .

    SUBPROCEDURE    shift and go to state 46
    END             reduce using rule 79 (empty -> .)

    S                              shift and go to state 45
    empty                          shift and go to state 47

state 21

    (19) F -> E F .

    SUBPROCEDURE    reduce using rule 19 (F -> E F .)
    END             reduce using rule 19 (F -> E F .)
    UNTIL           reduce using rule 19 (F -> E F .)
    ELSE            reduce using rule 19 (F -> E F .)
    EIF             reduce using rule 19 (F -> E F .)
    WEND            reduce using rule 19 (F -> E F .)
    RETURN          reduce using rule 19 (F -> E F .)
    NEXT            reduce using rule 19 (F -> E F .)


state 22

    (21) E -> LET setType . IdLet EQUALS EA
    (43) IdLet -> . ID
    (44) IdLet -> . ID Arr

    ID              shift and go to state 49

    IdLet                          shift and go to state 48

state 23

    (22) E -> DIM setType . Idv AS T Arr
    (45) Idv -> . ID COMA Idv
    (46) Idv -> . ID

    ID              shift and go to state 44

    Idv                            shift and go to state 50

state 24

    (23) E -> IF EL . THEN first_conditional F Esf EIF final_conditional

    THEN            shift and go to state 51


state 25

    (65) EL -> TRUE .

    THEN            reduce using rule 65 (EL -> TRUE .)
    DO              reduce using rule 65 (EL -> TRUE .)
    LET             reduce using rule 65 (EL -> TRUE .)
    DIM             reduce using rule 65 (EL -> TRUE .)
    IF              reduce using rule 65 (EL -> TRUE .)
    FOR             reduce using rule 65 (EL -> TRUE .)
    WHILE           reduce using rule 65 (EL -> TRUE .)
    REPEAT          reduce using rule 65 (EL -> TRUE .)
    GOSUB           reduce using rule 65 (EL -> TRUE .)
    INPUT           reduce using rule 65 (EL -> TRUE .)
    PRINT           reduce using rule 65 (EL -> TRUE .)
    SUBPROCEDURE    reduce using rule 65 (EL -> TRUE .)
    END             reduce using rule 65 (EL -> TRUE .)
    UNTIL           reduce using rule 65 (EL -> TRUE .)
    ELSE            reduce using rule 65 (EL -> TRUE .)
    EIF             reduce using rule 65 (EL -> TRUE .)
    WEND            reduce using rule 65 (EL -> TRUE .)
    RETURN          reduce using rule 65 (EL -> TRUE .)
    NEXT            reduce using rule 65 (EL -> TRUE .)


state 26

    (66) EL -> FALSE .

    THEN            reduce using rule 66 (EL -> FALSE .)
    DO              reduce using rule 66 (EL -> FALSE .)
    LET             reduce using rule 66 (EL -> FALSE .)
    DIM             reduce using rule 66 (EL -> FALSE .)
    IF              reduce using rule 66 (EL -> FALSE .)
    FOR             reduce using rule 66 (EL -> FALSE .)
    WHILE           reduce using rule 66 (EL -> FALSE .)
    REPEAT          reduce using rule 66 (EL -> FALSE .)
    GOSUB           reduce using rule 66 (EL -> FALSE .)
    INPUT           reduce using rule 66 (EL -> FALSE .)
    PRINT           reduce using rule 66 (EL -> FALSE .)
    SUBPROCEDURE    reduce using rule 66 (EL -> FALSE .)
    END             reduce using rule 66 (EL -> FALSE .)
    UNTIL           reduce using rule 66 (EL -> FALSE .)
    ELSE            reduce using rule 66 (EL -> FALSE .)
    EIF             reduce using rule 66 (EL -> FALSE .)
    WEND            reduce using rule 66 (EL -> FALSE .)
    RETURN          reduce using rule 66 (EL -> FALSE .)
    NEXT            reduce using rule 66 (EL -> FALSE .)


state 27

    (67) EL -> OPENPAR . O CLOSINGPAR
    (68) EL -> OPENPAR . O CLOSINGPAR OL EL
    (72) O -> . EA GREATHER EA
    (73) O -> . EA GREATHEREQUAL EA
    (74) O -> . EA SMALLER EA
    (75) O -> . EA SMALLEREQUAL EA
    (76) O -> . EA NOTEQUAL EA
    (77) O -> . EA EQUALTO EA
    (78) O -> . EA error EA
    (50) EA -> . EA PLUS P
    (51) EA -> . EA MINUS P
    (52) EA -> . P
    (53) P -> . P MULTIPLY N
    (54) P -> . P DIVIDE N
    (55) P -> . N
    (56) N -> . ID Arr saveID
    (57) N -> . cte saveID
    (58) N -> . ID saveID
    (59) N -> . OPENPAR EA CLOSINGPAR
    (61) cte -> . FLOATVAL
    (62) cte -> . INTVAL
    (63) cte -> . MINUS INTVAL
    (64) cte -> . MINUS FLOATVAL

    ID              shift and go to state 38
    OPENPAR         shift and go to state 40
    FLOATVAL        shift and go to state 41
    INTVAL          shift and go to state 42
    MINUS           shift and go to state 36

    O                              shift and go to state 52
    EA                             shift and go to state 53
    P                              shift and go to state 35
    N                              shift and go to state 37
    cte                            shift and go to state 39

state 28

    (24) E -> FOR ID . EQUALS EA for_assignation TO EA for_conditional DO for_save_conditional F NEXT ID for_conditional_end

    EQUALS          shift and go to state 54


state 29

    (25) E -> WHILE while_first_conditional . EL DO while_second_conditional F WEND while_final_conditional
    (65) EL -> . TRUE
    (66) EL -> . FALSE
    (67) EL -> . OPENPAR O CLOSINGPAR
    (68) EL -> . OPENPAR O CLOSINGPAR OL EL

    TRUE            shift and go to state 25
    FALSE           shift and go to state 26
    OPENPAR         shift and go to state 27

    EL                             shift and go to state 55

state 30

    (26) E -> REPEAT while_first_conditional . F UNTIL EL repeat_conditional
    (19) F -> . E F
    (20) F -> . empty
    (21) E -> . LET setType IdLet EQUALS EA
    (22) E -> . DIM setType Idv AS T Arr
    (23) E -> . IF EL THEN first_conditional F Esf EIF final_conditional
    (24) E -> . FOR ID EQUALS EA for_assignation TO EA for_conditional DO for_save_conditional F NEXT ID for_conditional_end
    (25) E -> . WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional
    (26) E -> . REPEAT while_first_conditional F UNTIL EL repeat_conditional
    (27) E -> . GOSUB ID
    (28) E -> . INPUT IDEx
    (29) E -> . PRINT EA
    (79) empty -> .

    LET             shift and go to state 10
    DIM             shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    REPEAT          shift and go to state 15
    GOSUB           shift and go to state 16
    INPUT           shift and go to state 17
    PRINT           shift and go to state 18
    UNTIL           reduce using rule 79 (empty -> .)

    F                              shift and go to state 56
    E                              shift and go to state 8
    empty                          shift and go to state 9

state 31

    (27) E -> GOSUB ID .

    LET             reduce using rule 27 (E -> GOSUB ID .)
    DIM             reduce using rule 27 (E -> GOSUB ID .)
    IF              reduce using rule 27 (E -> GOSUB ID .)
    FOR             reduce using rule 27 (E -> GOSUB ID .)
    WHILE           reduce using rule 27 (E -> GOSUB ID .)
    REPEAT          reduce using rule 27 (E -> GOSUB ID .)
    GOSUB           reduce using rule 27 (E -> GOSUB ID .)
    INPUT           reduce using rule 27 (E -> GOSUB ID .)
    PRINT           reduce using rule 27 (E -> GOSUB ID .)
    SUBPROCEDURE    reduce using rule 27 (E -> GOSUB ID .)
    END             reduce using rule 27 (E -> GOSUB ID .)
    UNTIL           reduce using rule 27 (E -> GOSUB ID .)
    ELSE            reduce using rule 27 (E -> GOSUB ID .)
    EIF             reduce using rule 27 (E -> GOSUB ID .)
    WEND            reduce using rule 27 (E -> GOSUB ID .)
    RETURN          reduce using rule 27 (E -> GOSUB ID .)
    NEXT            reduce using rule 27 (E -> GOSUB ID .)


state 32

    (28) E -> INPUT IDEx .

    LET             reduce using rule 28 (E -> INPUT IDEx .)
    DIM             reduce using rule 28 (E -> INPUT IDEx .)
    IF              reduce using rule 28 (E -> INPUT IDEx .)
    FOR             reduce using rule 28 (E -> INPUT IDEx .)
    WHILE           reduce using rule 28 (E -> INPUT IDEx .)
    REPEAT          reduce using rule 28 (E -> INPUT IDEx .)
    GOSUB           reduce using rule 28 (E -> INPUT IDEx .)
    INPUT           reduce using rule 28 (E -> INPUT IDEx .)
    PRINT           reduce using rule 28 (E -> INPUT IDEx .)
    SUBPROCEDURE    reduce using rule 28 (E -> INPUT IDEx .)
    END             reduce using rule 28 (E -> INPUT IDEx .)
    UNTIL           reduce using rule 28 (E -> INPUT IDEx .)
    ELSE            reduce using rule 28 (E -> INPUT IDEx .)
    EIF             reduce using rule 28 (E -> INPUT IDEx .)
    WEND            reduce using rule 28 (E -> INPUT IDEx .)
    RETURN          reduce using rule 28 (E -> INPUT IDEx .)
    NEXT            reduce using rule 28 (E -> INPUT IDEx .)


state 33

    (48) IDEx -> ID .
    (49) IDEx -> ID . OPENBRACKET setType Idv CLOSINGBRACKET

    LET             reduce using rule 48 (IDEx -> ID .)
    DIM             reduce using rule 48 (IDEx -> ID .)
    IF              reduce using rule 48 (IDEx -> ID .)
    FOR             reduce using rule 48 (IDEx -> ID .)
    WHILE           reduce using rule 48 (IDEx -> ID .)
    REPEAT          reduce using rule 48 (IDEx -> ID .)
    GOSUB           reduce using rule 48 (IDEx -> ID .)
    INPUT           reduce using rule 48 (IDEx -> ID .)
    PRINT           reduce using rule 48 (IDEx -> ID .)
    SUBPROCEDURE    reduce using rule 48 (IDEx -> ID .)
    END             reduce using rule 48 (IDEx -> ID .)
    UNTIL           reduce using rule 48 (IDEx -> ID .)
    ELSE            reduce using rule 48 (IDEx -> ID .)
    EIF             reduce using rule 48 (IDEx -> ID .)
    WEND            reduce using rule 48 (IDEx -> ID .)
    RETURN          reduce using rule 48 (IDEx -> ID .)
    NEXT            reduce using rule 48 (IDEx -> ID .)
    OPENBRACKET     shift and go to state 57


state 34

    (29) E -> PRINT EA .
    (50) EA -> EA . PLUS P
    (51) EA -> EA . MINUS P

    LET             reduce using rule 29 (E -> PRINT EA .)
    DIM             reduce using rule 29 (E -> PRINT EA .)
    IF              reduce using rule 29 (E -> PRINT EA .)
    FOR             reduce using rule 29 (E -> PRINT EA .)
    WHILE           reduce using rule 29 (E -> PRINT EA .)
    REPEAT          reduce using rule 29 (E -> PRINT EA .)
    GOSUB           reduce using rule 29 (E -> PRINT EA .)
    INPUT           reduce using rule 29 (E -> PRINT EA .)
    PRINT           reduce using rule 29 (E -> PRINT EA .)
    SUBPROCEDURE    reduce using rule 29 (E -> PRINT EA .)
    END             reduce using rule 29 (E -> PRINT EA .)
    UNTIL           reduce using rule 29 (E -> PRINT EA .)
    ELSE            reduce using rule 29 (E -> PRINT EA .)
    EIF             reduce using rule 29 (E -> PRINT EA .)
    WEND            reduce using rule 29 (E -> PRINT EA .)
    RETURN          reduce using rule 29 (E -> PRINT EA .)
    NEXT            reduce using rule 29 (E -> PRINT EA .)
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59


state 35

    (52) EA -> P .
    (53) P -> P . MULTIPLY N
    (54) P -> P . DIVIDE N

    PLUS            reduce using rule 52 (EA -> P .)
    MINUS           reduce using rule 52 (EA -> P .)
    LET             reduce using rule 52 (EA -> P .)
    DIM             reduce using rule 52 (EA -> P .)
    IF              reduce using rule 52 (EA -> P .)
    FOR             reduce using rule 52 (EA -> P .)
    WHILE           reduce using rule 52 (EA -> P .)
    REPEAT          reduce using rule 52 (EA -> P .)
    GOSUB           reduce using rule 52 (EA -> P .)
    INPUT           reduce using rule 52 (EA -> P .)
    PRINT           reduce using rule 52 (EA -> P .)
    SUBPROCEDURE    reduce using rule 52 (EA -> P .)
    END             reduce using rule 52 (EA -> P .)
    UNTIL           reduce using rule 52 (EA -> P .)
    ELSE            reduce using rule 52 (EA -> P .)
    EIF             reduce using rule 52 (EA -> P .)
    WEND            reduce using rule 52 (EA -> P .)
    RETURN          reduce using rule 52 (EA -> P .)
    NEXT            reduce using rule 52 (EA -> P .)
    GREATHER        reduce using rule 52 (EA -> P .)
    GREATHEREQUAL   reduce using rule 52 (EA -> P .)
    SMALLER         reduce using rule 52 (EA -> P .)
    SMALLEREQUAL    reduce using rule 52 (EA -> P .)
    NOTEQUAL        reduce using rule 52 (EA -> P .)
    EQUALTO         reduce using rule 52 (EA -> P .)
    error           reduce using rule 52 (EA -> P .)
    CLOSINGPAR      reduce using rule 52 (EA -> P .)
    TO              reduce using rule 52 (EA -> P .)
    DO              reduce using rule 52 (EA -> P .)
    MULTIPLY        shift and go to state 60
    DIVIDE          shift and go to state 61


state 36

    (63) cte -> MINUS . INTVAL
    (64) cte -> MINUS . FLOATVAL

    INTVAL          shift and go to state 62
    FLOATVAL        shift and go to state 63


state 37

    (55) P -> N .

    MULTIPLY        reduce using rule 55 (P -> N .)
    DIVIDE          reduce using rule 55 (P -> N .)
    PLUS            reduce using rule 55 (P -> N .)
    MINUS           reduce using rule 55 (P -> N .)
    LET             reduce using rule 55 (P -> N .)
    DIM             reduce using rule 55 (P -> N .)
    IF              reduce using rule 55 (P -> N .)
    FOR             reduce using rule 55 (P -> N .)
    WHILE           reduce using rule 55 (P -> N .)
    REPEAT          reduce using rule 55 (P -> N .)
    GOSUB           reduce using rule 55 (P -> N .)
    INPUT           reduce using rule 55 (P -> N .)
    PRINT           reduce using rule 55 (P -> N .)
    SUBPROCEDURE    reduce using rule 55 (P -> N .)
    END             reduce using rule 55 (P -> N .)
    UNTIL           reduce using rule 55 (P -> N .)
    ELSE            reduce using rule 55 (P -> N .)
    EIF             reduce using rule 55 (P -> N .)
    WEND            reduce using rule 55 (P -> N .)
    RETURN          reduce using rule 55 (P -> N .)
    NEXT            reduce using rule 55 (P -> N .)
    GREATHER        reduce using rule 55 (P -> N .)
    GREATHEREQUAL   reduce using rule 55 (P -> N .)
    SMALLER         reduce using rule 55 (P -> N .)
    SMALLEREQUAL    reduce using rule 55 (P -> N .)
    NOTEQUAL        reduce using rule 55 (P -> N .)
    EQUALTO         reduce using rule 55 (P -> N .)
    error           reduce using rule 55 (P -> N .)
    CLOSINGPAR      reduce using rule 55 (P -> N .)
    TO              reduce using rule 55 (P -> N .)
    DO              reduce using rule 55 (P -> N .)


state 38

    (56) N -> ID . Arr saveID
    (58) N -> ID . saveID
    (5) Arr -> . OPENBRACKET arr_space CLOSINGBRACKET
    (6) Arr -> . empty
    (60) saveID -> .
    (79) empty -> .

  ! reduce/reduce conflict for MULTIPLY resolved using rule 60 (saveID -> .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 60 (saveID -> .)
  ! reduce/reduce conflict for PLUS resolved using rule 60 (saveID -> .)
  ! reduce/reduce conflict for MINUS resolved using rule 60 (saveID -> .)
  ! reduce/reduce conflict for LET resolved using rule 60 (saveID -> .)
  ! reduce/reduce conflict for DIM resolved using rule 60 (saveID -> .)
  ! reduce/reduce conflict for IF resolved using rule 60 (saveID -> .)
  ! reduce/reduce conflict for FOR resolved using rule 60 (saveID -> .)
  ! reduce/reduce conflict for WHILE resolved using rule 60 (saveID -> .)
  ! reduce/reduce conflict for REPEAT resolved using rule 60 (saveID -> .)
  ! reduce/reduce conflict for GOSUB resolved using rule 60 (saveID -> .)
  ! reduce/reduce conflict for INPUT resolved using rule 60 (saveID -> .)
  ! reduce/reduce conflict for PRINT resolved using rule 60 (saveID -> .)
  ! reduce/reduce conflict for SUBPROCEDURE resolved using rule 60 (saveID -> .)
  ! reduce/reduce conflict for END resolved using rule 60 (saveID -> .)
  ! reduce/reduce conflict for UNTIL resolved using rule 60 (saveID -> .)
  ! reduce/reduce conflict for ELSE resolved using rule 60 (saveID -> .)
  ! reduce/reduce conflict for EIF resolved using rule 60 (saveID -> .)
  ! reduce/reduce conflict for WEND resolved using rule 60 (saveID -> .)
  ! reduce/reduce conflict for RETURN resolved using rule 60 (saveID -> .)
  ! reduce/reduce conflict for NEXT resolved using rule 60 (saveID -> .)
  ! reduce/reduce conflict for GREATHER resolved using rule 60 (saveID -> .)
  ! reduce/reduce conflict for GREATHEREQUAL resolved using rule 60 (saveID -> .)
  ! reduce/reduce conflict for SMALLER resolved using rule 60 (saveID -> .)
  ! reduce/reduce conflict for SMALLEREQUAL resolved using rule 60 (saveID -> .)
  ! reduce/reduce conflict for NOTEQUAL resolved using rule 60 (saveID -> .)
  ! reduce/reduce conflict for EQUALTO resolved using rule 60 (saveID -> .)
  ! reduce/reduce conflict for error resolved using rule 60 (saveID -> .)
  ! reduce/reduce conflict for CLOSINGPAR resolved using rule 60 (saveID -> .)
  ! reduce/reduce conflict for TO resolved using rule 60 (saveID -> .)
  ! reduce/reduce conflict for DO resolved using rule 60 (saveID -> .)
    OPENBRACKET     shift and go to state 66
    MULTIPLY        reduce using rule 60 (saveID -> .)
    DIVIDE          reduce using rule 60 (saveID -> .)
    PLUS            reduce using rule 60 (saveID -> .)
    MINUS           reduce using rule 60 (saveID -> .)
    LET             reduce using rule 60 (saveID -> .)
    DIM             reduce using rule 60 (saveID -> .)
    IF              reduce using rule 60 (saveID -> .)
    FOR             reduce using rule 60 (saveID -> .)
    WHILE           reduce using rule 60 (saveID -> .)
    REPEAT          reduce using rule 60 (saveID -> .)
    GOSUB           reduce using rule 60 (saveID -> .)
    INPUT           reduce using rule 60 (saveID -> .)
    PRINT           reduce using rule 60 (saveID -> .)
    SUBPROCEDURE    reduce using rule 60 (saveID -> .)
    END             reduce using rule 60 (saveID -> .)
    UNTIL           reduce using rule 60 (saveID -> .)
    ELSE            reduce using rule 60 (saveID -> .)
    EIF             reduce using rule 60 (saveID -> .)
    WEND            reduce using rule 60 (saveID -> .)
    RETURN          reduce using rule 60 (saveID -> .)
    NEXT            reduce using rule 60 (saveID -> .)
    GREATHER        reduce using rule 60 (saveID -> .)
    GREATHEREQUAL   reduce using rule 60 (saveID -> .)
    SMALLER         reduce using rule 60 (saveID -> .)
    SMALLEREQUAL    reduce using rule 60 (saveID -> .)
    NOTEQUAL        reduce using rule 60 (saveID -> .)
    EQUALTO         reduce using rule 60 (saveID -> .)
    error           reduce using rule 60 (saveID -> .)
    CLOSINGPAR      reduce using rule 60 (saveID -> .)
    TO              reduce using rule 60 (saveID -> .)
    DO              reduce using rule 60 (saveID -> .)

  ! MULTIPLY        [ reduce using rule 79 (empty -> .) ]
  ! DIVIDE          [ reduce using rule 79 (empty -> .) ]
  ! PLUS            [ reduce using rule 79 (empty -> .) ]
  ! MINUS           [ reduce using rule 79 (empty -> .) ]
  ! LET             [ reduce using rule 79 (empty -> .) ]
  ! DIM             [ reduce using rule 79 (empty -> .) ]
  ! IF              [ reduce using rule 79 (empty -> .) ]
  ! FOR             [ reduce using rule 79 (empty -> .) ]
  ! WHILE           [ reduce using rule 79 (empty -> .) ]
  ! REPEAT          [ reduce using rule 79 (empty -> .) ]
  ! GOSUB           [ reduce using rule 79 (empty -> .) ]
  ! INPUT           [ reduce using rule 79 (empty -> .) ]
  ! PRINT           [ reduce using rule 79 (empty -> .) ]
  ! SUBPROCEDURE    [ reduce using rule 79 (empty -> .) ]
  ! END             [ reduce using rule 79 (empty -> .) ]
  ! UNTIL           [ reduce using rule 79 (empty -> .) ]
  ! ELSE            [ reduce using rule 79 (empty -> .) ]
  ! EIF             [ reduce using rule 79 (empty -> .) ]
  ! WEND            [ reduce using rule 79 (empty -> .) ]
  ! RETURN          [ reduce using rule 79 (empty -> .) ]
  ! NEXT            [ reduce using rule 79 (empty -> .) ]
  ! GREATHER        [ reduce using rule 79 (empty -> .) ]
  ! GREATHEREQUAL   [ reduce using rule 79 (empty -> .) ]
  ! SMALLER         [ reduce using rule 79 (empty -> .) ]
  ! SMALLEREQUAL    [ reduce using rule 79 (empty -> .) ]
  ! NOTEQUAL        [ reduce using rule 79 (empty -> .) ]
  ! EQUALTO         [ reduce using rule 79 (empty -> .) ]
  ! error           [ reduce using rule 79 (empty -> .) ]
  ! CLOSINGPAR      [ reduce using rule 79 (empty -> .) ]
  ! TO              [ reduce using rule 79 (empty -> .) ]
  ! DO              [ reduce using rule 79 (empty -> .) ]

    Arr                            shift and go to state 64
    saveID                         shift and go to state 65
    empty                          shift and go to state 67

state 39

    (57) N -> cte . saveID
    (60) saveID -> .

    MULTIPLY        reduce using rule 60 (saveID -> .)
    DIVIDE          reduce using rule 60 (saveID -> .)
    PLUS            reduce using rule 60 (saveID -> .)
    MINUS           reduce using rule 60 (saveID -> .)
    LET             reduce using rule 60 (saveID -> .)
    DIM             reduce using rule 60 (saveID -> .)
    IF              reduce using rule 60 (saveID -> .)
    FOR             reduce using rule 60 (saveID -> .)
    WHILE           reduce using rule 60 (saveID -> .)
    REPEAT          reduce using rule 60 (saveID -> .)
    GOSUB           reduce using rule 60 (saveID -> .)
    INPUT           reduce using rule 60 (saveID -> .)
    PRINT           reduce using rule 60 (saveID -> .)
    SUBPROCEDURE    reduce using rule 60 (saveID -> .)
    END             reduce using rule 60 (saveID -> .)
    UNTIL           reduce using rule 60 (saveID -> .)
    ELSE            reduce using rule 60 (saveID -> .)
    EIF             reduce using rule 60 (saveID -> .)
    WEND            reduce using rule 60 (saveID -> .)
    RETURN          reduce using rule 60 (saveID -> .)
    NEXT            reduce using rule 60 (saveID -> .)
    GREATHER        reduce using rule 60 (saveID -> .)
    GREATHEREQUAL   reduce using rule 60 (saveID -> .)
    SMALLER         reduce using rule 60 (saveID -> .)
    SMALLEREQUAL    reduce using rule 60 (saveID -> .)
    NOTEQUAL        reduce using rule 60 (saveID -> .)
    EQUALTO         reduce using rule 60 (saveID -> .)
    error           reduce using rule 60 (saveID -> .)
    CLOSINGPAR      reduce using rule 60 (saveID -> .)
    TO              reduce using rule 60 (saveID -> .)
    DO              reduce using rule 60 (saveID -> .)

    saveID                         shift and go to state 68

state 40

    (59) N -> OPENPAR . EA CLOSINGPAR
    (50) EA -> . EA PLUS P
    (51) EA -> . EA MINUS P
    (52) EA -> . P
    (53) P -> . P MULTIPLY N
    (54) P -> . P DIVIDE N
    (55) P -> . N
    (56) N -> . ID Arr saveID
    (57) N -> . cte saveID
    (58) N -> . ID saveID
    (59) N -> . OPENPAR EA CLOSINGPAR
    (61) cte -> . FLOATVAL
    (62) cte -> . INTVAL
    (63) cte -> . MINUS INTVAL
    (64) cte -> . MINUS FLOATVAL

    ID              shift and go to state 38
    OPENPAR         shift and go to state 40
    FLOATVAL        shift and go to state 41
    INTVAL          shift and go to state 42
    MINUS           shift and go to state 36

    EA                             shift and go to state 69
    P                              shift and go to state 35
    N                              shift and go to state 37
    cte                            shift and go to state 39

state 41

    (61) cte -> FLOATVAL .

    MULTIPLY        reduce using rule 61 (cte -> FLOATVAL .)
    DIVIDE          reduce using rule 61 (cte -> FLOATVAL .)
    PLUS            reduce using rule 61 (cte -> FLOATVAL .)
    MINUS           reduce using rule 61 (cte -> FLOATVAL .)
    LET             reduce using rule 61 (cte -> FLOATVAL .)
    DIM             reduce using rule 61 (cte -> FLOATVAL .)
    IF              reduce using rule 61 (cte -> FLOATVAL .)
    FOR             reduce using rule 61 (cte -> FLOATVAL .)
    WHILE           reduce using rule 61 (cte -> FLOATVAL .)
    REPEAT          reduce using rule 61 (cte -> FLOATVAL .)
    GOSUB           reduce using rule 61 (cte -> FLOATVAL .)
    INPUT           reduce using rule 61 (cte -> FLOATVAL .)
    PRINT           reduce using rule 61 (cte -> FLOATVAL .)
    SUBPROCEDURE    reduce using rule 61 (cte -> FLOATVAL .)
    END             reduce using rule 61 (cte -> FLOATVAL .)
    UNTIL           reduce using rule 61 (cte -> FLOATVAL .)
    ELSE            reduce using rule 61 (cte -> FLOATVAL .)
    EIF             reduce using rule 61 (cte -> FLOATVAL .)
    WEND            reduce using rule 61 (cte -> FLOATVAL .)
    RETURN          reduce using rule 61 (cte -> FLOATVAL .)
    NEXT            reduce using rule 61 (cte -> FLOATVAL .)
    GREATHER        reduce using rule 61 (cte -> FLOATVAL .)
    GREATHEREQUAL   reduce using rule 61 (cte -> FLOATVAL .)
    SMALLER         reduce using rule 61 (cte -> FLOATVAL .)
    SMALLEREQUAL    reduce using rule 61 (cte -> FLOATVAL .)
    NOTEQUAL        reduce using rule 61 (cte -> FLOATVAL .)
    EQUALTO         reduce using rule 61 (cte -> FLOATVAL .)
    error           reduce using rule 61 (cte -> FLOATVAL .)
    CLOSINGPAR      reduce using rule 61 (cte -> FLOATVAL .)
    TO              reduce using rule 61 (cte -> FLOATVAL .)
    DO              reduce using rule 61 (cte -> FLOATVAL .)


state 42

    (62) cte -> INTVAL .

    MULTIPLY        reduce using rule 62 (cte -> INTVAL .)
    DIVIDE          reduce using rule 62 (cte -> INTVAL .)
    PLUS            reduce using rule 62 (cte -> INTVAL .)
    MINUS           reduce using rule 62 (cte -> INTVAL .)
    LET             reduce using rule 62 (cte -> INTVAL .)
    DIM             reduce using rule 62 (cte -> INTVAL .)
    IF              reduce using rule 62 (cte -> INTVAL .)
    FOR             reduce using rule 62 (cte -> INTVAL .)
    WHILE           reduce using rule 62 (cte -> INTVAL .)
    REPEAT          reduce using rule 62 (cte -> INTVAL .)
    GOSUB           reduce using rule 62 (cte -> INTVAL .)
    INPUT           reduce using rule 62 (cte -> INTVAL .)
    PRINT           reduce using rule 62 (cte -> INTVAL .)
    SUBPROCEDURE    reduce using rule 62 (cte -> INTVAL .)
    END             reduce using rule 62 (cte -> INTVAL .)
    UNTIL           reduce using rule 62 (cte -> INTVAL .)
    ELSE            reduce using rule 62 (cte -> INTVAL .)
    EIF             reduce using rule 62 (cte -> INTVAL .)
    WEND            reduce using rule 62 (cte -> INTVAL .)
    RETURN          reduce using rule 62 (cte -> INTVAL .)
    NEXT            reduce using rule 62 (cte -> INTVAL .)
    GREATHER        reduce using rule 62 (cte -> INTVAL .)
    GREATHEREQUAL   reduce using rule 62 (cte -> INTVAL .)
    SMALLER         reduce using rule 62 (cte -> INTVAL .)
    SMALLEREQUAL    reduce using rule 62 (cte -> INTVAL .)
    NOTEQUAL        reduce using rule 62 (cte -> INTVAL .)
    EQUALTO         reduce using rule 62 (cte -> INTVAL .)
    error           reduce using rule 62 (cte -> INTVAL .)
    CLOSINGPAR      reduce using rule 62 (cte -> INTVAL .)
    TO              reduce using rule 62 (cte -> INTVAL .)
    DO              reduce using rule 62 (cte -> INTVAL .)


state 43

    (3) V -> DIM setType Idv . AS T Arr

    AS              shift and go to state 70


state 44

    (45) Idv -> ID . COMA Idv
    (46) Idv -> ID .

    COMA            shift and go to state 71
    AS              reduce using rule 46 (Idv -> ID .)
    CLOSINGBRACKET  reduce using rule 46 (Idv -> ID .)


state 45

    (1) PROGRAMA -> PROGRAM V M endProgram S . END

    END             shift and go to state 72


state 46

    (14) S -> SUBPROCEDURE . ID fillSub TWOPOINTS M RETURN endProcedure S

    ID              shift and go to state 73


state 47

    (15) S -> empty .

    END             reduce using rule 15 (S -> empty .)


state 48

    (21) E -> LET setType IdLet . EQUALS EA

    EQUALS          shift and go to state 74


state 49

    (43) IdLet -> ID .
    (44) IdLet -> ID . Arr
    (5) Arr -> . OPENBRACKET arr_space CLOSINGBRACKET
    (6) Arr -> . empty
    (79) empty -> .

  ! reduce/reduce conflict for EQUALS resolved using rule 43 (IdLet -> ID .)
    EQUALS          reduce using rule 43 (IdLet -> ID .)
    OPENBRACKET     shift and go to state 66

  ! EQUALS          [ reduce using rule 79 (empty -> .) ]

    Arr                            shift and go to state 75
    empty                          shift and go to state 67

state 50

    (22) E -> DIM setType Idv . AS T Arr

    AS              shift and go to state 76


state 51

    (23) E -> IF EL THEN . first_conditional F Esf EIF final_conditional
    (38) first_conditional -> .

    LET             reduce using rule 38 (first_conditional -> .)
    DIM             reduce using rule 38 (first_conditional -> .)
    IF              reduce using rule 38 (first_conditional -> .)
    FOR             reduce using rule 38 (first_conditional -> .)
    WHILE           reduce using rule 38 (first_conditional -> .)
    REPEAT          reduce using rule 38 (first_conditional -> .)
    GOSUB           reduce using rule 38 (first_conditional -> .)
    INPUT           reduce using rule 38 (first_conditional -> .)
    PRINT           reduce using rule 38 (first_conditional -> .)
    ELSE            reduce using rule 38 (first_conditional -> .)
    EIF             reduce using rule 38 (first_conditional -> .)

    first_conditional              shift and go to state 77

state 52

    (67) EL -> OPENPAR O . CLOSINGPAR
    (68) EL -> OPENPAR O . CLOSINGPAR OL EL

    CLOSINGPAR      shift and go to state 78


state 53

    (72) O -> EA . GREATHER EA
    (73) O -> EA . GREATHEREQUAL EA
    (74) O -> EA . SMALLER EA
    (75) O -> EA . SMALLEREQUAL EA
    (76) O -> EA . NOTEQUAL EA
    (77) O -> EA . EQUALTO EA
    (78) O -> EA . error EA
    (50) EA -> EA . PLUS P
    (51) EA -> EA . MINUS P

    GREATHER        shift and go to state 79
    GREATHEREQUAL   shift and go to state 80
    SMALLER         shift and go to state 81
    SMALLEREQUAL    shift and go to state 82
    NOTEQUAL        shift and go to state 83
    EQUALTO         shift and go to state 84
    error           shift and go to state 85
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59


state 54

    (24) E -> FOR ID EQUALS . EA for_assignation TO EA for_conditional DO for_save_conditional F NEXT ID for_conditional_end
    (50) EA -> . EA PLUS P
    (51) EA -> . EA MINUS P
    (52) EA -> . P
    (53) P -> . P MULTIPLY N
    (54) P -> . P DIVIDE N
    (55) P -> . N
    (56) N -> . ID Arr saveID
    (57) N -> . cte saveID
    (58) N -> . ID saveID
    (59) N -> . OPENPAR EA CLOSINGPAR
    (61) cte -> . FLOATVAL
    (62) cte -> . INTVAL
    (63) cte -> . MINUS INTVAL
    (64) cte -> . MINUS FLOATVAL

    ID              shift and go to state 38
    OPENPAR         shift and go to state 40
    FLOATVAL        shift and go to state 41
    INTVAL          shift and go to state 42
    MINUS           shift and go to state 36

    EA                             shift and go to state 86
    P                              shift and go to state 35
    N                              shift and go to state 37
    cte                            shift and go to state 39

state 55

    (25) E -> WHILE while_first_conditional EL . DO while_second_conditional F WEND while_final_conditional

    DO              shift and go to state 87


state 56

    (26) E -> REPEAT while_first_conditional F . UNTIL EL repeat_conditional

    UNTIL           shift and go to state 88


state 57

    (49) IDEx -> ID OPENBRACKET . setType Idv CLOSINGBRACKET
    (47) setType -> .

    ID              reduce using rule 47 (setType -> .)

    setType                        shift and go to state 89

state 58

    (50) EA -> EA PLUS . P
    (53) P -> . P MULTIPLY N
    (54) P -> . P DIVIDE N
    (55) P -> . N
    (56) N -> . ID Arr saveID
    (57) N -> . cte saveID
    (58) N -> . ID saveID
    (59) N -> . OPENPAR EA CLOSINGPAR
    (61) cte -> . FLOATVAL
    (62) cte -> . INTVAL
    (63) cte -> . MINUS INTVAL
    (64) cte -> . MINUS FLOATVAL

    ID              shift and go to state 38
    OPENPAR         shift and go to state 40
    FLOATVAL        shift and go to state 41
    INTVAL          shift and go to state 42
    MINUS           shift and go to state 36

    P                              shift and go to state 90
    N                              shift and go to state 37
    cte                            shift and go to state 39

state 59

    (51) EA -> EA MINUS . P
    (53) P -> . P MULTIPLY N
    (54) P -> . P DIVIDE N
    (55) P -> . N
    (56) N -> . ID Arr saveID
    (57) N -> . cte saveID
    (58) N -> . ID saveID
    (59) N -> . OPENPAR EA CLOSINGPAR
    (61) cte -> . FLOATVAL
    (62) cte -> . INTVAL
    (63) cte -> . MINUS INTVAL
    (64) cte -> . MINUS FLOATVAL

    ID              shift and go to state 38
    OPENPAR         shift and go to state 40
    FLOATVAL        shift and go to state 41
    INTVAL          shift and go to state 42
    MINUS           shift and go to state 36

    P                              shift and go to state 91
    N                              shift and go to state 37
    cte                            shift and go to state 39

state 60

    (53) P -> P MULTIPLY . N
    (56) N -> . ID Arr saveID
    (57) N -> . cte saveID
    (58) N -> . ID saveID
    (59) N -> . OPENPAR EA CLOSINGPAR
    (61) cte -> . FLOATVAL
    (62) cte -> . INTVAL
    (63) cte -> . MINUS INTVAL
    (64) cte -> . MINUS FLOATVAL

    ID              shift and go to state 38
    OPENPAR         shift and go to state 40
    FLOATVAL        shift and go to state 41
    INTVAL          shift and go to state 42
    MINUS           shift and go to state 36

    N                              shift and go to state 92
    cte                            shift and go to state 39

state 61

    (54) P -> P DIVIDE . N
    (56) N -> . ID Arr saveID
    (57) N -> . cte saveID
    (58) N -> . ID saveID
    (59) N -> . OPENPAR EA CLOSINGPAR
    (61) cte -> . FLOATVAL
    (62) cte -> . INTVAL
    (63) cte -> . MINUS INTVAL
    (64) cte -> . MINUS FLOATVAL

    ID              shift and go to state 38
    OPENPAR         shift and go to state 40
    FLOATVAL        shift and go to state 41
    INTVAL          shift and go to state 42
    MINUS           shift and go to state 36

    N                              shift and go to state 93
    cte                            shift and go to state 39

state 62

    (63) cte -> MINUS INTVAL .

    MULTIPLY        reduce using rule 63 (cte -> MINUS INTVAL .)
    DIVIDE          reduce using rule 63 (cte -> MINUS INTVAL .)
    PLUS            reduce using rule 63 (cte -> MINUS INTVAL .)
    MINUS           reduce using rule 63 (cte -> MINUS INTVAL .)
    LET             reduce using rule 63 (cte -> MINUS INTVAL .)
    DIM             reduce using rule 63 (cte -> MINUS INTVAL .)
    IF              reduce using rule 63 (cte -> MINUS INTVAL .)
    FOR             reduce using rule 63 (cte -> MINUS INTVAL .)
    WHILE           reduce using rule 63 (cte -> MINUS INTVAL .)
    REPEAT          reduce using rule 63 (cte -> MINUS INTVAL .)
    GOSUB           reduce using rule 63 (cte -> MINUS INTVAL .)
    INPUT           reduce using rule 63 (cte -> MINUS INTVAL .)
    PRINT           reduce using rule 63 (cte -> MINUS INTVAL .)
    SUBPROCEDURE    reduce using rule 63 (cte -> MINUS INTVAL .)
    END             reduce using rule 63 (cte -> MINUS INTVAL .)
    UNTIL           reduce using rule 63 (cte -> MINUS INTVAL .)
    ELSE            reduce using rule 63 (cte -> MINUS INTVAL .)
    EIF             reduce using rule 63 (cte -> MINUS INTVAL .)
    WEND            reduce using rule 63 (cte -> MINUS INTVAL .)
    RETURN          reduce using rule 63 (cte -> MINUS INTVAL .)
    NEXT            reduce using rule 63 (cte -> MINUS INTVAL .)
    GREATHER        reduce using rule 63 (cte -> MINUS INTVAL .)
    GREATHEREQUAL   reduce using rule 63 (cte -> MINUS INTVAL .)
    SMALLER         reduce using rule 63 (cte -> MINUS INTVAL .)
    SMALLEREQUAL    reduce using rule 63 (cte -> MINUS INTVAL .)
    NOTEQUAL        reduce using rule 63 (cte -> MINUS INTVAL .)
    EQUALTO         reduce using rule 63 (cte -> MINUS INTVAL .)
    error           reduce using rule 63 (cte -> MINUS INTVAL .)
    CLOSINGPAR      reduce using rule 63 (cte -> MINUS INTVAL .)
    TO              reduce using rule 63 (cte -> MINUS INTVAL .)
    DO              reduce using rule 63 (cte -> MINUS INTVAL .)


state 63

    (64) cte -> MINUS FLOATVAL .

    MULTIPLY        reduce using rule 64 (cte -> MINUS FLOATVAL .)
    DIVIDE          reduce using rule 64 (cte -> MINUS FLOATVAL .)
    PLUS            reduce using rule 64 (cte -> MINUS FLOATVAL .)
    MINUS           reduce using rule 64 (cte -> MINUS FLOATVAL .)
    LET             reduce using rule 64 (cte -> MINUS FLOATVAL .)
    DIM             reduce using rule 64 (cte -> MINUS FLOATVAL .)
    IF              reduce using rule 64 (cte -> MINUS FLOATVAL .)
    FOR             reduce using rule 64 (cte -> MINUS FLOATVAL .)
    WHILE           reduce using rule 64 (cte -> MINUS FLOATVAL .)
    REPEAT          reduce using rule 64 (cte -> MINUS FLOATVAL .)
    GOSUB           reduce using rule 64 (cte -> MINUS FLOATVAL .)
    INPUT           reduce using rule 64 (cte -> MINUS FLOATVAL .)
    PRINT           reduce using rule 64 (cte -> MINUS FLOATVAL .)
    SUBPROCEDURE    reduce using rule 64 (cte -> MINUS FLOATVAL .)
    END             reduce using rule 64 (cte -> MINUS FLOATVAL .)
    UNTIL           reduce using rule 64 (cte -> MINUS FLOATVAL .)
    ELSE            reduce using rule 64 (cte -> MINUS FLOATVAL .)
    EIF             reduce using rule 64 (cte -> MINUS FLOATVAL .)
    WEND            reduce using rule 64 (cte -> MINUS FLOATVAL .)
    RETURN          reduce using rule 64 (cte -> MINUS FLOATVAL .)
    NEXT            reduce using rule 64 (cte -> MINUS FLOATVAL .)
    GREATHER        reduce using rule 64 (cte -> MINUS FLOATVAL .)
    GREATHEREQUAL   reduce using rule 64 (cte -> MINUS FLOATVAL .)
    SMALLER         reduce using rule 64 (cte -> MINUS FLOATVAL .)
    SMALLEREQUAL    reduce using rule 64 (cte -> MINUS FLOATVAL .)
    NOTEQUAL        reduce using rule 64 (cte -> MINUS FLOATVAL .)
    EQUALTO         reduce using rule 64 (cte -> MINUS FLOATVAL .)
    error           reduce using rule 64 (cte -> MINUS FLOATVAL .)
    CLOSINGPAR      reduce using rule 64 (cte -> MINUS FLOATVAL .)
    TO              reduce using rule 64 (cte -> MINUS FLOATVAL .)
    DO              reduce using rule 64 (cte -> MINUS FLOATVAL .)


state 64

    (56) N -> ID Arr . saveID
    (60) saveID -> .

    MULTIPLY        reduce using rule 60 (saveID -> .)
    DIVIDE          reduce using rule 60 (saveID -> .)
    PLUS            reduce using rule 60 (saveID -> .)
    MINUS           reduce using rule 60 (saveID -> .)
    LET             reduce using rule 60 (saveID -> .)
    DIM             reduce using rule 60 (saveID -> .)
    IF              reduce using rule 60 (saveID -> .)
    FOR             reduce using rule 60 (saveID -> .)
    WHILE           reduce using rule 60 (saveID -> .)
    REPEAT          reduce using rule 60 (saveID -> .)
    GOSUB           reduce using rule 60 (saveID -> .)
    INPUT           reduce using rule 60 (saveID -> .)
    PRINT           reduce using rule 60 (saveID -> .)
    SUBPROCEDURE    reduce using rule 60 (saveID -> .)
    END             reduce using rule 60 (saveID -> .)
    UNTIL           reduce using rule 60 (saveID -> .)
    ELSE            reduce using rule 60 (saveID -> .)
    EIF             reduce using rule 60 (saveID -> .)
    WEND            reduce using rule 60 (saveID -> .)
    RETURN          reduce using rule 60 (saveID -> .)
    NEXT            reduce using rule 60 (saveID -> .)
    GREATHER        reduce using rule 60 (saveID -> .)
    GREATHEREQUAL   reduce using rule 60 (saveID -> .)
    SMALLER         reduce using rule 60 (saveID -> .)
    SMALLEREQUAL    reduce using rule 60 (saveID -> .)
    NOTEQUAL        reduce using rule 60 (saveID -> .)
    EQUALTO         reduce using rule 60 (saveID -> .)
    error           reduce using rule 60 (saveID -> .)
    CLOSINGPAR      reduce using rule 60 (saveID -> .)
    TO              reduce using rule 60 (saveID -> .)
    DO              reduce using rule 60 (saveID -> .)

    saveID                         shift and go to state 94

state 65

    (58) N -> ID saveID .

    MULTIPLY        reduce using rule 58 (N -> ID saveID .)
    DIVIDE          reduce using rule 58 (N -> ID saveID .)
    PLUS            reduce using rule 58 (N -> ID saveID .)
    MINUS           reduce using rule 58 (N -> ID saveID .)
    LET             reduce using rule 58 (N -> ID saveID .)
    DIM             reduce using rule 58 (N -> ID saveID .)
    IF              reduce using rule 58 (N -> ID saveID .)
    FOR             reduce using rule 58 (N -> ID saveID .)
    WHILE           reduce using rule 58 (N -> ID saveID .)
    REPEAT          reduce using rule 58 (N -> ID saveID .)
    GOSUB           reduce using rule 58 (N -> ID saveID .)
    INPUT           reduce using rule 58 (N -> ID saveID .)
    PRINT           reduce using rule 58 (N -> ID saveID .)
    SUBPROCEDURE    reduce using rule 58 (N -> ID saveID .)
    END             reduce using rule 58 (N -> ID saveID .)
    UNTIL           reduce using rule 58 (N -> ID saveID .)
    ELSE            reduce using rule 58 (N -> ID saveID .)
    EIF             reduce using rule 58 (N -> ID saveID .)
    WEND            reduce using rule 58 (N -> ID saveID .)
    RETURN          reduce using rule 58 (N -> ID saveID .)
    NEXT            reduce using rule 58 (N -> ID saveID .)
    GREATHER        reduce using rule 58 (N -> ID saveID .)
    GREATHEREQUAL   reduce using rule 58 (N -> ID saveID .)
    SMALLER         reduce using rule 58 (N -> ID saveID .)
    SMALLEREQUAL    reduce using rule 58 (N -> ID saveID .)
    NOTEQUAL        reduce using rule 58 (N -> ID saveID .)
    EQUALTO         reduce using rule 58 (N -> ID saveID .)
    error           reduce using rule 58 (N -> ID saveID .)
    CLOSINGPAR      reduce using rule 58 (N -> ID saveID .)
    TO              reduce using rule 58 (N -> ID saveID .)
    DO              reduce using rule 58 (N -> ID saveID .)


state 66

    (5) Arr -> OPENBRACKET . arr_space CLOSINGBRACKET
    (7) arr_space -> . arr_index COMA arr_space
    (8) arr_space -> . arr_index
    (9) arr_index -> . INTVAL
    (10) arr_index -> . ID

    INTVAL          shift and go to state 97
    ID              shift and go to state 98

    arr_space                      shift and go to state 95
    arr_index                      shift and go to state 96

state 67

    (6) Arr -> empty .

    MULTIPLY        reduce using rule 6 (Arr -> empty .)
    DIVIDE          reduce using rule 6 (Arr -> empty .)
    PLUS            reduce using rule 6 (Arr -> empty .)
    MINUS           reduce using rule 6 (Arr -> empty .)
    LET             reduce using rule 6 (Arr -> empty .)
    DIM             reduce using rule 6 (Arr -> empty .)
    IF              reduce using rule 6 (Arr -> empty .)
    FOR             reduce using rule 6 (Arr -> empty .)
    WHILE           reduce using rule 6 (Arr -> empty .)
    REPEAT          reduce using rule 6 (Arr -> empty .)
    GOSUB           reduce using rule 6 (Arr -> empty .)
    INPUT           reduce using rule 6 (Arr -> empty .)
    PRINT           reduce using rule 6 (Arr -> empty .)
    SUBPROCEDURE    reduce using rule 6 (Arr -> empty .)
    END             reduce using rule 6 (Arr -> empty .)
    UNTIL           reduce using rule 6 (Arr -> empty .)
    ELSE            reduce using rule 6 (Arr -> empty .)
    EIF             reduce using rule 6 (Arr -> empty .)
    WEND            reduce using rule 6 (Arr -> empty .)
    RETURN          reduce using rule 6 (Arr -> empty .)
    NEXT            reduce using rule 6 (Arr -> empty .)
    GREATHER        reduce using rule 6 (Arr -> empty .)
    GREATHEREQUAL   reduce using rule 6 (Arr -> empty .)
    SMALLER         reduce using rule 6 (Arr -> empty .)
    SMALLEREQUAL    reduce using rule 6 (Arr -> empty .)
    NOTEQUAL        reduce using rule 6 (Arr -> empty .)
    EQUALTO         reduce using rule 6 (Arr -> empty .)
    error           reduce using rule 6 (Arr -> empty .)
    CLOSINGPAR      reduce using rule 6 (Arr -> empty .)
    TO              reduce using rule 6 (Arr -> empty .)
    DO              reduce using rule 6 (Arr -> empty .)
    EQUALS          reduce using rule 6 (Arr -> empty .)


state 68

    (57) N -> cte saveID .

    MULTIPLY        reduce using rule 57 (N -> cte saveID .)
    DIVIDE          reduce using rule 57 (N -> cte saveID .)
    PLUS            reduce using rule 57 (N -> cte saveID .)
    MINUS           reduce using rule 57 (N -> cte saveID .)
    LET             reduce using rule 57 (N -> cte saveID .)
    DIM             reduce using rule 57 (N -> cte saveID .)
    IF              reduce using rule 57 (N -> cte saveID .)
    FOR             reduce using rule 57 (N -> cte saveID .)
    WHILE           reduce using rule 57 (N -> cte saveID .)
    REPEAT          reduce using rule 57 (N -> cte saveID .)
    GOSUB           reduce using rule 57 (N -> cte saveID .)
    INPUT           reduce using rule 57 (N -> cte saveID .)
    PRINT           reduce using rule 57 (N -> cte saveID .)
    SUBPROCEDURE    reduce using rule 57 (N -> cte saveID .)
    END             reduce using rule 57 (N -> cte saveID .)
    UNTIL           reduce using rule 57 (N -> cte saveID .)
    ELSE            reduce using rule 57 (N -> cte saveID .)
    EIF             reduce using rule 57 (N -> cte saveID .)
    WEND            reduce using rule 57 (N -> cte saveID .)
    RETURN          reduce using rule 57 (N -> cte saveID .)
    NEXT            reduce using rule 57 (N -> cte saveID .)
    GREATHER        reduce using rule 57 (N -> cte saveID .)
    GREATHEREQUAL   reduce using rule 57 (N -> cte saveID .)
    SMALLER         reduce using rule 57 (N -> cte saveID .)
    SMALLEREQUAL    reduce using rule 57 (N -> cte saveID .)
    NOTEQUAL        reduce using rule 57 (N -> cte saveID .)
    EQUALTO         reduce using rule 57 (N -> cte saveID .)
    error           reduce using rule 57 (N -> cte saveID .)
    CLOSINGPAR      reduce using rule 57 (N -> cte saveID .)
    TO              reduce using rule 57 (N -> cte saveID .)
    DO              reduce using rule 57 (N -> cte saveID .)


state 69

    (59) N -> OPENPAR EA . CLOSINGPAR
    (50) EA -> EA . PLUS P
    (51) EA -> EA . MINUS P

    CLOSINGPAR      shift and go to state 99
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59


state 70

    (3) V -> DIM setType Idv AS . T Arr
    (11) T -> . INT
    (12) T -> . FLOAT
    (13) T -> . WORD

    INT             shift and go to state 101
    FLOAT           shift and go to state 102
    WORD            shift and go to state 103

    T                              shift and go to state 100

state 71

    (45) Idv -> ID COMA . Idv
    (45) Idv -> . ID COMA Idv
    (46) Idv -> . ID

    ID              shift and go to state 44

    Idv                            shift and go to state 104

state 72

    (1) PROGRAMA -> PROGRAM V M endProgram S END .

    $end            reduce using rule 1 (PROGRAMA -> PROGRAM V M endProgram S END .)


state 73

    (14) S -> SUBPROCEDURE ID . fillSub TWOPOINTS M RETURN endProcedure S
    (16) fillSub -> .

    TWOPOINTS       reduce using rule 16 (fillSub -> .)

    fillSub                        shift and go to state 105

state 74

    (21) E -> LET setType IdLet EQUALS . EA
    (50) EA -> . EA PLUS P
    (51) EA -> . EA MINUS P
    (52) EA -> . P
    (53) P -> . P MULTIPLY N
    (54) P -> . P DIVIDE N
    (55) P -> . N
    (56) N -> . ID Arr saveID
    (57) N -> . cte saveID
    (58) N -> . ID saveID
    (59) N -> . OPENPAR EA CLOSINGPAR
    (61) cte -> . FLOATVAL
    (62) cte -> . INTVAL
    (63) cte -> . MINUS INTVAL
    (64) cte -> . MINUS FLOATVAL

    ID              shift and go to state 38
    OPENPAR         shift and go to state 40
    FLOATVAL        shift and go to state 41
    INTVAL          shift and go to state 42
    MINUS           shift and go to state 36

    EA                             shift and go to state 106
    P                              shift and go to state 35
    N                              shift and go to state 37
    cte                            shift and go to state 39

state 75

    (44) IdLet -> ID Arr .

    EQUALS          reduce using rule 44 (IdLet -> ID Arr .)


state 76

    (22) E -> DIM setType Idv AS . T Arr
    (11) T -> . INT
    (12) T -> . FLOAT
    (13) T -> . WORD

    INT             shift and go to state 101
    FLOAT           shift and go to state 102
    WORD            shift and go to state 103

    T                              shift and go to state 107

state 77

    (23) E -> IF EL THEN first_conditional . F Esf EIF final_conditional
    (19) F -> . E F
    (20) F -> . empty
    (21) E -> . LET setType IdLet EQUALS EA
    (22) E -> . DIM setType Idv AS T Arr
    (23) E -> . IF EL THEN first_conditional F Esf EIF final_conditional
    (24) E -> . FOR ID EQUALS EA for_assignation TO EA for_conditional DO for_save_conditional F NEXT ID for_conditional_end
    (25) E -> . WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional
    (26) E -> . REPEAT while_first_conditional F UNTIL EL repeat_conditional
    (27) E -> . GOSUB ID
    (28) E -> . INPUT IDEx
    (29) E -> . PRINT EA
    (79) empty -> .

    LET             shift and go to state 10
    DIM             shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    REPEAT          shift and go to state 15
    GOSUB           shift and go to state 16
    INPUT           shift and go to state 17
    PRINT           shift and go to state 18
    ELSE            reduce using rule 79 (empty -> .)
    EIF             reduce using rule 79 (empty -> .)

    F                              shift and go to state 108
    E                              shift and go to state 8
    empty                          shift and go to state 9

state 78

    (67) EL -> OPENPAR O CLOSINGPAR .
    (68) EL -> OPENPAR O CLOSINGPAR . OL EL
    (69) OL -> . AND
    (70) OL -> . OR
    (71) OL -> . NOT

    THEN            reduce using rule 67 (EL -> OPENPAR O CLOSINGPAR .)
    DO              reduce using rule 67 (EL -> OPENPAR O CLOSINGPAR .)
    LET             reduce using rule 67 (EL -> OPENPAR O CLOSINGPAR .)
    DIM             reduce using rule 67 (EL -> OPENPAR O CLOSINGPAR .)
    IF              reduce using rule 67 (EL -> OPENPAR O CLOSINGPAR .)
    FOR             reduce using rule 67 (EL -> OPENPAR O CLOSINGPAR .)
    WHILE           reduce using rule 67 (EL -> OPENPAR O CLOSINGPAR .)
    REPEAT          reduce using rule 67 (EL -> OPENPAR O CLOSINGPAR .)
    GOSUB           reduce using rule 67 (EL -> OPENPAR O CLOSINGPAR .)
    INPUT           reduce using rule 67 (EL -> OPENPAR O CLOSINGPAR .)
    PRINT           reduce using rule 67 (EL -> OPENPAR O CLOSINGPAR .)
    SUBPROCEDURE    reduce using rule 67 (EL -> OPENPAR O CLOSINGPAR .)
    END             reduce using rule 67 (EL -> OPENPAR O CLOSINGPAR .)
    UNTIL           reduce using rule 67 (EL -> OPENPAR O CLOSINGPAR .)
    ELSE            reduce using rule 67 (EL -> OPENPAR O CLOSINGPAR .)
    EIF             reduce using rule 67 (EL -> OPENPAR O CLOSINGPAR .)
    WEND            reduce using rule 67 (EL -> OPENPAR O CLOSINGPAR .)
    RETURN          reduce using rule 67 (EL -> OPENPAR O CLOSINGPAR .)
    NEXT            reduce using rule 67 (EL -> OPENPAR O CLOSINGPAR .)
    AND             shift and go to state 110
    OR              shift and go to state 111
    NOT             shift and go to state 112

    OL                             shift and go to state 109

state 79

    (72) O -> EA GREATHER . EA
    (50) EA -> . EA PLUS P
    (51) EA -> . EA MINUS P
    (52) EA -> . P
    (53) P -> . P MULTIPLY N
    (54) P -> . P DIVIDE N
    (55) P -> . N
    (56) N -> . ID Arr saveID
    (57) N -> . cte saveID
    (58) N -> . ID saveID
    (59) N -> . OPENPAR EA CLOSINGPAR
    (61) cte -> . FLOATVAL
    (62) cte -> . INTVAL
    (63) cte -> . MINUS INTVAL
    (64) cte -> . MINUS FLOATVAL

    ID              shift and go to state 38
    OPENPAR         shift and go to state 40
    FLOATVAL        shift and go to state 41
    INTVAL          shift and go to state 42
    MINUS           shift and go to state 36

    EA                             shift and go to state 113
    P                              shift and go to state 35
    N                              shift and go to state 37
    cte                            shift and go to state 39

state 80

    (73) O -> EA GREATHEREQUAL . EA
    (50) EA -> . EA PLUS P
    (51) EA -> . EA MINUS P
    (52) EA -> . P
    (53) P -> . P MULTIPLY N
    (54) P -> . P DIVIDE N
    (55) P -> . N
    (56) N -> . ID Arr saveID
    (57) N -> . cte saveID
    (58) N -> . ID saveID
    (59) N -> . OPENPAR EA CLOSINGPAR
    (61) cte -> . FLOATVAL
    (62) cte -> . INTVAL
    (63) cte -> . MINUS INTVAL
    (64) cte -> . MINUS FLOATVAL

    ID              shift and go to state 38
    OPENPAR         shift and go to state 40
    FLOATVAL        shift and go to state 41
    INTVAL          shift and go to state 42
    MINUS           shift and go to state 36

    EA                             shift and go to state 114
    P                              shift and go to state 35
    N                              shift and go to state 37
    cte                            shift and go to state 39

state 81

    (74) O -> EA SMALLER . EA
    (50) EA -> . EA PLUS P
    (51) EA -> . EA MINUS P
    (52) EA -> . P
    (53) P -> . P MULTIPLY N
    (54) P -> . P DIVIDE N
    (55) P -> . N
    (56) N -> . ID Arr saveID
    (57) N -> . cte saveID
    (58) N -> . ID saveID
    (59) N -> . OPENPAR EA CLOSINGPAR
    (61) cte -> . FLOATVAL
    (62) cte -> . INTVAL
    (63) cte -> . MINUS INTVAL
    (64) cte -> . MINUS FLOATVAL

    ID              shift and go to state 38
    OPENPAR         shift and go to state 40
    FLOATVAL        shift and go to state 41
    INTVAL          shift and go to state 42
    MINUS           shift and go to state 36

    EA                             shift and go to state 115
    P                              shift and go to state 35
    N                              shift and go to state 37
    cte                            shift and go to state 39

state 82

    (75) O -> EA SMALLEREQUAL . EA
    (50) EA -> . EA PLUS P
    (51) EA -> . EA MINUS P
    (52) EA -> . P
    (53) P -> . P MULTIPLY N
    (54) P -> . P DIVIDE N
    (55) P -> . N
    (56) N -> . ID Arr saveID
    (57) N -> . cte saveID
    (58) N -> . ID saveID
    (59) N -> . OPENPAR EA CLOSINGPAR
    (61) cte -> . FLOATVAL
    (62) cte -> . INTVAL
    (63) cte -> . MINUS INTVAL
    (64) cte -> . MINUS FLOATVAL

    ID              shift and go to state 38
    OPENPAR         shift and go to state 40
    FLOATVAL        shift and go to state 41
    INTVAL          shift and go to state 42
    MINUS           shift and go to state 36

    EA                             shift and go to state 116
    P                              shift and go to state 35
    N                              shift and go to state 37
    cte                            shift and go to state 39

state 83

    (76) O -> EA NOTEQUAL . EA
    (50) EA -> . EA PLUS P
    (51) EA -> . EA MINUS P
    (52) EA -> . P
    (53) P -> . P MULTIPLY N
    (54) P -> . P DIVIDE N
    (55) P -> . N
    (56) N -> . ID Arr saveID
    (57) N -> . cte saveID
    (58) N -> . ID saveID
    (59) N -> . OPENPAR EA CLOSINGPAR
    (61) cte -> . FLOATVAL
    (62) cte -> . INTVAL
    (63) cte -> . MINUS INTVAL
    (64) cte -> . MINUS FLOATVAL

    ID              shift and go to state 38
    OPENPAR         shift and go to state 40
    FLOATVAL        shift and go to state 41
    INTVAL          shift and go to state 42
    MINUS           shift and go to state 36

    EA                             shift and go to state 117
    P                              shift and go to state 35
    N                              shift and go to state 37
    cte                            shift and go to state 39

state 84

    (77) O -> EA EQUALTO . EA
    (50) EA -> . EA PLUS P
    (51) EA -> . EA MINUS P
    (52) EA -> . P
    (53) P -> . P MULTIPLY N
    (54) P -> . P DIVIDE N
    (55) P -> . N
    (56) N -> . ID Arr saveID
    (57) N -> . cte saveID
    (58) N -> . ID saveID
    (59) N -> . OPENPAR EA CLOSINGPAR
    (61) cte -> . FLOATVAL
    (62) cte -> . INTVAL
    (63) cte -> . MINUS INTVAL
    (64) cte -> . MINUS FLOATVAL

    ID              shift and go to state 38
    OPENPAR         shift and go to state 40
    FLOATVAL        shift and go to state 41
    INTVAL          shift and go to state 42
    MINUS           shift and go to state 36

    EA                             shift and go to state 118
    P                              shift and go to state 35
    N                              shift and go to state 37
    cte                            shift and go to state 39

state 85

    (78) O -> EA error . EA
    (50) EA -> . EA PLUS P
    (51) EA -> . EA MINUS P
    (52) EA -> . P
    (53) P -> . P MULTIPLY N
    (54) P -> . P DIVIDE N
    (55) P -> . N
    (56) N -> . ID Arr saveID
    (57) N -> . cte saveID
    (58) N -> . ID saveID
    (59) N -> . OPENPAR EA CLOSINGPAR
    (61) cte -> . FLOATVAL
    (62) cte -> . INTVAL
    (63) cte -> . MINUS INTVAL
    (64) cte -> . MINUS FLOATVAL

    ID              shift and go to state 38
    OPENPAR         shift and go to state 40
    FLOATVAL        shift and go to state 41
    INTVAL          shift and go to state 42
    MINUS           shift and go to state 36

    EA                             shift and go to state 119
    P                              shift and go to state 35
    N                              shift and go to state 37
    cte                            shift and go to state 39

state 86

    (24) E -> FOR ID EQUALS EA . for_assignation TO EA for_conditional DO for_save_conditional F NEXT ID for_conditional_end
    (50) EA -> EA . PLUS P
    (51) EA -> EA . MINUS P
    (30) for_assignation -> .

    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    TO              reduce using rule 30 (for_assignation -> .)

    for_assignation                shift and go to state 120

state 87

    (25) E -> WHILE while_first_conditional EL DO . while_second_conditional F WEND while_final_conditional
    (36) while_second_conditional -> .

    LET             reduce using rule 36 (while_second_conditional -> .)
    DIM             reduce using rule 36 (while_second_conditional -> .)
    IF              reduce using rule 36 (while_second_conditional -> .)
    FOR             reduce using rule 36 (while_second_conditional -> .)
    WHILE           reduce using rule 36 (while_second_conditional -> .)
    REPEAT          reduce using rule 36 (while_second_conditional -> .)
    GOSUB           reduce using rule 36 (while_second_conditional -> .)
    INPUT           reduce using rule 36 (while_second_conditional -> .)
    PRINT           reduce using rule 36 (while_second_conditional -> .)
    WEND            reduce using rule 36 (while_second_conditional -> .)

    while_second_conditional       shift and go to state 121

state 88

    (26) E -> REPEAT while_first_conditional F UNTIL . EL repeat_conditional
    (65) EL -> . TRUE
    (66) EL -> . FALSE
    (67) EL -> . OPENPAR O CLOSINGPAR
    (68) EL -> . OPENPAR O CLOSINGPAR OL EL

    TRUE            shift and go to state 25
    FALSE           shift and go to state 26
    OPENPAR         shift and go to state 27

    EL                             shift and go to state 122

state 89

    (49) IDEx -> ID OPENBRACKET setType . Idv CLOSINGBRACKET
    (45) Idv -> . ID COMA Idv
    (46) Idv -> . ID

    ID              shift and go to state 44

    Idv                            shift and go to state 123

state 90

    (50) EA -> EA PLUS P .
    (53) P -> P . MULTIPLY N
    (54) P -> P . DIVIDE N

    PLUS            reduce using rule 50 (EA -> EA PLUS P .)
    MINUS           reduce using rule 50 (EA -> EA PLUS P .)
    LET             reduce using rule 50 (EA -> EA PLUS P .)
    DIM             reduce using rule 50 (EA -> EA PLUS P .)
    IF              reduce using rule 50 (EA -> EA PLUS P .)
    FOR             reduce using rule 50 (EA -> EA PLUS P .)
    WHILE           reduce using rule 50 (EA -> EA PLUS P .)
    REPEAT          reduce using rule 50 (EA -> EA PLUS P .)
    GOSUB           reduce using rule 50 (EA -> EA PLUS P .)
    INPUT           reduce using rule 50 (EA -> EA PLUS P .)
    PRINT           reduce using rule 50 (EA -> EA PLUS P .)
    SUBPROCEDURE    reduce using rule 50 (EA -> EA PLUS P .)
    END             reduce using rule 50 (EA -> EA PLUS P .)
    UNTIL           reduce using rule 50 (EA -> EA PLUS P .)
    ELSE            reduce using rule 50 (EA -> EA PLUS P .)
    EIF             reduce using rule 50 (EA -> EA PLUS P .)
    WEND            reduce using rule 50 (EA -> EA PLUS P .)
    RETURN          reduce using rule 50 (EA -> EA PLUS P .)
    NEXT            reduce using rule 50 (EA -> EA PLUS P .)
    GREATHER        reduce using rule 50 (EA -> EA PLUS P .)
    GREATHEREQUAL   reduce using rule 50 (EA -> EA PLUS P .)
    SMALLER         reduce using rule 50 (EA -> EA PLUS P .)
    SMALLEREQUAL    reduce using rule 50 (EA -> EA PLUS P .)
    NOTEQUAL        reduce using rule 50 (EA -> EA PLUS P .)
    EQUALTO         reduce using rule 50 (EA -> EA PLUS P .)
    error           reduce using rule 50 (EA -> EA PLUS P .)
    CLOSINGPAR      reduce using rule 50 (EA -> EA PLUS P .)
    TO              reduce using rule 50 (EA -> EA PLUS P .)
    DO              reduce using rule 50 (EA -> EA PLUS P .)
    MULTIPLY        shift and go to state 60
    DIVIDE          shift and go to state 61


state 91

    (51) EA -> EA MINUS P .
    (53) P -> P . MULTIPLY N
    (54) P -> P . DIVIDE N

    PLUS            reduce using rule 51 (EA -> EA MINUS P .)
    MINUS           reduce using rule 51 (EA -> EA MINUS P .)
    LET             reduce using rule 51 (EA -> EA MINUS P .)
    DIM             reduce using rule 51 (EA -> EA MINUS P .)
    IF              reduce using rule 51 (EA -> EA MINUS P .)
    FOR             reduce using rule 51 (EA -> EA MINUS P .)
    WHILE           reduce using rule 51 (EA -> EA MINUS P .)
    REPEAT          reduce using rule 51 (EA -> EA MINUS P .)
    GOSUB           reduce using rule 51 (EA -> EA MINUS P .)
    INPUT           reduce using rule 51 (EA -> EA MINUS P .)
    PRINT           reduce using rule 51 (EA -> EA MINUS P .)
    SUBPROCEDURE    reduce using rule 51 (EA -> EA MINUS P .)
    END             reduce using rule 51 (EA -> EA MINUS P .)
    UNTIL           reduce using rule 51 (EA -> EA MINUS P .)
    ELSE            reduce using rule 51 (EA -> EA MINUS P .)
    EIF             reduce using rule 51 (EA -> EA MINUS P .)
    WEND            reduce using rule 51 (EA -> EA MINUS P .)
    RETURN          reduce using rule 51 (EA -> EA MINUS P .)
    NEXT            reduce using rule 51 (EA -> EA MINUS P .)
    GREATHER        reduce using rule 51 (EA -> EA MINUS P .)
    GREATHEREQUAL   reduce using rule 51 (EA -> EA MINUS P .)
    SMALLER         reduce using rule 51 (EA -> EA MINUS P .)
    SMALLEREQUAL    reduce using rule 51 (EA -> EA MINUS P .)
    NOTEQUAL        reduce using rule 51 (EA -> EA MINUS P .)
    EQUALTO         reduce using rule 51 (EA -> EA MINUS P .)
    error           reduce using rule 51 (EA -> EA MINUS P .)
    CLOSINGPAR      reduce using rule 51 (EA -> EA MINUS P .)
    TO              reduce using rule 51 (EA -> EA MINUS P .)
    DO              reduce using rule 51 (EA -> EA MINUS P .)
    MULTIPLY        shift and go to state 60
    DIVIDE          shift and go to state 61


state 92

    (53) P -> P MULTIPLY N .

    MULTIPLY        reduce using rule 53 (P -> P MULTIPLY N .)
    DIVIDE          reduce using rule 53 (P -> P MULTIPLY N .)
    PLUS            reduce using rule 53 (P -> P MULTIPLY N .)
    MINUS           reduce using rule 53 (P -> P MULTIPLY N .)
    LET             reduce using rule 53 (P -> P MULTIPLY N .)
    DIM             reduce using rule 53 (P -> P MULTIPLY N .)
    IF              reduce using rule 53 (P -> P MULTIPLY N .)
    FOR             reduce using rule 53 (P -> P MULTIPLY N .)
    WHILE           reduce using rule 53 (P -> P MULTIPLY N .)
    REPEAT          reduce using rule 53 (P -> P MULTIPLY N .)
    GOSUB           reduce using rule 53 (P -> P MULTIPLY N .)
    INPUT           reduce using rule 53 (P -> P MULTIPLY N .)
    PRINT           reduce using rule 53 (P -> P MULTIPLY N .)
    SUBPROCEDURE    reduce using rule 53 (P -> P MULTIPLY N .)
    END             reduce using rule 53 (P -> P MULTIPLY N .)
    UNTIL           reduce using rule 53 (P -> P MULTIPLY N .)
    ELSE            reduce using rule 53 (P -> P MULTIPLY N .)
    EIF             reduce using rule 53 (P -> P MULTIPLY N .)
    WEND            reduce using rule 53 (P -> P MULTIPLY N .)
    RETURN          reduce using rule 53 (P -> P MULTIPLY N .)
    NEXT            reduce using rule 53 (P -> P MULTIPLY N .)
    GREATHER        reduce using rule 53 (P -> P MULTIPLY N .)
    GREATHEREQUAL   reduce using rule 53 (P -> P MULTIPLY N .)
    SMALLER         reduce using rule 53 (P -> P MULTIPLY N .)
    SMALLEREQUAL    reduce using rule 53 (P -> P MULTIPLY N .)
    NOTEQUAL        reduce using rule 53 (P -> P MULTIPLY N .)
    EQUALTO         reduce using rule 53 (P -> P MULTIPLY N .)
    error           reduce using rule 53 (P -> P MULTIPLY N .)
    CLOSINGPAR      reduce using rule 53 (P -> P MULTIPLY N .)
    TO              reduce using rule 53 (P -> P MULTIPLY N .)
    DO              reduce using rule 53 (P -> P MULTIPLY N .)


state 93

    (54) P -> P DIVIDE N .

    MULTIPLY        reduce using rule 54 (P -> P DIVIDE N .)
    DIVIDE          reduce using rule 54 (P -> P DIVIDE N .)
    PLUS            reduce using rule 54 (P -> P DIVIDE N .)
    MINUS           reduce using rule 54 (P -> P DIVIDE N .)
    LET             reduce using rule 54 (P -> P DIVIDE N .)
    DIM             reduce using rule 54 (P -> P DIVIDE N .)
    IF              reduce using rule 54 (P -> P DIVIDE N .)
    FOR             reduce using rule 54 (P -> P DIVIDE N .)
    WHILE           reduce using rule 54 (P -> P DIVIDE N .)
    REPEAT          reduce using rule 54 (P -> P DIVIDE N .)
    GOSUB           reduce using rule 54 (P -> P DIVIDE N .)
    INPUT           reduce using rule 54 (P -> P DIVIDE N .)
    PRINT           reduce using rule 54 (P -> P DIVIDE N .)
    SUBPROCEDURE    reduce using rule 54 (P -> P DIVIDE N .)
    END             reduce using rule 54 (P -> P DIVIDE N .)
    UNTIL           reduce using rule 54 (P -> P DIVIDE N .)
    ELSE            reduce using rule 54 (P -> P DIVIDE N .)
    EIF             reduce using rule 54 (P -> P DIVIDE N .)
    WEND            reduce using rule 54 (P -> P DIVIDE N .)
    RETURN          reduce using rule 54 (P -> P DIVIDE N .)
    NEXT            reduce using rule 54 (P -> P DIVIDE N .)
    GREATHER        reduce using rule 54 (P -> P DIVIDE N .)
    GREATHEREQUAL   reduce using rule 54 (P -> P DIVIDE N .)
    SMALLER         reduce using rule 54 (P -> P DIVIDE N .)
    SMALLEREQUAL    reduce using rule 54 (P -> P DIVIDE N .)
    NOTEQUAL        reduce using rule 54 (P -> P DIVIDE N .)
    EQUALTO         reduce using rule 54 (P -> P DIVIDE N .)
    error           reduce using rule 54 (P -> P DIVIDE N .)
    CLOSINGPAR      reduce using rule 54 (P -> P DIVIDE N .)
    TO              reduce using rule 54 (P -> P DIVIDE N .)
    DO              reduce using rule 54 (P -> P DIVIDE N .)


state 94

    (56) N -> ID Arr saveID .

    MULTIPLY        reduce using rule 56 (N -> ID Arr saveID .)
    DIVIDE          reduce using rule 56 (N -> ID Arr saveID .)
    PLUS            reduce using rule 56 (N -> ID Arr saveID .)
    MINUS           reduce using rule 56 (N -> ID Arr saveID .)
    LET             reduce using rule 56 (N -> ID Arr saveID .)
    DIM             reduce using rule 56 (N -> ID Arr saveID .)
    IF              reduce using rule 56 (N -> ID Arr saveID .)
    FOR             reduce using rule 56 (N -> ID Arr saveID .)
    WHILE           reduce using rule 56 (N -> ID Arr saveID .)
    REPEAT          reduce using rule 56 (N -> ID Arr saveID .)
    GOSUB           reduce using rule 56 (N -> ID Arr saveID .)
    INPUT           reduce using rule 56 (N -> ID Arr saveID .)
    PRINT           reduce using rule 56 (N -> ID Arr saveID .)
    SUBPROCEDURE    reduce using rule 56 (N -> ID Arr saveID .)
    END             reduce using rule 56 (N -> ID Arr saveID .)
    UNTIL           reduce using rule 56 (N -> ID Arr saveID .)
    ELSE            reduce using rule 56 (N -> ID Arr saveID .)
    EIF             reduce using rule 56 (N -> ID Arr saveID .)
    WEND            reduce using rule 56 (N -> ID Arr saveID .)
    RETURN          reduce using rule 56 (N -> ID Arr saveID .)
    NEXT            reduce using rule 56 (N -> ID Arr saveID .)
    GREATHER        reduce using rule 56 (N -> ID Arr saveID .)
    GREATHEREQUAL   reduce using rule 56 (N -> ID Arr saveID .)
    SMALLER         reduce using rule 56 (N -> ID Arr saveID .)
    SMALLEREQUAL    reduce using rule 56 (N -> ID Arr saveID .)
    NOTEQUAL        reduce using rule 56 (N -> ID Arr saveID .)
    EQUALTO         reduce using rule 56 (N -> ID Arr saveID .)
    error           reduce using rule 56 (N -> ID Arr saveID .)
    CLOSINGPAR      reduce using rule 56 (N -> ID Arr saveID .)
    TO              reduce using rule 56 (N -> ID Arr saveID .)
    DO              reduce using rule 56 (N -> ID Arr saveID .)


state 95

    (5) Arr -> OPENBRACKET arr_space . CLOSINGBRACKET

    CLOSINGBRACKET  shift and go to state 124


state 96

    (7) arr_space -> arr_index . COMA arr_space
    (8) arr_space -> arr_index .

    COMA            shift and go to state 125
    CLOSINGBRACKET  reduce using rule 8 (arr_space -> arr_index .)


state 97

    (9) arr_index -> INTVAL .

    COMA            reduce using rule 9 (arr_index -> INTVAL .)
    CLOSINGBRACKET  reduce using rule 9 (arr_index -> INTVAL .)


state 98

    (10) arr_index -> ID .

    COMA            reduce using rule 10 (arr_index -> ID .)
    CLOSINGBRACKET  reduce using rule 10 (arr_index -> ID .)


state 99

    (59) N -> OPENPAR EA CLOSINGPAR .

    MULTIPLY        reduce using rule 59 (N -> OPENPAR EA CLOSINGPAR .)
    DIVIDE          reduce using rule 59 (N -> OPENPAR EA CLOSINGPAR .)
    PLUS            reduce using rule 59 (N -> OPENPAR EA CLOSINGPAR .)
    MINUS           reduce using rule 59 (N -> OPENPAR EA CLOSINGPAR .)
    LET             reduce using rule 59 (N -> OPENPAR EA CLOSINGPAR .)
    DIM             reduce using rule 59 (N -> OPENPAR EA CLOSINGPAR .)
    IF              reduce using rule 59 (N -> OPENPAR EA CLOSINGPAR .)
    FOR             reduce using rule 59 (N -> OPENPAR EA CLOSINGPAR .)
    WHILE           reduce using rule 59 (N -> OPENPAR EA CLOSINGPAR .)
    REPEAT          reduce using rule 59 (N -> OPENPAR EA CLOSINGPAR .)
    GOSUB           reduce using rule 59 (N -> OPENPAR EA CLOSINGPAR .)
    INPUT           reduce using rule 59 (N -> OPENPAR EA CLOSINGPAR .)
    PRINT           reduce using rule 59 (N -> OPENPAR EA CLOSINGPAR .)
    SUBPROCEDURE    reduce using rule 59 (N -> OPENPAR EA CLOSINGPAR .)
    END             reduce using rule 59 (N -> OPENPAR EA CLOSINGPAR .)
    UNTIL           reduce using rule 59 (N -> OPENPAR EA CLOSINGPAR .)
    ELSE            reduce using rule 59 (N -> OPENPAR EA CLOSINGPAR .)
    EIF             reduce using rule 59 (N -> OPENPAR EA CLOSINGPAR .)
    WEND            reduce using rule 59 (N -> OPENPAR EA CLOSINGPAR .)
    RETURN          reduce using rule 59 (N -> OPENPAR EA CLOSINGPAR .)
    NEXT            reduce using rule 59 (N -> OPENPAR EA CLOSINGPAR .)
    GREATHER        reduce using rule 59 (N -> OPENPAR EA CLOSINGPAR .)
    GREATHEREQUAL   reduce using rule 59 (N -> OPENPAR EA CLOSINGPAR .)
    SMALLER         reduce using rule 59 (N -> OPENPAR EA CLOSINGPAR .)
    SMALLEREQUAL    reduce using rule 59 (N -> OPENPAR EA CLOSINGPAR .)
    NOTEQUAL        reduce using rule 59 (N -> OPENPAR EA CLOSINGPAR .)
    EQUALTO         reduce using rule 59 (N -> OPENPAR EA CLOSINGPAR .)
    error           reduce using rule 59 (N -> OPENPAR EA CLOSINGPAR .)
    CLOSINGPAR      reduce using rule 59 (N -> OPENPAR EA CLOSINGPAR .)
    TO              reduce using rule 59 (N -> OPENPAR EA CLOSINGPAR .)
    DO              reduce using rule 59 (N -> OPENPAR EA CLOSINGPAR .)


state 100

    (3) V -> DIM setType Idv AS T . Arr
    (5) Arr -> . OPENBRACKET arr_space CLOSINGBRACKET
    (6) Arr -> . empty
    (79) empty -> .

    OPENBRACKET     shift and go to state 66
    LET             reduce using rule 79 (empty -> .)
    DIM             reduce using rule 79 (empty -> .)
    IF              reduce using rule 79 (empty -> .)
    FOR             reduce using rule 79 (empty -> .)
    WHILE           reduce using rule 79 (empty -> .)
    REPEAT          reduce using rule 79 (empty -> .)
    GOSUB           reduce using rule 79 (empty -> .)
    INPUT           reduce using rule 79 (empty -> .)
    PRINT           reduce using rule 79 (empty -> .)
    SUBPROCEDURE    reduce using rule 79 (empty -> .)
    END             reduce using rule 79 (empty -> .)

    Arr                            shift and go to state 126
    empty                          shift and go to state 67

state 101

    (11) T -> INT .

    OPENBRACKET     reduce using rule 11 (T -> INT .)
    LET             reduce using rule 11 (T -> INT .)
    DIM             reduce using rule 11 (T -> INT .)
    IF              reduce using rule 11 (T -> INT .)
    FOR             reduce using rule 11 (T -> INT .)
    WHILE           reduce using rule 11 (T -> INT .)
    REPEAT          reduce using rule 11 (T -> INT .)
    GOSUB           reduce using rule 11 (T -> INT .)
    INPUT           reduce using rule 11 (T -> INT .)
    PRINT           reduce using rule 11 (T -> INT .)
    SUBPROCEDURE    reduce using rule 11 (T -> INT .)
    END             reduce using rule 11 (T -> INT .)
    UNTIL           reduce using rule 11 (T -> INT .)
    ELSE            reduce using rule 11 (T -> INT .)
    EIF             reduce using rule 11 (T -> INT .)
    WEND            reduce using rule 11 (T -> INT .)
    RETURN          reduce using rule 11 (T -> INT .)
    NEXT            reduce using rule 11 (T -> INT .)


state 102

    (12) T -> FLOAT .

    OPENBRACKET     reduce using rule 12 (T -> FLOAT .)
    LET             reduce using rule 12 (T -> FLOAT .)
    DIM             reduce using rule 12 (T -> FLOAT .)
    IF              reduce using rule 12 (T -> FLOAT .)
    FOR             reduce using rule 12 (T -> FLOAT .)
    WHILE           reduce using rule 12 (T -> FLOAT .)
    REPEAT          reduce using rule 12 (T -> FLOAT .)
    GOSUB           reduce using rule 12 (T -> FLOAT .)
    INPUT           reduce using rule 12 (T -> FLOAT .)
    PRINT           reduce using rule 12 (T -> FLOAT .)
    SUBPROCEDURE    reduce using rule 12 (T -> FLOAT .)
    END             reduce using rule 12 (T -> FLOAT .)
    UNTIL           reduce using rule 12 (T -> FLOAT .)
    ELSE            reduce using rule 12 (T -> FLOAT .)
    EIF             reduce using rule 12 (T -> FLOAT .)
    WEND            reduce using rule 12 (T -> FLOAT .)
    RETURN          reduce using rule 12 (T -> FLOAT .)
    NEXT            reduce using rule 12 (T -> FLOAT .)


state 103

    (13) T -> WORD .

    OPENBRACKET     reduce using rule 13 (T -> WORD .)
    LET             reduce using rule 13 (T -> WORD .)
    DIM             reduce using rule 13 (T -> WORD .)
    IF              reduce using rule 13 (T -> WORD .)
    FOR             reduce using rule 13 (T -> WORD .)
    WHILE           reduce using rule 13 (T -> WORD .)
    REPEAT          reduce using rule 13 (T -> WORD .)
    GOSUB           reduce using rule 13 (T -> WORD .)
    INPUT           reduce using rule 13 (T -> WORD .)
    PRINT           reduce using rule 13 (T -> WORD .)
    SUBPROCEDURE    reduce using rule 13 (T -> WORD .)
    END             reduce using rule 13 (T -> WORD .)
    UNTIL           reduce using rule 13 (T -> WORD .)
    ELSE            reduce using rule 13 (T -> WORD .)
    EIF             reduce using rule 13 (T -> WORD .)
    WEND            reduce using rule 13 (T -> WORD .)
    RETURN          reduce using rule 13 (T -> WORD .)
    NEXT            reduce using rule 13 (T -> WORD .)


state 104

    (45) Idv -> ID COMA Idv .

    AS              reduce using rule 45 (Idv -> ID COMA Idv .)
    CLOSINGBRACKET  reduce using rule 45 (Idv -> ID COMA Idv .)


state 105

    (14) S -> SUBPROCEDURE ID fillSub . TWOPOINTS M RETURN endProcedure S

    TWOPOINTS       shift and go to state 127


state 106

    (21) E -> LET setType IdLet EQUALS EA .
    (50) EA -> EA . PLUS P
    (51) EA -> EA . MINUS P

    LET             reduce using rule 21 (E -> LET setType IdLet EQUALS EA .)
    DIM             reduce using rule 21 (E -> LET setType IdLet EQUALS EA .)
    IF              reduce using rule 21 (E -> LET setType IdLet EQUALS EA .)
    FOR             reduce using rule 21 (E -> LET setType IdLet EQUALS EA .)
    WHILE           reduce using rule 21 (E -> LET setType IdLet EQUALS EA .)
    REPEAT          reduce using rule 21 (E -> LET setType IdLet EQUALS EA .)
    GOSUB           reduce using rule 21 (E -> LET setType IdLet EQUALS EA .)
    INPUT           reduce using rule 21 (E -> LET setType IdLet EQUALS EA .)
    PRINT           reduce using rule 21 (E -> LET setType IdLet EQUALS EA .)
    SUBPROCEDURE    reduce using rule 21 (E -> LET setType IdLet EQUALS EA .)
    END             reduce using rule 21 (E -> LET setType IdLet EQUALS EA .)
    UNTIL           reduce using rule 21 (E -> LET setType IdLet EQUALS EA .)
    ELSE            reduce using rule 21 (E -> LET setType IdLet EQUALS EA .)
    EIF             reduce using rule 21 (E -> LET setType IdLet EQUALS EA .)
    WEND            reduce using rule 21 (E -> LET setType IdLet EQUALS EA .)
    RETURN          reduce using rule 21 (E -> LET setType IdLet EQUALS EA .)
    NEXT            reduce using rule 21 (E -> LET setType IdLet EQUALS EA .)
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59


state 107

    (22) E -> DIM setType Idv AS T . Arr
    (5) Arr -> . OPENBRACKET arr_space CLOSINGBRACKET
    (6) Arr -> . empty
    (79) empty -> .

    OPENBRACKET     shift and go to state 66
    LET             reduce using rule 79 (empty -> .)
    DIM             reduce using rule 79 (empty -> .)
    IF              reduce using rule 79 (empty -> .)
    FOR             reduce using rule 79 (empty -> .)
    WHILE           reduce using rule 79 (empty -> .)
    REPEAT          reduce using rule 79 (empty -> .)
    GOSUB           reduce using rule 79 (empty -> .)
    INPUT           reduce using rule 79 (empty -> .)
    PRINT           reduce using rule 79 (empty -> .)
    SUBPROCEDURE    reduce using rule 79 (empty -> .)
    END             reduce using rule 79 (empty -> .)
    UNTIL           reduce using rule 79 (empty -> .)
    ELSE            reduce using rule 79 (empty -> .)
    EIF             reduce using rule 79 (empty -> .)
    WEND            reduce using rule 79 (empty -> .)
    RETURN          reduce using rule 79 (empty -> .)
    NEXT            reduce using rule 79 (empty -> .)

    Arr                            shift and go to state 128
    empty                          shift and go to state 67

state 108

    (23) E -> IF EL THEN first_conditional F . Esf EIF final_conditional
    (41) Esf -> . ELSE second_conditional F
    (42) Esf -> . empty
    (79) empty -> .

    ELSE            shift and go to state 130
    EIF             reduce using rule 79 (empty -> .)

    Esf                            shift and go to state 129
    empty                          shift and go to state 131

state 109

    (68) EL -> OPENPAR O CLOSINGPAR OL . EL
    (65) EL -> . TRUE
    (66) EL -> . FALSE
    (67) EL -> . OPENPAR O CLOSINGPAR
    (68) EL -> . OPENPAR O CLOSINGPAR OL EL

    TRUE            shift and go to state 25
    FALSE           shift and go to state 26
    OPENPAR         shift and go to state 27

    EL                             shift and go to state 132

state 110

    (69) OL -> AND .

    TRUE            reduce using rule 69 (OL -> AND .)
    FALSE           reduce using rule 69 (OL -> AND .)
    OPENPAR         reduce using rule 69 (OL -> AND .)


state 111

    (70) OL -> OR .

    TRUE            reduce using rule 70 (OL -> OR .)
    FALSE           reduce using rule 70 (OL -> OR .)
    OPENPAR         reduce using rule 70 (OL -> OR .)


state 112

    (71) OL -> NOT .

    TRUE            reduce using rule 71 (OL -> NOT .)
    FALSE           reduce using rule 71 (OL -> NOT .)
    OPENPAR         reduce using rule 71 (OL -> NOT .)


state 113

    (72) O -> EA GREATHER EA .
    (50) EA -> EA . PLUS P
    (51) EA -> EA . MINUS P

    CLOSINGPAR      reduce using rule 72 (O -> EA GREATHER EA .)
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59


state 114

    (73) O -> EA GREATHEREQUAL EA .
    (50) EA -> EA . PLUS P
    (51) EA -> EA . MINUS P

    CLOSINGPAR      reduce using rule 73 (O -> EA GREATHEREQUAL EA .)
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59


state 115

    (74) O -> EA SMALLER EA .
    (50) EA -> EA . PLUS P
    (51) EA -> EA . MINUS P

    CLOSINGPAR      reduce using rule 74 (O -> EA SMALLER EA .)
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59


state 116

    (75) O -> EA SMALLEREQUAL EA .
    (50) EA -> EA . PLUS P
    (51) EA -> EA . MINUS P

    CLOSINGPAR      reduce using rule 75 (O -> EA SMALLEREQUAL EA .)
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59


state 117

    (76) O -> EA NOTEQUAL EA .
    (50) EA -> EA . PLUS P
    (51) EA -> EA . MINUS P

    CLOSINGPAR      reduce using rule 76 (O -> EA NOTEQUAL EA .)
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59


state 118

    (77) O -> EA EQUALTO EA .
    (50) EA -> EA . PLUS P
    (51) EA -> EA . MINUS P

    CLOSINGPAR      reduce using rule 77 (O -> EA EQUALTO EA .)
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59


state 119

    (78) O -> EA error EA .
    (50) EA -> EA . PLUS P
    (51) EA -> EA . MINUS P

    CLOSINGPAR      reduce using rule 78 (O -> EA error EA .)
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59


state 120

    (24) E -> FOR ID EQUALS EA for_assignation . TO EA for_conditional DO for_save_conditional F NEXT ID for_conditional_end

    TO              shift and go to state 133


state 121

    (25) E -> WHILE while_first_conditional EL DO while_second_conditional . F WEND while_final_conditional
    (19) F -> . E F
    (20) F -> . empty
    (21) E -> . LET setType IdLet EQUALS EA
    (22) E -> . DIM setType Idv AS T Arr
    (23) E -> . IF EL THEN first_conditional F Esf EIF final_conditional
    (24) E -> . FOR ID EQUALS EA for_assignation TO EA for_conditional DO for_save_conditional F NEXT ID for_conditional_end
    (25) E -> . WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional
    (26) E -> . REPEAT while_first_conditional F UNTIL EL repeat_conditional
    (27) E -> . GOSUB ID
    (28) E -> . INPUT IDEx
    (29) E -> . PRINT EA
    (79) empty -> .

    LET             shift and go to state 10
    DIM             shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    REPEAT          shift and go to state 15
    GOSUB           shift and go to state 16
    INPUT           shift and go to state 17
    PRINT           shift and go to state 18
    WEND            reduce using rule 79 (empty -> .)

    F                              shift and go to state 134
    E                              shift and go to state 8
    empty                          shift and go to state 9

state 122

    (26) E -> REPEAT while_first_conditional F UNTIL EL . repeat_conditional
    (34) repeat_conditional -> .

    LET             reduce using rule 34 (repeat_conditional -> .)
    DIM             reduce using rule 34 (repeat_conditional -> .)
    IF              reduce using rule 34 (repeat_conditional -> .)
    FOR             reduce using rule 34 (repeat_conditional -> .)
    WHILE           reduce using rule 34 (repeat_conditional -> .)
    REPEAT          reduce using rule 34 (repeat_conditional -> .)
    GOSUB           reduce using rule 34 (repeat_conditional -> .)
    INPUT           reduce using rule 34 (repeat_conditional -> .)
    PRINT           reduce using rule 34 (repeat_conditional -> .)
    SUBPROCEDURE    reduce using rule 34 (repeat_conditional -> .)
    END             reduce using rule 34 (repeat_conditional -> .)
    UNTIL           reduce using rule 34 (repeat_conditional -> .)
    ELSE            reduce using rule 34 (repeat_conditional -> .)
    EIF             reduce using rule 34 (repeat_conditional -> .)
    WEND            reduce using rule 34 (repeat_conditional -> .)
    RETURN          reduce using rule 34 (repeat_conditional -> .)
    NEXT            reduce using rule 34 (repeat_conditional -> .)

    repeat_conditional             shift and go to state 135

state 123

    (49) IDEx -> ID OPENBRACKET setType Idv . CLOSINGBRACKET

    CLOSINGBRACKET  shift and go to state 136


state 124

    (5) Arr -> OPENBRACKET arr_space CLOSINGBRACKET .

    MULTIPLY        reduce using rule 5 (Arr -> OPENBRACKET arr_space CLOSINGBRACKET .)
    DIVIDE          reduce using rule 5 (Arr -> OPENBRACKET arr_space CLOSINGBRACKET .)
    PLUS            reduce using rule 5 (Arr -> OPENBRACKET arr_space CLOSINGBRACKET .)
    MINUS           reduce using rule 5 (Arr -> OPENBRACKET arr_space CLOSINGBRACKET .)
    LET             reduce using rule 5 (Arr -> OPENBRACKET arr_space CLOSINGBRACKET .)
    DIM             reduce using rule 5 (Arr -> OPENBRACKET arr_space CLOSINGBRACKET .)
    IF              reduce using rule 5 (Arr -> OPENBRACKET arr_space CLOSINGBRACKET .)
    FOR             reduce using rule 5 (Arr -> OPENBRACKET arr_space CLOSINGBRACKET .)
    WHILE           reduce using rule 5 (Arr -> OPENBRACKET arr_space CLOSINGBRACKET .)
    REPEAT          reduce using rule 5 (Arr -> OPENBRACKET arr_space CLOSINGBRACKET .)
    GOSUB           reduce using rule 5 (Arr -> OPENBRACKET arr_space CLOSINGBRACKET .)
    INPUT           reduce using rule 5 (Arr -> OPENBRACKET arr_space CLOSINGBRACKET .)
    PRINT           reduce using rule 5 (Arr -> OPENBRACKET arr_space CLOSINGBRACKET .)
    SUBPROCEDURE    reduce using rule 5 (Arr -> OPENBRACKET arr_space CLOSINGBRACKET .)
    END             reduce using rule 5 (Arr -> OPENBRACKET arr_space CLOSINGBRACKET .)
    UNTIL           reduce using rule 5 (Arr -> OPENBRACKET arr_space CLOSINGBRACKET .)
    ELSE            reduce using rule 5 (Arr -> OPENBRACKET arr_space CLOSINGBRACKET .)
    EIF             reduce using rule 5 (Arr -> OPENBRACKET arr_space CLOSINGBRACKET .)
    WEND            reduce using rule 5 (Arr -> OPENBRACKET arr_space CLOSINGBRACKET .)
    RETURN          reduce using rule 5 (Arr -> OPENBRACKET arr_space CLOSINGBRACKET .)
    NEXT            reduce using rule 5 (Arr -> OPENBRACKET arr_space CLOSINGBRACKET .)
    GREATHER        reduce using rule 5 (Arr -> OPENBRACKET arr_space CLOSINGBRACKET .)
    GREATHEREQUAL   reduce using rule 5 (Arr -> OPENBRACKET arr_space CLOSINGBRACKET .)
    SMALLER         reduce using rule 5 (Arr -> OPENBRACKET arr_space CLOSINGBRACKET .)
    SMALLEREQUAL    reduce using rule 5 (Arr -> OPENBRACKET arr_space CLOSINGBRACKET .)
    NOTEQUAL        reduce using rule 5 (Arr -> OPENBRACKET arr_space CLOSINGBRACKET .)
    EQUALTO         reduce using rule 5 (Arr -> OPENBRACKET arr_space CLOSINGBRACKET .)
    error           reduce using rule 5 (Arr -> OPENBRACKET arr_space CLOSINGBRACKET .)
    CLOSINGPAR      reduce using rule 5 (Arr -> OPENBRACKET arr_space CLOSINGBRACKET .)
    TO              reduce using rule 5 (Arr -> OPENBRACKET arr_space CLOSINGBRACKET .)
    DO              reduce using rule 5 (Arr -> OPENBRACKET arr_space CLOSINGBRACKET .)
    EQUALS          reduce using rule 5 (Arr -> OPENBRACKET arr_space CLOSINGBRACKET .)


state 125

    (7) arr_space -> arr_index COMA . arr_space
    (7) arr_space -> . arr_index COMA arr_space
    (8) arr_space -> . arr_index
    (9) arr_index -> . INTVAL
    (10) arr_index -> . ID

    INTVAL          shift and go to state 97
    ID              shift and go to state 98

    arr_index                      shift and go to state 96
    arr_space                      shift and go to state 137

state 126

    (3) V -> DIM setType Idv AS T Arr .

    LET             reduce using rule 3 (V -> DIM setType Idv AS T Arr .)
    DIM             reduce using rule 3 (V -> DIM setType Idv AS T Arr .)
    IF              reduce using rule 3 (V -> DIM setType Idv AS T Arr .)
    FOR             reduce using rule 3 (V -> DIM setType Idv AS T Arr .)
    WHILE           reduce using rule 3 (V -> DIM setType Idv AS T Arr .)
    REPEAT          reduce using rule 3 (V -> DIM setType Idv AS T Arr .)
    GOSUB           reduce using rule 3 (V -> DIM setType Idv AS T Arr .)
    INPUT           reduce using rule 3 (V -> DIM setType Idv AS T Arr .)
    PRINT           reduce using rule 3 (V -> DIM setType Idv AS T Arr .)
    SUBPROCEDURE    reduce using rule 3 (V -> DIM setType Idv AS T Arr .)
    END             reduce using rule 3 (V -> DIM setType Idv AS T Arr .)


state 127

    (14) S -> SUBPROCEDURE ID fillSub TWOPOINTS . M RETURN endProcedure S
    (18) M -> . F
    (19) F -> . E F
    (20) F -> . empty
    (21) E -> . LET setType IdLet EQUALS EA
    (22) E -> . DIM setType Idv AS T Arr
    (23) E -> . IF EL THEN first_conditional F Esf EIF final_conditional
    (24) E -> . FOR ID EQUALS EA for_assignation TO EA for_conditional DO for_save_conditional F NEXT ID for_conditional_end
    (25) E -> . WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional
    (26) E -> . REPEAT while_first_conditional F UNTIL EL repeat_conditional
    (27) E -> . GOSUB ID
    (28) E -> . INPUT IDEx
    (29) E -> . PRINT EA
    (79) empty -> .

    LET             shift and go to state 10
    DIM             shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    REPEAT          shift and go to state 15
    GOSUB           shift and go to state 16
    INPUT           shift and go to state 17
    PRINT           shift and go to state 18
    RETURN          reduce using rule 79 (empty -> .)

    M                              shift and go to state 138
    F                              shift and go to state 7
    E                              shift and go to state 8
    empty                          shift and go to state 9

state 128

    (22) E -> DIM setType Idv AS T Arr .

    LET             reduce using rule 22 (E -> DIM setType Idv AS T Arr .)
    DIM             reduce using rule 22 (E -> DIM setType Idv AS T Arr .)
    IF              reduce using rule 22 (E -> DIM setType Idv AS T Arr .)
    FOR             reduce using rule 22 (E -> DIM setType Idv AS T Arr .)
    WHILE           reduce using rule 22 (E -> DIM setType Idv AS T Arr .)
    REPEAT          reduce using rule 22 (E -> DIM setType Idv AS T Arr .)
    GOSUB           reduce using rule 22 (E -> DIM setType Idv AS T Arr .)
    INPUT           reduce using rule 22 (E -> DIM setType Idv AS T Arr .)
    PRINT           reduce using rule 22 (E -> DIM setType Idv AS T Arr .)
    SUBPROCEDURE    reduce using rule 22 (E -> DIM setType Idv AS T Arr .)
    END             reduce using rule 22 (E -> DIM setType Idv AS T Arr .)
    UNTIL           reduce using rule 22 (E -> DIM setType Idv AS T Arr .)
    ELSE            reduce using rule 22 (E -> DIM setType Idv AS T Arr .)
    EIF             reduce using rule 22 (E -> DIM setType Idv AS T Arr .)
    WEND            reduce using rule 22 (E -> DIM setType Idv AS T Arr .)
    RETURN          reduce using rule 22 (E -> DIM setType Idv AS T Arr .)
    NEXT            reduce using rule 22 (E -> DIM setType Idv AS T Arr .)


state 129

    (23) E -> IF EL THEN first_conditional F Esf . EIF final_conditional

    EIF             shift and go to state 139


state 130

    (41) Esf -> ELSE . second_conditional F
    (39) second_conditional -> .

    LET             reduce using rule 39 (second_conditional -> .)
    DIM             reduce using rule 39 (second_conditional -> .)
    IF              reduce using rule 39 (second_conditional -> .)
    FOR             reduce using rule 39 (second_conditional -> .)
    WHILE           reduce using rule 39 (second_conditional -> .)
    REPEAT          reduce using rule 39 (second_conditional -> .)
    GOSUB           reduce using rule 39 (second_conditional -> .)
    INPUT           reduce using rule 39 (second_conditional -> .)
    PRINT           reduce using rule 39 (second_conditional -> .)
    EIF             reduce using rule 39 (second_conditional -> .)

    second_conditional             shift and go to state 140

state 131

    (42) Esf -> empty .

    EIF             reduce using rule 42 (Esf -> empty .)


state 132

    (68) EL -> OPENPAR O CLOSINGPAR OL EL .

    THEN            reduce using rule 68 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    DO              reduce using rule 68 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    LET             reduce using rule 68 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    DIM             reduce using rule 68 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    IF              reduce using rule 68 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    FOR             reduce using rule 68 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    WHILE           reduce using rule 68 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    REPEAT          reduce using rule 68 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    GOSUB           reduce using rule 68 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    INPUT           reduce using rule 68 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    PRINT           reduce using rule 68 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    SUBPROCEDURE    reduce using rule 68 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    END             reduce using rule 68 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    UNTIL           reduce using rule 68 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    ELSE            reduce using rule 68 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    EIF             reduce using rule 68 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    WEND            reduce using rule 68 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    RETURN          reduce using rule 68 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    NEXT            reduce using rule 68 (EL -> OPENPAR O CLOSINGPAR OL EL .)


state 133

    (24) E -> FOR ID EQUALS EA for_assignation TO . EA for_conditional DO for_save_conditional F NEXT ID for_conditional_end
    (50) EA -> . EA PLUS P
    (51) EA -> . EA MINUS P
    (52) EA -> . P
    (53) P -> . P MULTIPLY N
    (54) P -> . P DIVIDE N
    (55) P -> . N
    (56) N -> . ID Arr saveID
    (57) N -> . cte saveID
    (58) N -> . ID saveID
    (59) N -> . OPENPAR EA CLOSINGPAR
    (61) cte -> . FLOATVAL
    (62) cte -> . INTVAL
    (63) cte -> . MINUS INTVAL
    (64) cte -> . MINUS FLOATVAL

    ID              shift and go to state 38
    OPENPAR         shift and go to state 40
    FLOATVAL        shift and go to state 41
    INTVAL          shift and go to state 42
    MINUS           shift and go to state 36

    EA                             shift and go to state 141
    P                              shift and go to state 35
    N                              shift and go to state 37
    cte                            shift and go to state 39

state 134

    (25) E -> WHILE while_first_conditional EL DO while_second_conditional F . WEND while_final_conditional

    WEND            shift and go to state 142


state 135

    (26) E -> REPEAT while_first_conditional F UNTIL EL repeat_conditional .

    LET             reduce using rule 26 (E -> REPEAT while_first_conditional F UNTIL EL repeat_conditional .)
    DIM             reduce using rule 26 (E -> REPEAT while_first_conditional F UNTIL EL repeat_conditional .)
    IF              reduce using rule 26 (E -> REPEAT while_first_conditional F UNTIL EL repeat_conditional .)
    FOR             reduce using rule 26 (E -> REPEAT while_first_conditional F UNTIL EL repeat_conditional .)
    WHILE           reduce using rule 26 (E -> REPEAT while_first_conditional F UNTIL EL repeat_conditional .)
    REPEAT          reduce using rule 26 (E -> REPEAT while_first_conditional F UNTIL EL repeat_conditional .)
    GOSUB           reduce using rule 26 (E -> REPEAT while_first_conditional F UNTIL EL repeat_conditional .)
    INPUT           reduce using rule 26 (E -> REPEAT while_first_conditional F UNTIL EL repeat_conditional .)
    PRINT           reduce using rule 26 (E -> REPEAT while_first_conditional F UNTIL EL repeat_conditional .)
    SUBPROCEDURE    reduce using rule 26 (E -> REPEAT while_first_conditional F UNTIL EL repeat_conditional .)
    END             reduce using rule 26 (E -> REPEAT while_first_conditional F UNTIL EL repeat_conditional .)
    UNTIL           reduce using rule 26 (E -> REPEAT while_first_conditional F UNTIL EL repeat_conditional .)
    ELSE            reduce using rule 26 (E -> REPEAT while_first_conditional F UNTIL EL repeat_conditional .)
    EIF             reduce using rule 26 (E -> REPEAT while_first_conditional F UNTIL EL repeat_conditional .)
    WEND            reduce using rule 26 (E -> REPEAT while_first_conditional F UNTIL EL repeat_conditional .)
    RETURN          reduce using rule 26 (E -> REPEAT while_first_conditional F UNTIL EL repeat_conditional .)
    NEXT            reduce using rule 26 (E -> REPEAT while_first_conditional F UNTIL EL repeat_conditional .)


state 136

    (49) IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .

    LET             reduce using rule 49 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    DIM             reduce using rule 49 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    IF              reduce using rule 49 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    FOR             reduce using rule 49 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    WHILE           reduce using rule 49 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    REPEAT          reduce using rule 49 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    GOSUB           reduce using rule 49 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    INPUT           reduce using rule 49 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    PRINT           reduce using rule 49 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    SUBPROCEDURE    reduce using rule 49 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    END             reduce using rule 49 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    UNTIL           reduce using rule 49 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    ELSE            reduce using rule 49 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    EIF             reduce using rule 49 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    WEND            reduce using rule 49 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    RETURN          reduce using rule 49 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    NEXT            reduce using rule 49 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)


state 137

    (7) arr_space -> arr_index COMA arr_space .

    CLOSINGBRACKET  reduce using rule 7 (arr_space -> arr_index COMA arr_space .)


state 138

    (14) S -> SUBPROCEDURE ID fillSub TWOPOINTS M . RETURN endProcedure S

    RETURN          shift and go to state 143


state 139

    (23) E -> IF EL THEN first_conditional F Esf EIF . final_conditional
    (40) final_conditional -> .

    LET             reduce using rule 40 (final_conditional -> .)
    DIM             reduce using rule 40 (final_conditional -> .)
    IF              reduce using rule 40 (final_conditional -> .)
    FOR             reduce using rule 40 (final_conditional -> .)
    WHILE           reduce using rule 40 (final_conditional -> .)
    REPEAT          reduce using rule 40 (final_conditional -> .)
    GOSUB           reduce using rule 40 (final_conditional -> .)
    INPUT           reduce using rule 40 (final_conditional -> .)
    PRINT           reduce using rule 40 (final_conditional -> .)
    SUBPROCEDURE    reduce using rule 40 (final_conditional -> .)
    END             reduce using rule 40 (final_conditional -> .)
    UNTIL           reduce using rule 40 (final_conditional -> .)
    ELSE            reduce using rule 40 (final_conditional -> .)
    EIF             reduce using rule 40 (final_conditional -> .)
    WEND            reduce using rule 40 (final_conditional -> .)
    RETURN          reduce using rule 40 (final_conditional -> .)
    NEXT            reduce using rule 40 (final_conditional -> .)

    final_conditional              shift and go to state 144

state 140

    (41) Esf -> ELSE second_conditional . F
    (19) F -> . E F
    (20) F -> . empty
    (21) E -> . LET setType IdLet EQUALS EA
    (22) E -> . DIM setType Idv AS T Arr
    (23) E -> . IF EL THEN first_conditional F Esf EIF final_conditional
    (24) E -> . FOR ID EQUALS EA for_assignation TO EA for_conditional DO for_save_conditional F NEXT ID for_conditional_end
    (25) E -> . WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional
    (26) E -> . REPEAT while_first_conditional F UNTIL EL repeat_conditional
    (27) E -> . GOSUB ID
    (28) E -> . INPUT IDEx
    (29) E -> . PRINT EA
    (79) empty -> .

    LET             shift and go to state 10
    DIM             shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    REPEAT          shift and go to state 15
    GOSUB           shift and go to state 16
    INPUT           shift and go to state 17
    PRINT           shift and go to state 18
    EIF             reduce using rule 79 (empty -> .)

    F                              shift and go to state 145
    E                              shift and go to state 8
    empty                          shift and go to state 9

state 141

    (24) E -> FOR ID EQUALS EA for_assignation TO EA . for_conditional DO for_save_conditional F NEXT ID for_conditional_end
    (50) EA -> EA . PLUS P
    (51) EA -> EA . MINUS P
    (31) for_conditional -> .

    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    DO              reduce using rule 31 (for_conditional -> .)

    for_conditional                shift and go to state 146

state 142

    (25) E -> WHILE while_first_conditional EL DO while_second_conditional F WEND . while_final_conditional
    (37) while_final_conditional -> .

    LET             reduce using rule 37 (while_final_conditional -> .)
    DIM             reduce using rule 37 (while_final_conditional -> .)
    IF              reduce using rule 37 (while_final_conditional -> .)
    FOR             reduce using rule 37 (while_final_conditional -> .)
    WHILE           reduce using rule 37 (while_final_conditional -> .)
    REPEAT          reduce using rule 37 (while_final_conditional -> .)
    GOSUB           reduce using rule 37 (while_final_conditional -> .)
    INPUT           reduce using rule 37 (while_final_conditional -> .)
    PRINT           reduce using rule 37 (while_final_conditional -> .)
    SUBPROCEDURE    reduce using rule 37 (while_final_conditional -> .)
    END             reduce using rule 37 (while_final_conditional -> .)
    UNTIL           reduce using rule 37 (while_final_conditional -> .)
    ELSE            reduce using rule 37 (while_final_conditional -> .)
    EIF             reduce using rule 37 (while_final_conditional -> .)
    WEND            reduce using rule 37 (while_final_conditional -> .)
    RETURN          reduce using rule 37 (while_final_conditional -> .)
    NEXT            reduce using rule 37 (while_final_conditional -> .)

    while_final_conditional        shift and go to state 147

state 143

    (14) S -> SUBPROCEDURE ID fillSub TWOPOINTS M RETURN . endProcedure S
    (17) endProcedure -> .

    SUBPROCEDURE    reduce using rule 17 (endProcedure -> .)
    END             reduce using rule 17 (endProcedure -> .)

    endProcedure                   shift and go to state 148

state 144

    (23) E -> IF EL THEN first_conditional F Esf EIF final_conditional .

    LET             reduce using rule 23 (E -> IF EL THEN first_conditional F Esf EIF final_conditional .)
    DIM             reduce using rule 23 (E -> IF EL THEN first_conditional F Esf EIF final_conditional .)
    IF              reduce using rule 23 (E -> IF EL THEN first_conditional F Esf EIF final_conditional .)
    FOR             reduce using rule 23 (E -> IF EL THEN first_conditional F Esf EIF final_conditional .)
    WHILE           reduce using rule 23 (E -> IF EL THEN first_conditional F Esf EIF final_conditional .)
    REPEAT          reduce using rule 23 (E -> IF EL THEN first_conditional F Esf EIF final_conditional .)
    GOSUB           reduce using rule 23 (E -> IF EL THEN first_conditional F Esf EIF final_conditional .)
    INPUT           reduce using rule 23 (E -> IF EL THEN first_conditional F Esf EIF final_conditional .)
    PRINT           reduce using rule 23 (E -> IF EL THEN first_conditional F Esf EIF final_conditional .)
    SUBPROCEDURE    reduce using rule 23 (E -> IF EL THEN first_conditional F Esf EIF final_conditional .)
    END             reduce using rule 23 (E -> IF EL THEN first_conditional F Esf EIF final_conditional .)
    UNTIL           reduce using rule 23 (E -> IF EL THEN first_conditional F Esf EIF final_conditional .)
    ELSE            reduce using rule 23 (E -> IF EL THEN first_conditional F Esf EIF final_conditional .)
    EIF             reduce using rule 23 (E -> IF EL THEN first_conditional F Esf EIF final_conditional .)
    WEND            reduce using rule 23 (E -> IF EL THEN first_conditional F Esf EIF final_conditional .)
    RETURN          reduce using rule 23 (E -> IF EL THEN first_conditional F Esf EIF final_conditional .)
    NEXT            reduce using rule 23 (E -> IF EL THEN first_conditional F Esf EIF final_conditional .)


state 145

    (41) Esf -> ELSE second_conditional F .

    EIF             reduce using rule 41 (Esf -> ELSE second_conditional F .)


state 146

    (24) E -> FOR ID EQUALS EA for_assignation TO EA for_conditional . DO for_save_conditional F NEXT ID for_conditional_end

    DO              shift and go to state 149


state 147

    (25) E -> WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional .

    LET             reduce using rule 25 (E -> WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional .)
    DIM             reduce using rule 25 (E -> WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional .)
    IF              reduce using rule 25 (E -> WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional .)
    FOR             reduce using rule 25 (E -> WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional .)
    WHILE           reduce using rule 25 (E -> WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional .)
    REPEAT          reduce using rule 25 (E -> WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional .)
    GOSUB           reduce using rule 25 (E -> WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional .)
    INPUT           reduce using rule 25 (E -> WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional .)
    PRINT           reduce using rule 25 (E -> WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional .)
    SUBPROCEDURE    reduce using rule 25 (E -> WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional .)
    END             reduce using rule 25 (E -> WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional .)
    UNTIL           reduce using rule 25 (E -> WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional .)
    ELSE            reduce using rule 25 (E -> WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional .)
    EIF             reduce using rule 25 (E -> WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional .)
    WEND            reduce using rule 25 (E -> WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional .)
    RETURN          reduce using rule 25 (E -> WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional .)
    NEXT            reduce using rule 25 (E -> WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional .)


state 148

    (14) S -> SUBPROCEDURE ID fillSub TWOPOINTS M RETURN endProcedure . S
    (14) S -> . SUBPROCEDURE ID fillSub TWOPOINTS M RETURN endProcedure S
    (15) S -> . empty
    (79) empty -> .

    SUBPROCEDURE    shift and go to state 46
    END             reduce using rule 79 (empty -> .)

    S                              shift and go to state 150
    empty                          shift and go to state 47

state 149

    (24) E -> FOR ID EQUALS EA for_assignation TO EA for_conditional DO . for_save_conditional F NEXT ID for_conditional_end
    (32) for_save_conditional -> .

    LET             reduce using rule 32 (for_save_conditional -> .)
    DIM             reduce using rule 32 (for_save_conditional -> .)
    IF              reduce using rule 32 (for_save_conditional -> .)
    FOR             reduce using rule 32 (for_save_conditional -> .)
    WHILE           reduce using rule 32 (for_save_conditional -> .)
    REPEAT          reduce using rule 32 (for_save_conditional -> .)
    GOSUB           reduce using rule 32 (for_save_conditional -> .)
    INPUT           reduce using rule 32 (for_save_conditional -> .)
    PRINT           reduce using rule 32 (for_save_conditional -> .)
    NEXT            reduce using rule 32 (for_save_conditional -> .)

    for_save_conditional           shift and go to state 151

state 150

    (14) S -> SUBPROCEDURE ID fillSub TWOPOINTS M RETURN endProcedure S .

    END             reduce using rule 14 (S -> SUBPROCEDURE ID fillSub TWOPOINTS M RETURN endProcedure S .)


state 151

    (24) E -> FOR ID EQUALS EA for_assignation TO EA for_conditional DO for_save_conditional . F NEXT ID for_conditional_end
    (19) F -> . E F
    (20) F -> . empty
    (21) E -> . LET setType IdLet EQUALS EA
    (22) E -> . DIM setType Idv AS T Arr
    (23) E -> . IF EL THEN first_conditional F Esf EIF final_conditional
    (24) E -> . FOR ID EQUALS EA for_assignation TO EA for_conditional DO for_save_conditional F NEXT ID for_conditional_end
    (25) E -> . WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional
    (26) E -> . REPEAT while_first_conditional F UNTIL EL repeat_conditional
    (27) E -> . GOSUB ID
    (28) E -> . INPUT IDEx
    (29) E -> . PRINT EA
    (79) empty -> .

    LET             shift and go to state 10
    DIM             shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    REPEAT          shift and go to state 15
    GOSUB           shift and go to state 16
    INPUT           shift and go to state 17
    PRINT           shift and go to state 18
    NEXT            reduce using rule 79 (empty -> .)

    F                              shift and go to state 152
    E                              shift and go to state 8
    empty                          shift and go to state 9

state 152

    (24) E -> FOR ID EQUALS EA for_assignation TO EA for_conditional DO for_save_conditional F . NEXT ID for_conditional_end

    NEXT            shift and go to state 153


state 153

    (24) E -> FOR ID EQUALS EA for_assignation TO EA for_conditional DO for_save_conditional F NEXT . ID for_conditional_end

    ID              shift and go to state 154


state 154

    (24) E -> FOR ID EQUALS EA for_assignation TO EA for_conditional DO for_save_conditional F NEXT ID . for_conditional_end
    (33) for_conditional_end -> .

    LET             reduce using rule 33 (for_conditional_end -> .)
    DIM             reduce using rule 33 (for_conditional_end -> .)
    IF              reduce using rule 33 (for_conditional_end -> .)
    FOR             reduce using rule 33 (for_conditional_end -> .)
    WHILE           reduce using rule 33 (for_conditional_end -> .)
    REPEAT          reduce using rule 33 (for_conditional_end -> .)
    GOSUB           reduce using rule 33 (for_conditional_end -> .)
    INPUT           reduce using rule 33 (for_conditional_end -> .)
    PRINT           reduce using rule 33 (for_conditional_end -> .)
    SUBPROCEDURE    reduce using rule 33 (for_conditional_end -> .)
    END             reduce using rule 33 (for_conditional_end -> .)
    UNTIL           reduce using rule 33 (for_conditional_end -> .)
    ELSE            reduce using rule 33 (for_conditional_end -> .)
    EIF             reduce using rule 33 (for_conditional_end -> .)
    WEND            reduce using rule 33 (for_conditional_end -> .)
    RETURN          reduce using rule 33 (for_conditional_end -> .)
    NEXT            reduce using rule 33 (for_conditional_end -> .)

    for_conditional_end            shift and go to state 155

state 155

    (24) E -> FOR ID EQUALS EA for_assignation TO EA for_conditional DO for_save_conditional F NEXT ID for_conditional_end .

    LET             reduce using rule 24 (E -> FOR ID EQUALS EA for_assignation TO EA for_conditional DO for_save_conditional F NEXT ID for_conditional_end .)
    DIM             reduce using rule 24 (E -> FOR ID EQUALS EA for_assignation TO EA for_conditional DO for_save_conditional F NEXT ID for_conditional_end .)
    IF              reduce using rule 24 (E -> FOR ID EQUALS EA for_assignation TO EA for_conditional DO for_save_conditional F NEXT ID for_conditional_end .)
    FOR             reduce using rule 24 (E -> FOR ID EQUALS EA for_assignation TO EA for_conditional DO for_save_conditional F NEXT ID for_conditional_end .)
    WHILE           reduce using rule 24 (E -> FOR ID EQUALS EA for_assignation TO EA for_conditional DO for_save_conditional F NEXT ID for_conditional_end .)
    REPEAT          reduce using rule 24 (E -> FOR ID EQUALS EA for_assignation TO EA for_conditional DO for_save_conditional F NEXT ID for_conditional_end .)
    GOSUB           reduce using rule 24 (E -> FOR ID EQUALS EA for_assignation TO EA for_conditional DO for_save_conditional F NEXT ID for_conditional_end .)
    INPUT           reduce using rule 24 (E -> FOR ID EQUALS EA for_assignation TO EA for_conditional DO for_save_conditional F NEXT ID for_conditional_end .)
    PRINT           reduce using rule 24 (E -> FOR ID EQUALS EA for_assignation TO EA for_conditional DO for_save_conditional F NEXT ID for_conditional_end .)
    SUBPROCEDURE    reduce using rule 24 (E -> FOR ID EQUALS EA for_assignation TO EA for_conditional DO for_save_conditional F NEXT ID for_conditional_end .)
    END             reduce using rule 24 (E -> FOR ID EQUALS EA for_assignation TO EA for_conditional DO for_save_conditional F NEXT ID for_conditional_end .)
    UNTIL           reduce using rule 24 (E -> FOR ID EQUALS EA for_assignation TO EA for_conditional DO for_save_conditional F NEXT ID for_conditional_end .)
    ELSE            reduce using rule 24 (E -> FOR ID EQUALS EA for_assignation TO EA for_conditional DO for_save_conditional F NEXT ID for_conditional_end .)
    EIF             reduce using rule 24 (E -> FOR ID EQUALS EA for_assignation TO EA for_conditional DO for_save_conditional F NEXT ID for_conditional_end .)
    WEND            reduce using rule 24 (E -> FOR ID EQUALS EA for_assignation TO EA for_conditional DO for_save_conditional F NEXT ID for_conditional_end .)
    RETURN          reduce using rule 24 (E -> FOR ID EQUALS EA for_assignation TO EA for_conditional DO for_save_conditional F NEXT ID for_conditional_end .)
    NEXT            reduce using rule 24 (E -> FOR ID EQUALS EA for_assignation TO EA for_conditional DO for_save_conditional F NEXT ID for_conditional_end .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for DIM in state 2 resolved as shift
WARNING: reduce/reduce conflict in state 38 resolved using rule (saveID -> <empty>)
WARNING: rejected rule (empty -> <empty>) in state 38
WARNING: reduce/reduce conflict in state 49 resolved using rule (IdLet -> ID)
WARNING: rejected rule (empty -> <empty>) in state 49
