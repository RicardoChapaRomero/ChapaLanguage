Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT

Grammar

Rule 0     S' -> PROGRAMA
Rule 1     PROGRAMA -> PROGRAM V M S END
Rule 2     V -> DIM setType Idv AS T Arr
Rule 3     V -> empty
Rule 4     Arr -> OPENBRACKET EA CLOSINGBRACKET Arr
Rule 5     Arr -> OPENBRACKET ID CLOSINGBRACKET Arr
Rule 6     Arr -> empty
Rule 7     T -> INT
Rule 8     T -> FLOAT
Rule 9     T -> WORD
Rule 10    S -> SUBPROCEDURE ID TWOPOINTS M RETURN S
Rule 11    S -> empty
Rule 12    M -> F M
Rule 13    M -> empty
Rule 14    F -> E F
Rule 15    F -> empty
Rule 16    E -> LET setType Idv EQUALS Ex
Rule 17    E -> DIM setType Idv AS T Arr
Rule 18    E -> IF EL THEN first_conditional F Esf EIF final_conditional
Rule 19    E -> FOR ID EQUALS EA for_assignation TO Ex for_conditional DO for_save_conditional F NEXT ID for_conditional_end
Rule 20    E -> WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional
Rule 21    E -> REPEAT while_first_conditional F UNTIL EL repeat_conditional
Rule 22    E -> GOSUB ID
Rule 23    E -> INPUT ES COMA IDEx
Rule 24    E -> PRINT Ex
Rule 25    for_assignation -> <empty>
Rule 26    for_conditional -> <empty>
Rule 27    for_save_conditional -> <empty>
Rule 28    for_conditional_end -> <empty>
Rule 29    repeat_conditional -> <empty>
Rule 30    while_first_conditional -> <empty>
Rule 31    while_second_conditional -> <empty>
Rule 32    while_final_conditional -> <empty>
Rule 33    first_conditional -> <empty>
Rule 34    second_conditional -> <empty>
Rule 35    final_conditional -> <empty>
Rule 36    Esf -> ELSE second_conditional F
Rule 37    Esf -> empty
Rule 38    Idv -> ID COMA Idv
Rule 39    Idv -> ID
Rule 40    setType -> <empty>
Rule 41    IDEx -> ID
Rule 42    IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET
Rule 43    Ex -> EA
Rule 44    Ex -> ES
Rule 45    Ex -> EL
Rule 46    Ex -> ID
Rule 47    ES -> WORDVAL
Rule 48    EA -> EA PLUS P
Rule 49    EA -> EA MINUS P
Rule 50    EA -> P
Rule 51    P -> P MULTIPLY N
Rule 52    P -> P DIVIDE N
Rule 53    P -> N
Rule 54    N -> cte saveID
Rule 55    N -> ID saveID
Rule 56    N -> OPENPAR EA CLOSINGPAR
Rule 57    N -> ID OPENBRACKET INTVAL CLOSINGBRACKET
Rule 58    N -> ID OPENBRACKET setType Idv CLOSINGBRACKET
Rule 59    saveID -> <empty>
Rule 60    cte -> INTVAL
Rule 61    cte -> FLOATVAL
Rule 62    EL -> TRUE
Rule 63    EL -> FALSE
Rule 64    EL -> OPENPAR O CLOSINGPAR
Rule 65    EL -> OPENPAR O CLOSINGPAR OL EL
Rule 66    OL -> AND
Rule 67    OL -> OR
Rule 68    OL -> NOT
Rule 69    O -> Ex GREATHER Ex
Rule 70    O -> Ex GREATHEREQUAL Ex
Rule 71    O -> Ex SMALLER Ex
Rule 72    O -> Ex SMALLEREQUAL Ex
Rule 73    O -> Ex NOTEQUAL Ex
Rule 74    O -> Ex EQUALTO Ex
Rule 75    O -> Ex error Ex
Rule 76    empty -> <empty>

Terminals, with rules where they appear

AND                  : 66
AS                   : 2 17
CLOSINGBRACKET       : 4 5 42 57 58
CLOSINGPAR           : 56 64 65
COMA                 : 23 38
COMMENT              : 
DIM                  : 2 17
DIVIDE               : 52
DO                   : 19 20
EIF                  : 18
ELSE                 : 36
END                  : 1
EQUALS               : 16 19
EQUALTO              : 74
FALSE                : 63
FLOAT                : 8
FLOATVAL             : 61
FOR                  : 19
GOSUB                : 22
GREATHER             : 69
GREATHEREQUAL        : 70
ID                   : 5 10 19 19 22 38 39 41 42 46 55 57 58
IF                   : 18
INPUT                : 23
INT                  : 7
INTVAL               : 57 60
LET                  : 16
MINUS                : 49
MULTIPLY             : 51
NEXT                 : 19
NOT                  : 68
NOTEQUAL             : 73
OPENBRACKET          : 4 5 42 57 58
OPENPAR              : 56 64 65
OR                   : 67
PLUS                 : 48
PRINT                : 24
PROGRAM              : 1
REPEAT               : 21
RETURN               : 10
SMALLER              : 71
SMALLEREQUAL         : 72
SUBPROCEDURE         : 10
THEN                 : 18
TO                   : 19
TRUE                 : 62
TWOPOINTS            : 10
UNTIL                : 21
WEND                 : 20
WHILE                : 20
WORD                 : 9
WORDVAL              : 47
error                : 75

Nonterminals, with rules where they appear

Arr                  : 2 4 5 17
E                    : 14
EA                   : 4 19 43 48 49 56
EL                   : 18 20 21 45 65
ES                   : 23 44
Esf                  : 18
Ex                   : 16 19 24 69 69 70 70 71 71 72 72 73 73 74 74 75 75
F                    : 12 14 18 19 20 21 36
IDEx                 : 23
Idv                  : 2 16 17 38 42 58
M                    : 1 10 12
N                    : 51 52 53
O                    : 64 65
OL                   : 65
P                    : 48 49 50 51 52
PROGRAMA             : 0
S                    : 1 10
T                    : 2 17
V                    : 1
cte                  : 54
empty                : 3 6 11 13 15 37
final_conditional    : 18
first_conditional    : 18
for_assignation      : 19
for_conditional      : 19
for_conditional_end  : 19
for_save_conditional : 19
repeat_conditional   : 21
saveID               : 54 55
second_conditional   : 36
setType              : 2 16 17 42 58
while_final_conditional : 20
while_first_conditional : 20 21
while_second_conditional : 20

Parsing method: LALR

state 0

    (0) S' -> . PROGRAMA
    (1) PROGRAMA -> . PROGRAM V M S END

    PROGRAM         shift and go to state 2

    PROGRAMA                       shift and go to state 1

state 1

    (0) S' -> PROGRAMA .



state 2

    (1) PROGRAMA -> PROGRAM . V M S END
    (2) V -> . DIM setType Idv AS T Arr
    (3) V -> . empty
    (76) empty -> .

  ! shift/reduce conflict for DIM resolved as shift
    DIM             shift and go to state 4
    LET             reduce using rule 76 (empty -> .)
    IF              reduce using rule 76 (empty -> .)
    FOR             reduce using rule 76 (empty -> .)
    WHILE           reduce using rule 76 (empty -> .)
    REPEAT          reduce using rule 76 (empty -> .)
    GOSUB           reduce using rule 76 (empty -> .)
    INPUT           reduce using rule 76 (empty -> .)
    PRINT           reduce using rule 76 (empty -> .)
    SUBPROCEDURE    reduce using rule 76 (empty -> .)
    END             reduce using rule 76 (empty -> .)

  ! DIM             [ reduce using rule 76 (empty -> .) ]

    V                              shift and go to state 3
    empty                          shift and go to state 5

state 3

    (1) PROGRAMA -> PROGRAM V . M S END
    (12) M -> . F M
    (13) M -> . empty
    (14) F -> . E F
    (15) F -> . empty
    (76) empty -> .
    (16) E -> . LET setType Idv EQUALS Ex
    (17) E -> . DIM setType Idv AS T Arr
    (18) E -> . IF EL THEN first_conditional F Esf EIF final_conditional
    (19) E -> . FOR ID EQUALS EA for_assignation TO Ex for_conditional DO for_save_conditional F NEXT ID for_conditional_end
    (20) E -> . WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional
    (21) E -> . REPEAT while_first_conditional F UNTIL EL repeat_conditional
    (22) E -> . GOSUB ID
    (23) E -> . INPUT ES COMA IDEx
    (24) E -> . PRINT Ex

  ! shift/reduce conflict for LET resolved as shift
  ! shift/reduce conflict for DIM resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for REPEAT resolved as shift
  ! shift/reduce conflict for GOSUB resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
    SUBPROCEDURE    reduce using rule 76 (empty -> .)
    END             reduce using rule 76 (empty -> .)
    LET             shift and go to state 10
    DIM             shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    REPEAT          shift and go to state 15
    GOSUB           shift and go to state 16
    INPUT           shift and go to state 17
    PRINT           shift and go to state 18

  ! LET             [ reduce using rule 76 (empty -> .) ]
  ! DIM             [ reduce using rule 76 (empty -> .) ]
  ! IF              [ reduce using rule 76 (empty -> .) ]
  ! FOR             [ reduce using rule 76 (empty -> .) ]
  ! WHILE           [ reduce using rule 76 (empty -> .) ]
  ! REPEAT          [ reduce using rule 76 (empty -> .) ]
  ! GOSUB           [ reduce using rule 76 (empty -> .) ]
  ! INPUT           [ reduce using rule 76 (empty -> .) ]
  ! PRINT           [ reduce using rule 76 (empty -> .) ]

    M                              shift and go to state 6
    F                              shift and go to state 7
    empty                          shift and go to state 8
    E                              shift and go to state 9

state 4

    (2) V -> DIM . setType Idv AS T Arr
    (40) setType -> .

    ID              reduce using rule 40 (setType -> .)

    setType                        shift and go to state 19

state 5

    (3) V -> empty .

    LET             reduce using rule 3 (V -> empty .)
    DIM             reduce using rule 3 (V -> empty .)
    IF              reduce using rule 3 (V -> empty .)
    FOR             reduce using rule 3 (V -> empty .)
    WHILE           reduce using rule 3 (V -> empty .)
    REPEAT          reduce using rule 3 (V -> empty .)
    GOSUB           reduce using rule 3 (V -> empty .)
    INPUT           reduce using rule 3 (V -> empty .)
    PRINT           reduce using rule 3 (V -> empty .)
    SUBPROCEDURE    reduce using rule 3 (V -> empty .)
    END             reduce using rule 3 (V -> empty .)


state 6

    (1) PROGRAMA -> PROGRAM V M . S END
    (10) S -> . SUBPROCEDURE ID TWOPOINTS M RETURN S
    (11) S -> . empty
    (76) empty -> .

    SUBPROCEDURE    shift and go to state 21
    END             reduce using rule 76 (empty -> .)

    S                              shift and go to state 20
    empty                          shift and go to state 22

state 7

    (12) M -> F . M
    (12) M -> . F M
    (13) M -> . empty
    (14) F -> . E F
    (15) F -> . empty
    (76) empty -> .
    (16) E -> . LET setType Idv EQUALS Ex
    (17) E -> . DIM setType Idv AS T Arr
    (18) E -> . IF EL THEN first_conditional F Esf EIF final_conditional
    (19) E -> . FOR ID EQUALS EA for_assignation TO Ex for_conditional DO for_save_conditional F NEXT ID for_conditional_end
    (20) E -> . WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional
    (21) E -> . REPEAT while_first_conditional F UNTIL EL repeat_conditional
    (22) E -> . GOSUB ID
    (23) E -> . INPUT ES COMA IDEx
    (24) E -> . PRINT Ex

  ! shift/reduce conflict for LET resolved as shift
  ! shift/reduce conflict for DIM resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for REPEAT resolved as shift
  ! shift/reduce conflict for GOSUB resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
    SUBPROCEDURE    reduce using rule 76 (empty -> .)
    END             reduce using rule 76 (empty -> .)
    RETURN          reduce using rule 76 (empty -> .)
    LET             shift and go to state 10
    DIM             shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    REPEAT          shift and go to state 15
    GOSUB           shift and go to state 16
    INPUT           shift and go to state 17
    PRINT           shift and go to state 18

  ! LET             [ reduce using rule 76 (empty -> .) ]
  ! DIM             [ reduce using rule 76 (empty -> .) ]
  ! IF              [ reduce using rule 76 (empty -> .) ]
  ! FOR             [ reduce using rule 76 (empty -> .) ]
  ! WHILE           [ reduce using rule 76 (empty -> .) ]
  ! REPEAT          [ reduce using rule 76 (empty -> .) ]
  ! GOSUB           [ reduce using rule 76 (empty -> .) ]
  ! INPUT           [ reduce using rule 76 (empty -> .) ]
  ! PRINT           [ reduce using rule 76 (empty -> .) ]

    F                              shift and go to state 7
    M                              shift and go to state 23
    empty                          shift and go to state 8
    E                              shift and go to state 9

state 8

    (13) M -> empty .
    (15) F -> empty .

  ! reduce/reduce conflict for SUBPROCEDURE resolved using rule 13 (M -> empty .)
  ! reduce/reduce conflict for END resolved using rule 13 (M -> empty .)
  ! reduce/reduce conflict for RETURN resolved using rule 13 (M -> empty .)
    SUBPROCEDURE    reduce using rule 13 (M -> empty .)
    END             reduce using rule 13 (M -> empty .)
    RETURN          reduce using rule 13 (M -> empty .)
    LET             reduce using rule 15 (F -> empty .)
    DIM             reduce using rule 15 (F -> empty .)
    IF              reduce using rule 15 (F -> empty .)
    FOR             reduce using rule 15 (F -> empty .)
    WHILE           reduce using rule 15 (F -> empty .)
    REPEAT          reduce using rule 15 (F -> empty .)
    GOSUB           reduce using rule 15 (F -> empty .)
    INPUT           reduce using rule 15 (F -> empty .)
    PRINT           reduce using rule 15 (F -> empty .)

  ! SUBPROCEDURE    [ reduce using rule 15 (F -> empty .) ]
  ! END             [ reduce using rule 15 (F -> empty .) ]
  ! RETURN          [ reduce using rule 15 (F -> empty .) ]


state 9

    (14) F -> E . F
    (14) F -> . E F
    (15) F -> . empty
    (16) E -> . LET setType Idv EQUALS Ex
    (17) E -> . DIM setType Idv AS T Arr
    (18) E -> . IF EL THEN first_conditional F Esf EIF final_conditional
    (19) E -> . FOR ID EQUALS EA for_assignation TO Ex for_conditional DO for_save_conditional F NEXT ID for_conditional_end
    (20) E -> . WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional
    (21) E -> . REPEAT while_first_conditional F UNTIL EL repeat_conditional
    (22) E -> . GOSUB ID
    (23) E -> . INPUT ES COMA IDEx
    (24) E -> . PRINT Ex
    (76) empty -> .

  ! shift/reduce conflict for LET resolved as shift
  ! shift/reduce conflict for DIM resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for REPEAT resolved as shift
  ! shift/reduce conflict for GOSUB resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
    LET             shift and go to state 10
    DIM             shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    REPEAT          shift and go to state 15
    GOSUB           shift and go to state 16
    INPUT           shift and go to state 17
    PRINT           shift and go to state 18
    SUBPROCEDURE    reduce using rule 76 (empty -> .)
    END             reduce using rule 76 (empty -> .)
    RETURN          reduce using rule 76 (empty -> .)
    UNTIL           reduce using rule 76 (empty -> .)
    ELSE            reduce using rule 76 (empty -> .)
    EIF             reduce using rule 76 (empty -> .)
    WEND            reduce using rule 76 (empty -> .)
    NEXT            reduce using rule 76 (empty -> .)

  ! LET             [ reduce using rule 76 (empty -> .) ]
  ! DIM             [ reduce using rule 76 (empty -> .) ]
  ! IF              [ reduce using rule 76 (empty -> .) ]
  ! FOR             [ reduce using rule 76 (empty -> .) ]
  ! WHILE           [ reduce using rule 76 (empty -> .) ]
  ! REPEAT          [ reduce using rule 76 (empty -> .) ]
  ! GOSUB           [ reduce using rule 76 (empty -> .) ]
  ! INPUT           [ reduce using rule 76 (empty -> .) ]
  ! PRINT           [ reduce using rule 76 (empty -> .) ]

    E                              shift and go to state 9
    F                              shift and go to state 24
    empty                          shift and go to state 25

state 10

    (16) E -> LET . setType Idv EQUALS Ex
    (40) setType -> .

    ID              reduce using rule 40 (setType -> .)

    setType                        shift and go to state 26

state 11

    (17) E -> DIM . setType Idv AS T Arr
    (40) setType -> .

    ID              reduce using rule 40 (setType -> .)

    setType                        shift and go to state 27

state 12

    (18) E -> IF . EL THEN first_conditional F Esf EIF final_conditional
    (62) EL -> . TRUE
    (63) EL -> . FALSE
    (64) EL -> . OPENPAR O CLOSINGPAR
    (65) EL -> . OPENPAR O CLOSINGPAR OL EL

    TRUE            shift and go to state 29
    FALSE           shift and go to state 30
    OPENPAR         shift and go to state 31

    EL                             shift and go to state 28

state 13

    (19) E -> FOR . ID EQUALS EA for_assignation TO Ex for_conditional DO for_save_conditional F NEXT ID for_conditional_end

    ID              shift and go to state 32


state 14

    (20) E -> WHILE . while_first_conditional EL DO while_second_conditional F WEND while_final_conditional
    (30) while_first_conditional -> .

    TRUE            reduce using rule 30 (while_first_conditional -> .)
    FALSE           reduce using rule 30 (while_first_conditional -> .)
    OPENPAR         reduce using rule 30 (while_first_conditional -> .)

    while_first_conditional        shift and go to state 33

state 15

    (21) E -> REPEAT . while_first_conditional F UNTIL EL repeat_conditional
    (30) while_first_conditional -> .

    LET             reduce using rule 30 (while_first_conditional -> .)
    DIM             reduce using rule 30 (while_first_conditional -> .)
    IF              reduce using rule 30 (while_first_conditional -> .)
    FOR             reduce using rule 30 (while_first_conditional -> .)
    WHILE           reduce using rule 30 (while_first_conditional -> .)
    REPEAT          reduce using rule 30 (while_first_conditional -> .)
    GOSUB           reduce using rule 30 (while_first_conditional -> .)
    INPUT           reduce using rule 30 (while_first_conditional -> .)
    PRINT           reduce using rule 30 (while_first_conditional -> .)
    UNTIL           reduce using rule 30 (while_first_conditional -> .)

    while_first_conditional        shift and go to state 34

state 16

    (22) E -> GOSUB . ID

    ID              shift and go to state 35


state 17

    (23) E -> INPUT . ES COMA IDEx
    (47) ES -> . WORDVAL

    WORDVAL         shift and go to state 37

    ES                             shift and go to state 36

state 18

    (24) E -> PRINT . Ex
    (43) Ex -> . EA
    (44) Ex -> . ES
    (45) Ex -> . EL
    (46) Ex -> . ID
    (48) EA -> . EA PLUS P
    (49) EA -> . EA MINUS P
    (50) EA -> . P
    (47) ES -> . WORDVAL
    (62) EL -> . TRUE
    (63) EL -> . FALSE
    (64) EL -> . OPENPAR O CLOSINGPAR
    (65) EL -> . OPENPAR O CLOSINGPAR OL EL
    (51) P -> . P MULTIPLY N
    (52) P -> . P DIVIDE N
    (53) P -> . N
    (54) N -> . cte saveID
    (55) N -> . ID saveID
    (56) N -> . OPENPAR EA CLOSINGPAR
    (57) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (58) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (60) cte -> . INTVAL
    (61) cte -> . FLOATVAL

    ID              shift and go to state 42
    WORDVAL         shift and go to state 37
    TRUE            shift and go to state 29
    FALSE           shift and go to state 30
    OPENPAR         shift and go to state 44
    INTVAL          shift and go to state 47
    FLOATVAL        shift and go to state 48

    Ex                             shift and go to state 38
    EA                             shift and go to state 39
    ES                             shift and go to state 40
    EL                             shift and go to state 41
    P                              shift and go to state 43
    N                              shift and go to state 45
    cte                            shift and go to state 46

state 19

    (2) V -> DIM setType . Idv AS T Arr
    (38) Idv -> . ID COMA Idv
    (39) Idv -> . ID

    ID              shift and go to state 50

    Idv                            shift and go to state 49

state 20

    (1) PROGRAMA -> PROGRAM V M S . END

    END             shift and go to state 51


state 21

    (10) S -> SUBPROCEDURE . ID TWOPOINTS M RETURN S

    ID              shift and go to state 52


state 22

    (11) S -> empty .

    END             reduce using rule 11 (S -> empty .)


state 23

    (12) M -> F M .

    SUBPROCEDURE    reduce using rule 12 (M -> F M .)
    END             reduce using rule 12 (M -> F M .)
    RETURN          reduce using rule 12 (M -> F M .)


state 24

    (14) F -> E F .

    LET             reduce using rule 14 (F -> E F .)
    DIM             reduce using rule 14 (F -> E F .)
    IF              reduce using rule 14 (F -> E F .)
    FOR             reduce using rule 14 (F -> E F .)
    WHILE           reduce using rule 14 (F -> E F .)
    REPEAT          reduce using rule 14 (F -> E F .)
    GOSUB           reduce using rule 14 (F -> E F .)
    INPUT           reduce using rule 14 (F -> E F .)
    PRINT           reduce using rule 14 (F -> E F .)
    SUBPROCEDURE    reduce using rule 14 (F -> E F .)
    END             reduce using rule 14 (F -> E F .)
    RETURN          reduce using rule 14 (F -> E F .)
    UNTIL           reduce using rule 14 (F -> E F .)
    ELSE            reduce using rule 14 (F -> E F .)
    EIF             reduce using rule 14 (F -> E F .)
    WEND            reduce using rule 14 (F -> E F .)
    NEXT            reduce using rule 14 (F -> E F .)


state 25

    (15) F -> empty .

    LET             reduce using rule 15 (F -> empty .)
    DIM             reduce using rule 15 (F -> empty .)
    IF              reduce using rule 15 (F -> empty .)
    FOR             reduce using rule 15 (F -> empty .)
    WHILE           reduce using rule 15 (F -> empty .)
    REPEAT          reduce using rule 15 (F -> empty .)
    GOSUB           reduce using rule 15 (F -> empty .)
    INPUT           reduce using rule 15 (F -> empty .)
    PRINT           reduce using rule 15 (F -> empty .)
    SUBPROCEDURE    reduce using rule 15 (F -> empty .)
    END             reduce using rule 15 (F -> empty .)
    RETURN          reduce using rule 15 (F -> empty .)
    UNTIL           reduce using rule 15 (F -> empty .)
    ELSE            reduce using rule 15 (F -> empty .)
    EIF             reduce using rule 15 (F -> empty .)
    WEND            reduce using rule 15 (F -> empty .)
    NEXT            reduce using rule 15 (F -> empty .)


state 26

    (16) E -> LET setType . Idv EQUALS Ex
    (38) Idv -> . ID COMA Idv
    (39) Idv -> . ID

    ID              shift and go to state 50

    Idv                            shift and go to state 53

state 27

    (17) E -> DIM setType . Idv AS T Arr
    (38) Idv -> . ID COMA Idv
    (39) Idv -> . ID

    ID              shift and go to state 50

    Idv                            shift and go to state 54

state 28

    (18) E -> IF EL . THEN first_conditional F Esf EIF final_conditional

    THEN            shift and go to state 55


state 29

    (62) EL -> TRUE .

    THEN            reduce using rule 62 (EL -> TRUE .)
    LET             reduce using rule 62 (EL -> TRUE .)
    DIM             reduce using rule 62 (EL -> TRUE .)
    IF              reduce using rule 62 (EL -> TRUE .)
    FOR             reduce using rule 62 (EL -> TRUE .)
    WHILE           reduce using rule 62 (EL -> TRUE .)
    REPEAT          reduce using rule 62 (EL -> TRUE .)
    GOSUB           reduce using rule 62 (EL -> TRUE .)
    INPUT           reduce using rule 62 (EL -> TRUE .)
    PRINT           reduce using rule 62 (EL -> TRUE .)
    SUBPROCEDURE    reduce using rule 62 (EL -> TRUE .)
    END             reduce using rule 62 (EL -> TRUE .)
    RETURN          reduce using rule 62 (EL -> TRUE .)
    UNTIL           reduce using rule 62 (EL -> TRUE .)
    ELSE            reduce using rule 62 (EL -> TRUE .)
    EIF             reduce using rule 62 (EL -> TRUE .)
    WEND            reduce using rule 62 (EL -> TRUE .)
    NEXT            reduce using rule 62 (EL -> TRUE .)
    GREATHER        reduce using rule 62 (EL -> TRUE .)
    GREATHEREQUAL   reduce using rule 62 (EL -> TRUE .)
    SMALLER         reduce using rule 62 (EL -> TRUE .)
    SMALLEREQUAL    reduce using rule 62 (EL -> TRUE .)
    NOTEQUAL        reduce using rule 62 (EL -> TRUE .)
    EQUALTO         reduce using rule 62 (EL -> TRUE .)
    error           reduce using rule 62 (EL -> TRUE .)
    DO              reduce using rule 62 (EL -> TRUE .)
    CLOSINGPAR      reduce using rule 62 (EL -> TRUE .)


state 30

    (63) EL -> FALSE .

    THEN            reduce using rule 63 (EL -> FALSE .)
    LET             reduce using rule 63 (EL -> FALSE .)
    DIM             reduce using rule 63 (EL -> FALSE .)
    IF              reduce using rule 63 (EL -> FALSE .)
    FOR             reduce using rule 63 (EL -> FALSE .)
    WHILE           reduce using rule 63 (EL -> FALSE .)
    REPEAT          reduce using rule 63 (EL -> FALSE .)
    GOSUB           reduce using rule 63 (EL -> FALSE .)
    INPUT           reduce using rule 63 (EL -> FALSE .)
    PRINT           reduce using rule 63 (EL -> FALSE .)
    SUBPROCEDURE    reduce using rule 63 (EL -> FALSE .)
    END             reduce using rule 63 (EL -> FALSE .)
    RETURN          reduce using rule 63 (EL -> FALSE .)
    UNTIL           reduce using rule 63 (EL -> FALSE .)
    ELSE            reduce using rule 63 (EL -> FALSE .)
    EIF             reduce using rule 63 (EL -> FALSE .)
    WEND            reduce using rule 63 (EL -> FALSE .)
    NEXT            reduce using rule 63 (EL -> FALSE .)
    GREATHER        reduce using rule 63 (EL -> FALSE .)
    GREATHEREQUAL   reduce using rule 63 (EL -> FALSE .)
    SMALLER         reduce using rule 63 (EL -> FALSE .)
    SMALLEREQUAL    reduce using rule 63 (EL -> FALSE .)
    NOTEQUAL        reduce using rule 63 (EL -> FALSE .)
    EQUALTO         reduce using rule 63 (EL -> FALSE .)
    error           reduce using rule 63 (EL -> FALSE .)
    DO              reduce using rule 63 (EL -> FALSE .)
    CLOSINGPAR      reduce using rule 63 (EL -> FALSE .)


state 31

    (64) EL -> OPENPAR . O CLOSINGPAR
    (65) EL -> OPENPAR . O CLOSINGPAR OL EL
    (69) O -> . Ex GREATHER Ex
    (70) O -> . Ex GREATHEREQUAL Ex
    (71) O -> . Ex SMALLER Ex
    (72) O -> . Ex SMALLEREQUAL Ex
    (73) O -> . Ex NOTEQUAL Ex
    (74) O -> . Ex EQUALTO Ex
    (75) O -> . Ex error Ex
    (43) Ex -> . EA
    (44) Ex -> . ES
    (45) Ex -> . EL
    (46) Ex -> . ID
    (48) EA -> . EA PLUS P
    (49) EA -> . EA MINUS P
    (50) EA -> . P
    (47) ES -> . WORDVAL
    (62) EL -> . TRUE
    (63) EL -> . FALSE
    (64) EL -> . OPENPAR O CLOSINGPAR
    (65) EL -> . OPENPAR O CLOSINGPAR OL EL
    (51) P -> . P MULTIPLY N
    (52) P -> . P DIVIDE N
    (53) P -> . N
    (54) N -> . cte saveID
    (55) N -> . ID saveID
    (56) N -> . OPENPAR EA CLOSINGPAR
    (57) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (58) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (60) cte -> . INTVAL
    (61) cte -> . FLOATVAL

    ID              shift and go to state 42
    WORDVAL         shift and go to state 37
    TRUE            shift and go to state 29
    FALSE           shift and go to state 30
    OPENPAR         shift and go to state 44
    INTVAL          shift and go to state 47
    FLOATVAL        shift and go to state 48

    O                              shift and go to state 56
    EL                             shift and go to state 41
    Ex                             shift and go to state 57
    EA                             shift and go to state 39
    ES                             shift and go to state 40
    P                              shift and go to state 43
    N                              shift and go to state 45
    cte                            shift and go to state 46

state 32

    (19) E -> FOR ID . EQUALS EA for_assignation TO Ex for_conditional DO for_save_conditional F NEXT ID for_conditional_end

    EQUALS          shift and go to state 58


state 33

    (20) E -> WHILE while_first_conditional . EL DO while_second_conditional F WEND while_final_conditional
    (62) EL -> . TRUE
    (63) EL -> . FALSE
    (64) EL -> . OPENPAR O CLOSINGPAR
    (65) EL -> . OPENPAR O CLOSINGPAR OL EL

    TRUE            shift and go to state 29
    FALSE           shift and go to state 30
    OPENPAR         shift and go to state 31

    EL                             shift and go to state 59

state 34

    (21) E -> REPEAT while_first_conditional . F UNTIL EL repeat_conditional
    (14) F -> . E F
    (15) F -> . empty
    (16) E -> . LET setType Idv EQUALS Ex
    (17) E -> . DIM setType Idv AS T Arr
    (18) E -> . IF EL THEN first_conditional F Esf EIF final_conditional
    (19) E -> . FOR ID EQUALS EA for_assignation TO Ex for_conditional DO for_save_conditional F NEXT ID for_conditional_end
    (20) E -> . WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional
    (21) E -> . REPEAT while_first_conditional F UNTIL EL repeat_conditional
    (22) E -> . GOSUB ID
    (23) E -> . INPUT ES COMA IDEx
    (24) E -> . PRINT Ex
    (76) empty -> .

    LET             shift and go to state 10
    DIM             shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    REPEAT          shift and go to state 15
    GOSUB           shift and go to state 16
    INPUT           shift and go to state 17
    PRINT           shift and go to state 18
    UNTIL           reduce using rule 76 (empty -> .)

    F                              shift and go to state 60
    E                              shift and go to state 9
    empty                          shift and go to state 25

state 35

    (22) E -> GOSUB ID .

    LET             reduce using rule 22 (E -> GOSUB ID .)
    DIM             reduce using rule 22 (E -> GOSUB ID .)
    IF              reduce using rule 22 (E -> GOSUB ID .)
    FOR             reduce using rule 22 (E -> GOSUB ID .)
    WHILE           reduce using rule 22 (E -> GOSUB ID .)
    REPEAT          reduce using rule 22 (E -> GOSUB ID .)
    GOSUB           reduce using rule 22 (E -> GOSUB ID .)
    INPUT           reduce using rule 22 (E -> GOSUB ID .)
    PRINT           reduce using rule 22 (E -> GOSUB ID .)
    SUBPROCEDURE    reduce using rule 22 (E -> GOSUB ID .)
    END             reduce using rule 22 (E -> GOSUB ID .)
    RETURN          reduce using rule 22 (E -> GOSUB ID .)
    UNTIL           reduce using rule 22 (E -> GOSUB ID .)
    ELSE            reduce using rule 22 (E -> GOSUB ID .)
    EIF             reduce using rule 22 (E -> GOSUB ID .)
    WEND            reduce using rule 22 (E -> GOSUB ID .)
    NEXT            reduce using rule 22 (E -> GOSUB ID .)


state 36

    (23) E -> INPUT ES . COMA IDEx

    COMA            shift and go to state 61


state 37

    (47) ES -> WORDVAL .

    COMA            reduce using rule 47 (ES -> WORDVAL .)
    LET             reduce using rule 47 (ES -> WORDVAL .)
    DIM             reduce using rule 47 (ES -> WORDVAL .)
    IF              reduce using rule 47 (ES -> WORDVAL .)
    FOR             reduce using rule 47 (ES -> WORDVAL .)
    WHILE           reduce using rule 47 (ES -> WORDVAL .)
    REPEAT          reduce using rule 47 (ES -> WORDVAL .)
    GOSUB           reduce using rule 47 (ES -> WORDVAL .)
    INPUT           reduce using rule 47 (ES -> WORDVAL .)
    PRINT           reduce using rule 47 (ES -> WORDVAL .)
    SUBPROCEDURE    reduce using rule 47 (ES -> WORDVAL .)
    END             reduce using rule 47 (ES -> WORDVAL .)
    RETURN          reduce using rule 47 (ES -> WORDVAL .)
    UNTIL           reduce using rule 47 (ES -> WORDVAL .)
    ELSE            reduce using rule 47 (ES -> WORDVAL .)
    EIF             reduce using rule 47 (ES -> WORDVAL .)
    WEND            reduce using rule 47 (ES -> WORDVAL .)
    NEXT            reduce using rule 47 (ES -> WORDVAL .)
    GREATHER        reduce using rule 47 (ES -> WORDVAL .)
    GREATHEREQUAL   reduce using rule 47 (ES -> WORDVAL .)
    SMALLER         reduce using rule 47 (ES -> WORDVAL .)
    SMALLEREQUAL    reduce using rule 47 (ES -> WORDVAL .)
    NOTEQUAL        reduce using rule 47 (ES -> WORDVAL .)
    EQUALTO         reduce using rule 47 (ES -> WORDVAL .)
    error           reduce using rule 47 (ES -> WORDVAL .)
    CLOSINGPAR      reduce using rule 47 (ES -> WORDVAL .)
    DO              reduce using rule 47 (ES -> WORDVAL .)


state 38

    (24) E -> PRINT Ex .

    LET             reduce using rule 24 (E -> PRINT Ex .)
    DIM             reduce using rule 24 (E -> PRINT Ex .)
    IF              reduce using rule 24 (E -> PRINT Ex .)
    FOR             reduce using rule 24 (E -> PRINT Ex .)
    WHILE           reduce using rule 24 (E -> PRINT Ex .)
    REPEAT          reduce using rule 24 (E -> PRINT Ex .)
    GOSUB           reduce using rule 24 (E -> PRINT Ex .)
    INPUT           reduce using rule 24 (E -> PRINT Ex .)
    PRINT           reduce using rule 24 (E -> PRINT Ex .)
    SUBPROCEDURE    reduce using rule 24 (E -> PRINT Ex .)
    END             reduce using rule 24 (E -> PRINT Ex .)
    RETURN          reduce using rule 24 (E -> PRINT Ex .)
    UNTIL           reduce using rule 24 (E -> PRINT Ex .)
    ELSE            reduce using rule 24 (E -> PRINT Ex .)
    EIF             reduce using rule 24 (E -> PRINT Ex .)
    WEND            reduce using rule 24 (E -> PRINT Ex .)
    NEXT            reduce using rule 24 (E -> PRINT Ex .)


state 39

    (43) Ex -> EA .
    (48) EA -> EA . PLUS P
    (49) EA -> EA . MINUS P

    LET             reduce using rule 43 (Ex -> EA .)
    DIM             reduce using rule 43 (Ex -> EA .)
    IF              reduce using rule 43 (Ex -> EA .)
    FOR             reduce using rule 43 (Ex -> EA .)
    WHILE           reduce using rule 43 (Ex -> EA .)
    REPEAT          reduce using rule 43 (Ex -> EA .)
    GOSUB           reduce using rule 43 (Ex -> EA .)
    INPUT           reduce using rule 43 (Ex -> EA .)
    PRINT           reduce using rule 43 (Ex -> EA .)
    SUBPROCEDURE    reduce using rule 43 (Ex -> EA .)
    END             reduce using rule 43 (Ex -> EA .)
    RETURN          reduce using rule 43 (Ex -> EA .)
    UNTIL           reduce using rule 43 (Ex -> EA .)
    ELSE            reduce using rule 43 (Ex -> EA .)
    EIF             reduce using rule 43 (Ex -> EA .)
    WEND            reduce using rule 43 (Ex -> EA .)
    NEXT            reduce using rule 43 (Ex -> EA .)
    GREATHER        reduce using rule 43 (Ex -> EA .)
    GREATHEREQUAL   reduce using rule 43 (Ex -> EA .)
    SMALLER         reduce using rule 43 (Ex -> EA .)
    SMALLEREQUAL    reduce using rule 43 (Ex -> EA .)
    NOTEQUAL        reduce using rule 43 (Ex -> EA .)
    EQUALTO         reduce using rule 43 (Ex -> EA .)
    error           reduce using rule 43 (Ex -> EA .)
    CLOSINGPAR      reduce using rule 43 (Ex -> EA .)
    DO              reduce using rule 43 (Ex -> EA .)
    PLUS            shift and go to state 62
    MINUS           shift and go to state 63


state 40

    (44) Ex -> ES .

    LET             reduce using rule 44 (Ex -> ES .)
    DIM             reduce using rule 44 (Ex -> ES .)
    IF              reduce using rule 44 (Ex -> ES .)
    FOR             reduce using rule 44 (Ex -> ES .)
    WHILE           reduce using rule 44 (Ex -> ES .)
    REPEAT          reduce using rule 44 (Ex -> ES .)
    GOSUB           reduce using rule 44 (Ex -> ES .)
    INPUT           reduce using rule 44 (Ex -> ES .)
    PRINT           reduce using rule 44 (Ex -> ES .)
    SUBPROCEDURE    reduce using rule 44 (Ex -> ES .)
    END             reduce using rule 44 (Ex -> ES .)
    RETURN          reduce using rule 44 (Ex -> ES .)
    UNTIL           reduce using rule 44 (Ex -> ES .)
    ELSE            reduce using rule 44 (Ex -> ES .)
    EIF             reduce using rule 44 (Ex -> ES .)
    WEND            reduce using rule 44 (Ex -> ES .)
    NEXT            reduce using rule 44 (Ex -> ES .)
    GREATHER        reduce using rule 44 (Ex -> ES .)
    GREATHEREQUAL   reduce using rule 44 (Ex -> ES .)
    SMALLER         reduce using rule 44 (Ex -> ES .)
    SMALLEREQUAL    reduce using rule 44 (Ex -> ES .)
    NOTEQUAL        reduce using rule 44 (Ex -> ES .)
    EQUALTO         reduce using rule 44 (Ex -> ES .)
    error           reduce using rule 44 (Ex -> ES .)
    CLOSINGPAR      reduce using rule 44 (Ex -> ES .)
    DO              reduce using rule 44 (Ex -> ES .)


state 41

    (45) Ex -> EL .

    LET             reduce using rule 45 (Ex -> EL .)
    DIM             reduce using rule 45 (Ex -> EL .)
    IF              reduce using rule 45 (Ex -> EL .)
    FOR             reduce using rule 45 (Ex -> EL .)
    WHILE           reduce using rule 45 (Ex -> EL .)
    REPEAT          reduce using rule 45 (Ex -> EL .)
    GOSUB           reduce using rule 45 (Ex -> EL .)
    INPUT           reduce using rule 45 (Ex -> EL .)
    PRINT           reduce using rule 45 (Ex -> EL .)
    SUBPROCEDURE    reduce using rule 45 (Ex -> EL .)
    END             reduce using rule 45 (Ex -> EL .)
    RETURN          reduce using rule 45 (Ex -> EL .)
    UNTIL           reduce using rule 45 (Ex -> EL .)
    ELSE            reduce using rule 45 (Ex -> EL .)
    EIF             reduce using rule 45 (Ex -> EL .)
    WEND            reduce using rule 45 (Ex -> EL .)
    NEXT            reduce using rule 45 (Ex -> EL .)
    GREATHER        reduce using rule 45 (Ex -> EL .)
    GREATHEREQUAL   reduce using rule 45 (Ex -> EL .)
    SMALLER         reduce using rule 45 (Ex -> EL .)
    SMALLEREQUAL    reduce using rule 45 (Ex -> EL .)
    NOTEQUAL        reduce using rule 45 (Ex -> EL .)
    EQUALTO         reduce using rule 45 (Ex -> EL .)
    error           reduce using rule 45 (Ex -> EL .)
    CLOSINGPAR      reduce using rule 45 (Ex -> EL .)
    DO              reduce using rule 45 (Ex -> EL .)


state 42

    (46) Ex -> ID .
    (55) N -> ID . saveID
    (57) N -> ID . OPENBRACKET INTVAL CLOSINGBRACKET
    (58) N -> ID . OPENBRACKET setType Idv CLOSINGBRACKET
    (59) saveID -> .

  ! reduce/reduce conflict for LET resolved using rule 46 (Ex -> ID .)
  ! reduce/reduce conflict for DIM resolved using rule 46 (Ex -> ID .)
  ! reduce/reduce conflict for IF resolved using rule 46 (Ex -> ID .)
  ! reduce/reduce conflict for FOR resolved using rule 46 (Ex -> ID .)
  ! reduce/reduce conflict for WHILE resolved using rule 46 (Ex -> ID .)
  ! reduce/reduce conflict for REPEAT resolved using rule 46 (Ex -> ID .)
  ! reduce/reduce conflict for GOSUB resolved using rule 46 (Ex -> ID .)
  ! reduce/reduce conflict for INPUT resolved using rule 46 (Ex -> ID .)
  ! reduce/reduce conflict for PRINT resolved using rule 46 (Ex -> ID .)
  ! reduce/reduce conflict for SUBPROCEDURE resolved using rule 46 (Ex -> ID .)
  ! reduce/reduce conflict for END resolved using rule 46 (Ex -> ID .)
  ! reduce/reduce conflict for RETURN resolved using rule 46 (Ex -> ID .)
  ! reduce/reduce conflict for UNTIL resolved using rule 46 (Ex -> ID .)
  ! reduce/reduce conflict for ELSE resolved using rule 46 (Ex -> ID .)
  ! reduce/reduce conflict for EIF resolved using rule 46 (Ex -> ID .)
  ! reduce/reduce conflict for WEND resolved using rule 46 (Ex -> ID .)
  ! reduce/reduce conflict for NEXT resolved using rule 46 (Ex -> ID .)
  ! reduce/reduce conflict for GREATHER resolved using rule 46 (Ex -> ID .)
  ! reduce/reduce conflict for GREATHEREQUAL resolved using rule 46 (Ex -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 46 (Ex -> ID .)
  ! reduce/reduce conflict for SMALLEREQUAL resolved using rule 46 (Ex -> ID .)
  ! reduce/reduce conflict for NOTEQUAL resolved using rule 46 (Ex -> ID .)
  ! reduce/reduce conflict for EQUALTO resolved using rule 46 (Ex -> ID .)
  ! reduce/reduce conflict for error resolved using rule 46 (Ex -> ID .)
  ! reduce/reduce conflict for CLOSINGPAR resolved using rule 46 (Ex -> ID .)
  ! reduce/reduce conflict for DO resolved using rule 46 (Ex -> ID .)
    LET             reduce using rule 46 (Ex -> ID .)
    DIM             reduce using rule 46 (Ex -> ID .)
    IF              reduce using rule 46 (Ex -> ID .)
    FOR             reduce using rule 46 (Ex -> ID .)
    WHILE           reduce using rule 46 (Ex -> ID .)
    REPEAT          reduce using rule 46 (Ex -> ID .)
    GOSUB           reduce using rule 46 (Ex -> ID .)
    INPUT           reduce using rule 46 (Ex -> ID .)
    PRINT           reduce using rule 46 (Ex -> ID .)
    SUBPROCEDURE    reduce using rule 46 (Ex -> ID .)
    END             reduce using rule 46 (Ex -> ID .)
    RETURN          reduce using rule 46 (Ex -> ID .)
    UNTIL           reduce using rule 46 (Ex -> ID .)
    ELSE            reduce using rule 46 (Ex -> ID .)
    EIF             reduce using rule 46 (Ex -> ID .)
    WEND            reduce using rule 46 (Ex -> ID .)
    NEXT            reduce using rule 46 (Ex -> ID .)
    GREATHER        reduce using rule 46 (Ex -> ID .)
    GREATHEREQUAL   reduce using rule 46 (Ex -> ID .)
    SMALLER         reduce using rule 46 (Ex -> ID .)
    SMALLEREQUAL    reduce using rule 46 (Ex -> ID .)
    NOTEQUAL        reduce using rule 46 (Ex -> ID .)
    EQUALTO         reduce using rule 46 (Ex -> ID .)
    error           reduce using rule 46 (Ex -> ID .)
    CLOSINGPAR      reduce using rule 46 (Ex -> ID .)
    DO              reduce using rule 46 (Ex -> ID .)
    OPENBRACKET     shift and go to state 65
    MULTIPLY        reduce using rule 59 (saveID -> .)
    DIVIDE          reduce using rule 59 (saveID -> .)
    PLUS            reduce using rule 59 (saveID -> .)
    MINUS           reduce using rule 59 (saveID -> .)

  ! LET             [ reduce using rule 59 (saveID -> .) ]
  ! DIM             [ reduce using rule 59 (saveID -> .) ]
  ! IF              [ reduce using rule 59 (saveID -> .) ]
  ! FOR             [ reduce using rule 59 (saveID -> .) ]
  ! WHILE           [ reduce using rule 59 (saveID -> .) ]
  ! REPEAT          [ reduce using rule 59 (saveID -> .) ]
  ! GOSUB           [ reduce using rule 59 (saveID -> .) ]
  ! INPUT           [ reduce using rule 59 (saveID -> .) ]
  ! PRINT           [ reduce using rule 59 (saveID -> .) ]
  ! SUBPROCEDURE    [ reduce using rule 59 (saveID -> .) ]
  ! END             [ reduce using rule 59 (saveID -> .) ]
  ! RETURN          [ reduce using rule 59 (saveID -> .) ]
  ! UNTIL           [ reduce using rule 59 (saveID -> .) ]
  ! ELSE            [ reduce using rule 59 (saveID -> .) ]
  ! EIF             [ reduce using rule 59 (saveID -> .) ]
  ! WEND            [ reduce using rule 59 (saveID -> .) ]
  ! NEXT            [ reduce using rule 59 (saveID -> .) ]
  ! GREATHER        [ reduce using rule 59 (saveID -> .) ]
  ! GREATHEREQUAL   [ reduce using rule 59 (saveID -> .) ]
  ! SMALLER         [ reduce using rule 59 (saveID -> .) ]
  ! SMALLEREQUAL    [ reduce using rule 59 (saveID -> .) ]
  ! NOTEQUAL        [ reduce using rule 59 (saveID -> .) ]
  ! EQUALTO         [ reduce using rule 59 (saveID -> .) ]
  ! error           [ reduce using rule 59 (saveID -> .) ]
  ! CLOSINGPAR      [ reduce using rule 59 (saveID -> .) ]
  ! DO              [ reduce using rule 59 (saveID -> .) ]

    saveID                         shift and go to state 64

state 43

    (50) EA -> P .
    (51) P -> P . MULTIPLY N
    (52) P -> P . DIVIDE N

    PLUS            reduce using rule 50 (EA -> P .)
    MINUS           reduce using rule 50 (EA -> P .)
    LET             reduce using rule 50 (EA -> P .)
    DIM             reduce using rule 50 (EA -> P .)
    IF              reduce using rule 50 (EA -> P .)
    FOR             reduce using rule 50 (EA -> P .)
    WHILE           reduce using rule 50 (EA -> P .)
    REPEAT          reduce using rule 50 (EA -> P .)
    GOSUB           reduce using rule 50 (EA -> P .)
    INPUT           reduce using rule 50 (EA -> P .)
    PRINT           reduce using rule 50 (EA -> P .)
    SUBPROCEDURE    reduce using rule 50 (EA -> P .)
    END             reduce using rule 50 (EA -> P .)
    RETURN          reduce using rule 50 (EA -> P .)
    UNTIL           reduce using rule 50 (EA -> P .)
    ELSE            reduce using rule 50 (EA -> P .)
    EIF             reduce using rule 50 (EA -> P .)
    WEND            reduce using rule 50 (EA -> P .)
    NEXT            reduce using rule 50 (EA -> P .)
    GREATHER        reduce using rule 50 (EA -> P .)
    GREATHEREQUAL   reduce using rule 50 (EA -> P .)
    SMALLER         reduce using rule 50 (EA -> P .)
    SMALLEREQUAL    reduce using rule 50 (EA -> P .)
    NOTEQUAL        reduce using rule 50 (EA -> P .)
    EQUALTO         reduce using rule 50 (EA -> P .)
    error           reduce using rule 50 (EA -> P .)
    CLOSINGPAR      reduce using rule 50 (EA -> P .)
    TO              reduce using rule 50 (EA -> P .)
    CLOSINGBRACKET  reduce using rule 50 (EA -> P .)
    DO              reduce using rule 50 (EA -> P .)
    MULTIPLY        shift and go to state 66
    DIVIDE          shift and go to state 67


state 44

    (64) EL -> OPENPAR . O CLOSINGPAR
    (65) EL -> OPENPAR . O CLOSINGPAR OL EL
    (56) N -> OPENPAR . EA CLOSINGPAR
    (69) O -> . Ex GREATHER Ex
    (70) O -> . Ex GREATHEREQUAL Ex
    (71) O -> . Ex SMALLER Ex
    (72) O -> . Ex SMALLEREQUAL Ex
    (73) O -> . Ex NOTEQUAL Ex
    (74) O -> . Ex EQUALTO Ex
    (75) O -> . Ex error Ex
    (48) EA -> . EA PLUS P
    (49) EA -> . EA MINUS P
    (50) EA -> . P
    (43) Ex -> . EA
    (44) Ex -> . ES
    (45) Ex -> . EL
    (46) Ex -> . ID
    (51) P -> . P MULTIPLY N
    (52) P -> . P DIVIDE N
    (53) P -> . N
    (47) ES -> . WORDVAL
    (62) EL -> . TRUE
    (63) EL -> . FALSE
    (64) EL -> . OPENPAR O CLOSINGPAR
    (65) EL -> . OPENPAR O CLOSINGPAR OL EL
    (54) N -> . cte saveID
    (55) N -> . ID saveID
    (56) N -> . OPENPAR EA CLOSINGPAR
    (57) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (58) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (60) cte -> . INTVAL
    (61) cte -> . FLOATVAL

    ID              shift and go to state 42
    WORDVAL         shift and go to state 37
    TRUE            shift and go to state 29
    FALSE           shift and go to state 30
    OPENPAR         shift and go to state 44
    INTVAL          shift and go to state 47
    FLOATVAL        shift and go to state 48

    O                              shift and go to state 56
    EL                             shift and go to state 41
    EA                             shift and go to state 68
    Ex                             shift and go to state 57
    P                              shift and go to state 43
    ES                             shift and go to state 40
    N                              shift and go to state 45
    cte                            shift and go to state 46

state 45

    (53) P -> N .

    MULTIPLY        reduce using rule 53 (P -> N .)
    DIVIDE          reduce using rule 53 (P -> N .)
    PLUS            reduce using rule 53 (P -> N .)
    MINUS           reduce using rule 53 (P -> N .)
    LET             reduce using rule 53 (P -> N .)
    DIM             reduce using rule 53 (P -> N .)
    IF              reduce using rule 53 (P -> N .)
    FOR             reduce using rule 53 (P -> N .)
    WHILE           reduce using rule 53 (P -> N .)
    REPEAT          reduce using rule 53 (P -> N .)
    GOSUB           reduce using rule 53 (P -> N .)
    INPUT           reduce using rule 53 (P -> N .)
    PRINT           reduce using rule 53 (P -> N .)
    SUBPROCEDURE    reduce using rule 53 (P -> N .)
    END             reduce using rule 53 (P -> N .)
    RETURN          reduce using rule 53 (P -> N .)
    UNTIL           reduce using rule 53 (P -> N .)
    ELSE            reduce using rule 53 (P -> N .)
    EIF             reduce using rule 53 (P -> N .)
    WEND            reduce using rule 53 (P -> N .)
    NEXT            reduce using rule 53 (P -> N .)
    GREATHER        reduce using rule 53 (P -> N .)
    GREATHEREQUAL   reduce using rule 53 (P -> N .)
    SMALLER         reduce using rule 53 (P -> N .)
    SMALLEREQUAL    reduce using rule 53 (P -> N .)
    NOTEQUAL        reduce using rule 53 (P -> N .)
    EQUALTO         reduce using rule 53 (P -> N .)
    error           reduce using rule 53 (P -> N .)
    CLOSINGPAR      reduce using rule 53 (P -> N .)
    TO              reduce using rule 53 (P -> N .)
    CLOSINGBRACKET  reduce using rule 53 (P -> N .)
    DO              reduce using rule 53 (P -> N .)


state 46

    (54) N -> cte . saveID
    (59) saveID -> .

    MULTIPLY        reduce using rule 59 (saveID -> .)
    DIVIDE          reduce using rule 59 (saveID -> .)
    PLUS            reduce using rule 59 (saveID -> .)
    MINUS           reduce using rule 59 (saveID -> .)
    LET             reduce using rule 59 (saveID -> .)
    DIM             reduce using rule 59 (saveID -> .)
    IF              reduce using rule 59 (saveID -> .)
    FOR             reduce using rule 59 (saveID -> .)
    WHILE           reduce using rule 59 (saveID -> .)
    REPEAT          reduce using rule 59 (saveID -> .)
    GOSUB           reduce using rule 59 (saveID -> .)
    INPUT           reduce using rule 59 (saveID -> .)
    PRINT           reduce using rule 59 (saveID -> .)
    SUBPROCEDURE    reduce using rule 59 (saveID -> .)
    END             reduce using rule 59 (saveID -> .)
    RETURN          reduce using rule 59 (saveID -> .)
    UNTIL           reduce using rule 59 (saveID -> .)
    ELSE            reduce using rule 59 (saveID -> .)
    EIF             reduce using rule 59 (saveID -> .)
    WEND            reduce using rule 59 (saveID -> .)
    NEXT            reduce using rule 59 (saveID -> .)
    GREATHER        reduce using rule 59 (saveID -> .)
    GREATHEREQUAL   reduce using rule 59 (saveID -> .)
    SMALLER         reduce using rule 59 (saveID -> .)
    SMALLEREQUAL    reduce using rule 59 (saveID -> .)
    NOTEQUAL        reduce using rule 59 (saveID -> .)
    EQUALTO         reduce using rule 59 (saveID -> .)
    error           reduce using rule 59 (saveID -> .)
    CLOSINGPAR      reduce using rule 59 (saveID -> .)
    TO              reduce using rule 59 (saveID -> .)
    CLOSINGBRACKET  reduce using rule 59 (saveID -> .)
    DO              reduce using rule 59 (saveID -> .)

    saveID                         shift and go to state 69

state 47

    (60) cte -> INTVAL .

    MULTIPLY        reduce using rule 60 (cte -> INTVAL .)
    DIVIDE          reduce using rule 60 (cte -> INTVAL .)
    PLUS            reduce using rule 60 (cte -> INTVAL .)
    MINUS           reduce using rule 60 (cte -> INTVAL .)
    LET             reduce using rule 60 (cte -> INTVAL .)
    DIM             reduce using rule 60 (cte -> INTVAL .)
    IF              reduce using rule 60 (cte -> INTVAL .)
    FOR             reduce using rule 60 (cte -> INTVAL .)
    WHILE           reduce using rule 60 (cte -> INTVAL .)
    REPEAT          reduce using rule 60 (cte -> INTVAL .)
    GOSUB           reduce using rule 60 (cte -> INTVAL .)
    INPUT           reduce using rule 60 (cte -> INTVAL .)
    PRINT           reduce using rule 60 (cte -> INTVAL .)
    SUBPROCEDURE    reduce using rule 60 (cte -> INTVAL .)
    END             reduce using rule 60 (cte -> INTVAL .)
    RETURN          reduce using rule 60 (cte -> INTVAL .)
    UNTIL           reduce using rule 60 (cte -> INTVAL .)
    ELSE            reduce using rule 60 (cte -> INTVAL .)
    EIF             reduce using rule 60 (cte -> INTVAL .)
    WEND            reduce using rule 60 (cte -> INTVAL .)
    NEXT            reduce using rule 60 (cte -> INTVAL .)
    GREATHER        reduce using rule 60 (cte -> INTVAL .)
    GREATHEREQUAL   reduce using rule 60 (cte -> INTVAL .)
    SMALLER         reduce using rule 60 (cte -> INTVAL .)
    SMALLEREQUAL    reduce using rule 60 (cte -> INTVAL .)
    NOTEQUAL        reduce using rule 60 (cte -> INTVAL .)
    EQUALTO         reduce using rule 60 (cte -> INTVAL .)
    error           reduce using rule 60 (cte -> INTVAL .)
    CLOSINGPAR      reduce using rule 60 (cte -> INTVAL .)
    TO              reduce using rule 60 (cte -> INTVAL .)
    CLOSINGBRACKET  reduce using rule 60 (cte -> INTVAL .)
    DO              reduce using rule 60 (cte -> INTVAL .)


state 48

    (61) cte -> FLOATVAL .

    MULTIPLY        reduce using rule 61 (cte -> FLOATVAL .)
    DIVIDE          reduce using rule 61 (cte -> FLOATVAL .)
    PLUS            reduce using rule 61 (cte -> FLOATVAL .)
    MINUS           reduce using rule 61 (cte -> FLOATVAL .)
    LET             reduce using rule 61 (cte -> FLOATVAL .)
    DIM             reduce using rule 61 (cte -> FLOATVAL .)
    IF              reduce using rule 61 (cte -> FLOATVAL .)
    FOR             reduce using rule 61 (cte -> FLOATVAL .)
    WHILE           reduce using rule 61 (cte -> FLOATVAL .)
    REPEAT          reduce using rule 61 (cte -> FLOATVAL .)
    GOSUB           reduce using rule 61 (cte -> FLOATVAL .)
    INPUT           reduce using rule 61 (cte -> FLOATVAL .)
    PRINT           reduce using rule 61 (cte -> FLOATVAL .)
    SUBPROCEDURE    reduce using rule 61 (cte -> FLOATVAL .)
    END             reduce using rule 61 (cte -> FLOATVAL .)
    RETURN          reduce using rule 61 (cte -> FLOATVAL .)
    UNTIL           reduce using rule 61 (cte -> FLOATVAL .)
    ELSE            reduce using rule 61 (cte -> FLOATVAL .)
    EIF             reduce using rule 61 (cte -> FLOATVAL .)
    WEND            reduce using rule 61 (cte -> FLOATVAL .)
    NEXT            reduce using rule 61 (cte -> FLOATVAL .)
    GREATHER        reduce using rule 61 (cte -> FLOATVAL .)
    GREATHEREQUAL   reduce using rule 61 (cte -> FLOATVAL .)
    SMALLER         reduce using rule 61 (cte -> FLOATVAL .)
    SMALLEREQUAL    reduce using rule 61 (cte -> FLOATVAL .)
    NOTEQUAL        reduce using rule 61 (cte -> FLOATVAL .)
    EQUALTO         reduce using rule 61 (cte -> FLOATVAL .)
    error           reduce using rule 61 (cte -> FLOATVAL .)
    CLOSINGPAR      reduce using rule 61 (cte -> FLOATVAL .)
    TO              reduce using rule 61 (cte -> FLOATVAL .)
    CLOSINGBRACKET  reduce using rule 61 (cte -> FLOATVAL .)
    DO              reduce using rule 61 (cte -> FLOATVAL .)


state 49

    (2) V -> DIM setType Idv . AS T Arr

    AS              shift and go to state 70


state 50

    (38) Idv -> ID . COMA Idv
    (39) Idv -> ID .

    COMA            shift and go to state 71
    AS              reduce using rule 39 (Idv -> ID .)
    EQUALS          reduce using rule 39 (Idv -> ID .)
    CLOSINGBRACKET  reduce using rule 39 (Idv -> ID .)


state 51

    (1) PROGRAMA -> PROGRAM V M S END .

    $end            reduce using rule 1 (PROGRAMA -> PROGRAM V M S END .)


state 52

    (10) S -> SUBPROCEDURE ID . TWOPOINTS M RETURN S

    TWOPOINTS       shift and go to state 72


state 53

    (16) E -> LET setType Idv . EQUALS Ex

    EQUALS          shift and go to state 73


state 54

    (17) E -> DIM setType Idv . AS T Arr

    AS              shift and go to state 74


state 55

    (18) E -> IF EL THEN . first_conditional F Esf EIF final_conditional
    (33) first_conditional -> .

    LET             reduce using rule 33 (first_conditional -> .)
    DIM             reduce using rule 33 (first_conditional -> .)
    IF              reduce using rule 33 (first_conditional -> .)
    FOR             reduce using rule 33 (first_conditional -> .)
    WHILE           reduce using rule 33 (first_conditional -> .)
    REPEAT          reduce using rule 33 (first_conditional -> .)
    GOSUB           reduce using rule 33 (first_conditional -> .)
    INPUT           reduce using rule 33 (first_conditional -> .)
    PRINT           reduce using rule 33 (first_conditional -> .)
    ELSE            reduce using rule 33 (first_conditional -> .)
    EIF             reduce using rule 33 (first_conditional -> .)

    first_conditional              shift and go to state 75

state 56

    (64) EL -> OPENPAR O . CLOSINGPAR
    (65) EL -> OPENPAR O . CLOSINGPAR OL EL

    CLOSINGPAR      shift and go to state 76


state 57

    (69) O -> Ex . GREATHER Ex
    (70) O -> Ex . GREATHEREQUAL Ex
    (71) O -> Ex . SMALLER Ex
    (72) O -> Ex . SMALLEREQUAL Ex
    (73) O -> Ex . NOTEQUAL Ex
    (74) O -> Ex . EQUALTO Ex
    (75) O -> Ex . error Ex

    GREATHER        shift and go to state 77
    GREATHEREQUAL   shift and go to state 78
    SMALLER         shift and go to state 79
    SMALLEREQUAL    shift and go to state 80
    NOTEQUAL        shift and go to state 81
    EQUALTO         shift and go to state 82
    error           shift and go to state 83


state 58

    (19) E -> FOR ID EQUALS . EA for_assignation TO Ex for_conditional DO for_save_conditional F NEXT ID for_conditional_end
    (48) EA -> . EA PLUS P
    (49) EA -> . EA MINUS P
    (50) EA -> . P
    (51) P -> . P MULTIPLY N
    (52) P -> . P DIVIDE N
    (53) P -> . N
    (54) N -> . cte saveID
    (55) N -> . ID saveID
    (56) N -> . OPENPAR EA CLOSINGPAR
    (57) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (58) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (60) cte -> . INTVAL
    (61) cte -> . FLOATVAL

    ID              shift and go to state 84
    OPENPAR         shift and go to state 86
    INTVAL          shift and go to state 47
    FLOATVAL        shift and go to state 48

    EA                             shift and go to state 85
    P                              shift and go to state 43
    N                              shift and go to state 45
    cte                            shift and go to state 46

state 59

    (20) E -> WHILE while_first_conditional EL . DO while_second_conditional F WEND while_final_conditional

    DO              shift and go to state 87


state 60

    (21) E -> REPEAT while_first_conditional F . UNTIL EL repeat_conditional

    UNTIL           shift and go to state 88


state 61

    (23) E -> INPUT ES COMA . IDEx
    (41) IDEx -> . ID
    (42) IDEx -> . ID OPENBRACKET setType Idv CLOSINGBRACKET

    ID              shift and go to state 90

    IDEx                           shift and go to state 89

state 62

    (48) EA -> EA PLUS . P
    (51) P -> . P MULTIPLY N
    (52) P -> . P DIVIDE N
    (53) P -> . N
    (54) N -> . cte saveID
    (55) N -> . ID saveID
    (56) N -> . OPENPAR EA CLOSINGPAR
    (57) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (58) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (60) cte -> . INTVAL
    (61) cte -> . FLOATVAL

    ID              shift and go to state 84
    OPENPAR         shift and go to state 86
    INTVAL          shift and go to state 47
    FLOATVAL        shift and go to state 48

    P                              shift and go to state 91
    N                              shift and go to state 45
    cte                            shift and go to state 46

state 63

    (49) EA -> EA MINUS . P
    (51) P -> . P MULTIPLY N
    (52) P -> . P DIVIDE N
    (53) P -> . N
    (54) N -> . cte saveID
    (55) N -> . ID saveID
    (56) N -> . OPENPAR EA CLOSINGPAR
    (57) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (58) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (60) cte -> . INTVAL
    (61) cte -> . FLOATVAL

    ID              shift and go to state 84
    OPENPAR         shift and go to state 86
    INTVAL          shift and go to state 47
    FLOATVAL        shift and go to state 48

    P                              shift and go to state 92
    N                              shift and go to state 45
    cte                            shift and go to state 46

state 64

    (55) N -> ID saveID .

    MULTIPLY        reduce using rule 55 (N -> ID saveID .)
    DIVIDE          reduce using rule 55 (N -> ID saveID .)
    PLUS            reduce using rule 55 (N -> ID saveID .)
    MINUS           reduce using rule 55 (N -> ID saveID .)
    LET             reduce using rule 55 (N -> ID saveID .)
    DIM             reduce using rule 55 (N -> ID saveID .)
    IF              reduce using rule 55 (N -> ID saveID .)
    FOR             reduce using rule 55 (N -> ID saveID .)
    WHILE           reduce using rule 55 (N -> ID saveID .)
    REPEAT          reduce using rule 55 (N -> ID saveID .)
    GOSUB           reduce using rule 55 (N -> ID saveID .)
    INPUT           reduce using rule 55 (N -> ID saveID .)
    PRINT           reduce using rule 55 (N -> ID saveID .)
    SUBPROCEDURE    reduce using rule 55 (N -> ID saveID .)
    END             reduce using rule 55 (N -> ID saveID .)
    RETURN          reduce using rule 55 (N -> ID saveID .)
    UNTIL           reduce using rule 55 (N -> ID saveID .)
    ELSE            reduce using rule 55 (N -> ID saveID .)
    EIF             reduce using rule 55 (N -> ID saveID .)
    WEND            reduce using rule 55 (N -> ID saveID .)
    NEXT            reduce using rule 55 (N -> ID saveID .)
    GREATHER        reduce using rule 55 (N -> ID saveID .)
    GREATHEREQUAL   reduce using rule 55 (N -> ID saveID .)
    SMALLER         reduce using rule 55 (N -> ID saveID .)
    SMALLEREQUAL    reduce using rule 55 (N -> ID saveID .)
    NOTEQUAL        reduce using rule 55 (N -> ID saveID .)
    EQUALTO         reduce using rule 55 (N -> ID saveID .)
    error           reduce using rule 55 (N -> ID saveID .)
    CLOSINGPAR      reduce using rule 55 (N -> ID saveID .)
    TO              reduce using rule 55 (N -> ID saveID .)
    CLOSINGBRACKET  reduce using rule 55 (N -> ID saveID .)
    DO              reduce using rule 55 (N -> ID saveID .)


state 65

    (57) N -> ID OPENBRACKET . INTVAL CLOSINGBRACKET
    (58) N -> ID OPENBRACKET . setType Idv CLOSINGBRACKET
    (40) setType -> .

    INTVAL          shift and go to state 93
    ID              reduce using rule 40 (setType -> .)

    setType                        shift and go to state 94

state 66

    (51) P -> P MULTIPLY . N
    (54) N -> . cte saveID
    (55) N -> . ID saveID
    (56) N -> . OPENPAR EA CLOSINGPAR
    (57) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (58) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (60) cte -> . INTVAL
    (61) cte -> . FLOATVAL

    ID              shift and go to state 84
    OPENPAR         shift and go to state 86
    INTVAL          shift and go to state 47
    FLOATVAL        shift and go to state 48

    N                              shift and go to state 95
    cte                            shift and go to state 46

state 67

    (52) P -> P DIVIDE . N
    (54) N -> . cte saveID
    (55) N -> . ID saveID
    (56) N -> . OPENPAR EA CLOSINGPAR
    (57) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (58) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (60) cte -> . INTVAL
    (61) cte -> . FLOATVAL

    ID              shift and go to state 84
    OPENPAR         shift and go to state 86
    INTVAL          shift and go to state 47
    FLOATVAL        shift and go to state 48

    N                              shift and go to state 96
    cte                            shift and go to state 46

state 68

    (56) N -> OPENPAR EA . CLOSINGPAR
    (48) EA -> EA . PLUS P
    (49) EA -> EA . MINUS P
    (43) Ex -> EA .

    CLOSINGPAR      shift and go to state 97
    PLUS            shift and go to state 62
    MINUS           shift and go to state 63
    GREATHER        reduce using rule 43 (Ex -> EA .)
    GREATHEREQUAL   reduce using rule 43 (Ex -> EA .)
    SMALLER         reduce using rule 43 (Ex -> EA .)
    SMALLEREQUAL    reduce using rule 43 (Ex -> EA .)
    NOTEQUAL        reduce using rule 43 (Ex -> EA .)
    EQUALTO         reduce using rule 43 (Ex -> EA .)
    error           reduce using rule 43 (Ex -> EA .)


state 69

    (54) N -> cte saveID .

    MULTIPLY        reduce using rule 54 (N -> cte saveID .)
    DIVIDE          reduce using rule 54 (N -> cte saveID .)
    PLUS            reduce using rule 54 (N -> cte saveID .)
    MINUS           reduce using rule 54 (N -> cte saveID .)
    LET             reduce using rule 54 (N -> cte saveID .)
    DIM             reduce using rule 54 (N -> cte saveID .)
    IF              reduce using rule 54 (N -> cte saveID .)
    FOR             reduce using rule 54 (N -> cte saveID .)
    WHILE           reduce using rule 54 (N -> cte saveID .)
    REPEAT          reduce using rule 54 (N -> cte saveID .)
    GOSUB           reduce using rule 54 (N -> cte saveID .)
    INPUT           reduce using rule 54 (N -> cte saveID .)
    PRINT           reduce using rule 54 (N -> cte saveID .)
    SUBPROCEDURE    reduce using rule 54 (N -> cte saveID .)
    END             reduce using rule 54 (N -> cte saveID .)
    RETURN          reduce using rule 54 (N -> cte saveID .)
    UNTIL           reduce using rule 54 (N -> cte saveID .)
    ELSE            reduce using rule 54 (N -> cte saveID .)
    EIF             reduce using rule 54 (N -> cte saveID .)
    WEND            reduce using rule 54 (N -> cte saveID .)
    NEXT            reduce using rule 54 (N -> cte saveID .)
    GREATHER        reduce using rule 54 (N -> cte saveID .)
    GREATHEREQUAL   reduce using rule 54 (N -> cte saveID .)
    SMALLER         reduce using rule 54 (N -> cte saveID .)
    SMALLEREQUAL    reduce using rule 54 (N -> cte saveID .)
    NOTEQUAL        reduce using rule 54 (N -> cte saveID .)
    EQUALTO         reduce using rule 54 (N -> cte saveID .)
    error           reduce using rule 54 (N -> cte saveID .)
    CLOSINGPAR      reduce using rule 54 (N -> cte saveID .)
    TO              reduce using rule 54 (N -> cte saveID .)
    CLOSINGBRACKET  reduce using rule 54 (N -> cte saveID .)
    DO              reduce using rule 54 (N -> cte saveID .)


state 70

    (2) V -> DIM setType Idv AS . T Arr
    (7) T -> . INT
    (8) T -> . FLOAT
    (9) T -> . WORD

    INT             shift and go to state 99
    FLOAT           shift and go to state 100
    WORD            shift and go to state 101

    T                              shift and go to state 98

state 71

    (38) Idv -> ID COMA . Idv
    (38) Idv -> . ID COMA Idv
    (39) Idv -> . ID

    ID              shift and go to state 50

    Idv                            shift and go to state 102

state 72

    (10) S -> SUBPROCEDURE ID TWOPOINTS . M RETURN S
    (12) M -> . F M
    (13) M -> . empty
    (14) F -> . E F
    (15) F -> . empty
    (76) empty -> .
    (16) E -> . LET setType Idv EQUALS Ex
    (17) E -> . DIM setType Idv AS T Arr
    (18) E -> . IF EL THEN first_conditional F Esf EIF final_conditional
    (19) E -> . FOR ID EQUALS EA for_assignation TO Ex for_conditional DO for_save_conditional F NEXT ID for_conditional_end
    (20) E -> . WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional
    (21) E -> . REPEAT while_first_conditional F UNTIL EL repeat_conditional
    (22) E -> . GOSUB ID
    (23) E -> . INPUT ES COMA IDEx
    (24) E -> . PRINT Ex

  ! shift/reduce conflict for LET resolved as shift
  ! shift/reduce conflict for DIM resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for REPEAT resolved as shift
  ! shift/reduce conflict for GOSUB resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
    RETURN          reduce using rule 76 (empty -> .)
    LET             shift and go to state 10
    DIM             shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    REPEAT          shift and go to state 15
    GOSUB           shift and go to state 16
    INPUT           shift and go to state 17
    PRINT           shift and go to state 18

  ! LET             [ reduce using rule 76 (empty -> .) ]
  ! DIM             [ reduce using rule 76 (empty -> .) ]
  ! IF              [ reduce using rule 76 (empty -> .) ]
  ! FOR             [ reduce using rule 76 (empty -> .) ]
  ! WHILE           [ reduce using rule 76 (empty -> .) ]
  ! REPEAT          [ reduce using rule 76 (empty -> .) ]
  ! GOSUB           [ reduce using rule 76 (empty -> .) ]
  ! INPUT           [ reduce using rule 76 (empty -> .) ]
  ! PRINT           [ reduce using rule 76 (empty -> .) ]

    M                              shift and go to state 103
    F                              shift and go to state 7
    empty                          shift and go to state 8
    E                              shift and go to state 9

state 73

    (16) E -> LET setType Idv EQUALS . Ex
    (43) Ex -> . EA
    (44) Ex -> . ES
    (45) Ex -> . EL
    (46) Ex -> . ID
    (48) EA -> . EA PLUS P
    (49) EA -> . EA MINUS P
    (50) EA -> . P
    (47) ES -> . WORDVAL
    (62) EL -> . TRUE
    (63) EL -> . FALSE
    (64) EL -> . OPENPAR O CLOSINGPAR
    (65) EL -> . OPENPAR O CLOSINGPAR OL EL
    (51) P -> . P MULTIPLY N
    (52) P -> . P DIVIDE N
    (53) P -> . N
    (54) N -> . cte saveID
    (55) N -> . ID saveID
    (56) N -> . OPENPAR EA CLOSINGPAR
    (57) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (58) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (60) cte -> . INTVAL
    (61) cte -> . FLOATVAL

    ID              shift and go to state 42
    WORDVAL         shift and go to state 37
    TRUE            shift and go to state 29
    FALSE           shift and go to state 30
    OPENPAR         shift and go to state 44
    INTVAL          shift and go to state 47
    FLOATVAL        shift and go to state 48

    Ex                             shift and go to state 104
    EA                             shift and go to state 39
    ES                             shift and go to state 40
    EL                             shift and go to state 41
    P                              shift and go to state 43
    N                              shift and go to state 45
    cte                            shift and go to state 46

state 74

    (17) E -> DIM setType Idv AS . T Arr
    (7) T -> . INT
    (8) T -> . FLOAT
    (9) T -> . WORD

    INT             shift and go to state 99
    FLOAT           shift and go to state 100
    WORD            shift and go to state 101

    T                              shift and go to state 105

state 75

    (18) E -> IF EL THEN first_conditional . F Esf EIF final_conditional
    (14) F -> . E F
    (15) F -> . empty
    (16) E -> . LET setType Idv EQUALS Ex
    (17) E -> . DIM setType Idv AS T Arr
    (18) E -> . IF EL THEN first_conditional F Esf EIF final_conditional
    (19) E -> . FOR ID EQUALS EA for_assignation TO Ex for_conditional DO for_save_conditional F NEXT ID for_conditional_end
    (20) E -> . WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional
    (21) E -> . REPEAT while_first_conditional F UNTIL EL repeat_conditional
    (22) E -> . GOSUB ID
    (23) E -> . INPUT ES COMA IDEx
    (24) E -> . PRINT Ex
    (76) empty -> .

    LET             shift and go to state 10
    DIM             shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    REPEAT          shift and go to state 15
    GOSUB           shift and go to state 16
    INPUT           shift and go to state 17
    PRINT           shift and go to state 18
    ELSE            reduce using rule 76 (empty -> .)
    EIF             reduce using rule 76 (empty -> .)

    F                              shift and go to state 106
    E                              shift and go to state 9
    empty                          shift and go to state 25

state 76

    (64) EL -> OPENPAR O CLOSINGPAR .
    (65) EL -> OPENPAR O CLOSINGPAR . OL EL
    (66) OL -> . AND
    (67) OL -> . OR
    (68) OL -> . NOT

    THEN            reduce using rule 64 (EL -> OPENPAR O CLOSINGPAR .)
    LET             reduce using rule 64 (EL -> OPENPAR O CLOSINGPAR .)
    DIM             reduce using rule 64 (EL -> OPENPAR O CLOSINGPAR .)
    IF              reduce using rule 64 (EL -> OPENPAR O CLOSINGPAR .)
    FOR             reduce using rule 64 (EL -> OPENPAR O CLOSINGPAR .)
    WHILE           reduce using rule 64 (EL -> OPENPAR O CLOSINGPAR .)
    REPEAT          reduce using rule 64 (EL -> OPENPAR O CLOSINGPAR .)
    GOSUB           reduce using rule 64 (EL -> OPENPAR O CLOSINGPAR .)
    INPUT           reduce using rule 64 (EL -> OPENPAR O CLOSINGPAR .)
    PRINT           reduce using rule 64 (EL -> OPENPAR O CLOSINGPAR .)
    SUBPROCEDURE    reduce using rule 64 (EL -> OPENPAR O CLOSINGPAR .)
    END             reduce using rule 64 (EL -> OPENPAR O CLOSINGPAR .)
    RETURN          reduce using rule 64 (EL -> OPENPAR O CLOSINGPAR .)
    UNTIL           reduce using rule 64 (EL -> OPENPAR O CLOSINGPAR .)
    ELSE            reduce using rule 64 (EL -> OPENPAR O CLOSINGPAR .)
    EIF             reduce using rule 64 (EL -> OPENPAR O CLOSINGPAR .)
    WEND            reduce using rule 64 (EL -> OPENPAR O CLOSINGPAR .)
    NEXT            reduce using rule 64 (EL -> OPENPAR O CLOSINGPAR .)
    GREATHER        reduce using rule 64 (EL -> OPENPAR O CLOSINGPAR .)
    GREATHEREQUAL   reduce using rule 64 (EL -> OPENPAR O CLOSINGPAR .)
    SMALLER         reduce using rule 64 (EL -> OPENPAR O CLOSINGPAR .)
    SMALLEREQUAL    reduce using rule 64 (EL -> OPENPAR O CLOSINGPAR .)
    NOTEQUAL        reduce using rule 64 (EL -> OPENPAR O CLOSINGPAR .)
    EQUALTO         reduce using rule 64 (EL -> OPENPAR O CLOSINGPAR .)
    error           reduce using rule 64 (EL -> OPENPAR O CLOSINGPAR .)
    DO              reduce using rule 64 (EL -> OPENPAR O CLOSINGPAR .)
    CLOSINGPAR      reduce using rule 64 (EL -> OPENPAR O CLOSINGPAR .)
    AND             shift and go to state 108
    OR              shift and go to state 109
    NOT             shift and go to state 110

    OL                             shift and go to state 107

state 77

    (69) O -> Ex GREATHER . Ex
    (43) Ex -> . EA
    (44) Ex -> . ES
    (45) Ex -> . EL
    (46) Ex -> . ID
    (48) EA -> . EA PLUS P
    (49) EA -> . EA MINUS P
    (50) EA -> . P
    (47) ES -> . WORDVAL
    (62) EL -> . TRUE
    (63) EL -> . FALSE
    (64) EL -> . OPENPAR O CLOSINGPAR
    (65) EL -> . OPENPAR O CLOSINGPAR OL EL
    (51) P -> . P MULTIPLY N
    (52) P -> . P DIVIDE N
    (53) P -> . N
    (54) N -> . cte saveID
    (55) N -> . ID saveID
    (56) N -> . OPENPAR EA CLOSINGPAR
    (57) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (58) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (60) cte -> . INTVAL
    (61) cte -> . FLOATVAL

    ID              shift and go to state 42
    WORDVAL         shift and go to state 37
    TRUE            shift and go to state 29
    FALSE           shift and go to state 30
    OPENPAR         shift and go to state 44
    INTVAL          shift and go to state 47
    FLOATVAL        shift and go to state 48

    Ex                             shift and go to state 111
    EA                             shift and go to state 39
    ES                             shift and go to state 40
    EL                             shift and go to state 41
    P                              shift and go to state 43
    N                              shift and go to state 45
    cte                            shift and go to state 46

state 78

    (70) O -> Ex GREATHEREQUAL . Ex
    (43) Ex -> . EA
    (44) Ex -> . ES
    (45) Ex -> . EL
    (46) Ex -> . ID
    (48) EA -> . EA PLUS P
    (49) EA -> . EA MINUS P
    (50) EA -> . P
    (47) ES -> . WORDVAL
    (62) EL -> . TRUE
    (63) EL -> . FALSE
    (64) EL -> . OPENPAR O CLOSINGPAR
    (65) EL -> . OPENPAR O CLOSINGPAR OL EL
    (51) P -> . P MULTIPLY N
    (52) P -> . P DIVIDE N
    (53) P -> . N
    (54) N -> . cte saveID
    (55) N -> . ID saveID
    (56) N -> . OPENPAR EA CLOSINGPAR
    (57) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (58) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (60) cte -> . INTVAL
    (61) cte -> . FLOATVAL

    ID              shift and go to state 42
    WORDVAL         shift and go to state 37
    TRUE            shift and go to state 29
    FALSE           shift and go to state 30
    OPENPAR         shift and go to state 44
    INTVAL          shift and go to state 47
    FLOATVAL        shift and go to state 48

    Ex                             shift and go to state 112
    EA                             shift and go to state 39
    ES                             shift and go to state 40
    EL                             shift and go to state 41
    P                              shift and go to state 43
    N                              shift and go to state 45
    cte                            shift and go to state 46

state 79

    (71) O -> Ex SMALLER . Ex
    (43) Ex -> . EA
    (44) Ex -> . ES
    (45) Ex -> . EL
    (46) Ex -> . ID
    (48) EA -> . EA PLUS P
    (49) EA -> . EA MINUS P
    (50) EA -> . P
    (47) ES -> . WORDVAL
    (62) EL -> . TRUE
    (63) EL -> . FALSE
    (64) EL -> . OPENPAR O CLOSINGPAR
    (65) EL -> . OPENPAR O CLOSINGPAR OL EL
    (51) P -> . P MULTIPLY N
    (52) P -> . P DIVIDE N
    (53) P -> . N
    (54) N -> . cte saveID
    (55) N -> . ID saveID
    (56) N -> . OPENPAR EA CLOSINGPAR
    (57) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (58) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (60) cte -> . INTVAL
    (61) cte -> . FLOATVAL

    ID              shift and go to state 42
    WORDVAL         shift and go to state 37
    TRUE            shift and go to state 29
    FALSE           shift and go to state 30
    OPENPAR         shift and go to state 44
    INTVAL          shift and go to state 47
    FLOATVAL        shift and go to state 48

    Ex                             shift and go to state 113
    EA                             shift and go to state 39
    ES                             shift and go to state 40
    EL                             shift and go to state 41
    P                              shift and go to state 43
    N                              shift and go to state 45
    cte                            shift and go to state 46

state 80

    (72) O -> Ex SMALLEREQUAL . Ex
    (43) Ex -> . EA
    (44) Ex -> . ES
    (45) Ex -> . EL
    (46) Ex -> . ID
    (48) EA -> . EA PLUS P
    (49) EA -> . EA MINUS P
    (50) EA -> . P
    (47) ES -> . WORDVAL
    (62) EL -> . TRUE
    (63) EL -> . FALSE
    (64) EL -> . OPENPAR O CLOSINGPAR
    (65) EL -> . OPENPAR O CLOSINGPAR OL EL
    (51) P -> . P MULTIPLY N
    (52) P -> . P DIVIDE N
    (53) P -> . N
    (54) N -> . cte saveID
    (55) N -> . ID saveID
    (56) N -> . OPENPAR EA CLOSINGPAR
    (57) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (58) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (60) cte -> . INTVAL
    (61) cte -> . FLOATVAL

    ID              shift and go to state 42
    WORDVAL         shift and go to state 37
    TRUE            shift and go to state 29
    FALSE           shift and go to state 30
    OPENPAR         shift and go to state 44
    INTVAL          shift and go to state 47
    FLOATVAL        shift and go to state 48

    Ex                             shift and go to state 114
    EA                             shift and go to state 39
    ES                             shift and go to state 40
    EL                             shift and go to state 41
    P                              shift and go to state 43
    N                              shift and go to state 45
    cte                            shift and go to state 46

state 81

    (73) O -> Ex NOTEQUAL . Ex
    (43) Ex -> . EA
    (44) Ex -> . ES
    (45) Ex -> . EL
    (46) Ex -> . ID
    (48) EA -> . EA PLUS P
    (49) EA -> . EA MINUS P
    (50) EA -> . P
    (47) ES -> . WORDVAL
    (62) EL -> . TRUE
    (63) EL -> . FALSE
    (64) EL -> . OPENPAR O CLOSINGPAR
    (65) EL -> . OPENPAR O CLOSINGPAR OL EL
    (51) P -> . P MULTIPLY N
    (52) P -> . P DIVIDE N
    (53) P -> . N
    (54) N -> . cte saveID
    (55) N -> . ID saveID
    (56) N -> . OPENPAR EA CLOSINGPAR
    (57) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (58) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (60) cte -> . INTVAL
    (61) cte -> . FLOATVAL

    ID              shift and go to state 42
    WORDVAL         shift and go to state 37
    TRUE            shift and go to state 29
    FALSE           shift and go to state 30
    OPENPAR         shift and go to state 44
    INTVAL          shift and go to state 47
    FLOATVAL        shift and go to state 48

    Ex                             shift and go to state 115
    EA                             shift and go to state 39
    ES                             shift and go to state 40
    EL                             shift and go to state 41
    P                              shift and go to state 43
    N                              shift and go to state 45
    cte                            shift and go to state 46

state 82

    (74) O -> Ex EQUALTO . Ex
    (43) Ex -> . EA
    (44) Ex -> . ES
    (45) Ex -> . EL
    (46) Ex -> . ID
    (48) EA -> . EA PLUS P
    (49) EA -> . EA MINUS P
    (50) EA -> . P
    (47) ES -> . WORDVAL
    (62) EL -> . TRUE
    (63) EL -> . FALSE
    (64) EL -> . OPENPAR O CLOSINGPAR
    (65) EL -> . OPENPAR O CLOSINGPAR OL EL
    (51) P -> . P MULTIPLY N
    (52) P -> . P DIVIDE N
    (53) P -> . N
    (54) N -> . cte saveID
    (55) N -> . ID saveID
    (56) N -> . OPENPAR EA CLOSINGPAR
    (57) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (58) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (60) cte -> . INTVAL
    (61) cte -> . FLOATVAL

    ID              shift and go to state 42
    WORDVAL         shift and go to state 37
    TRUE            shift and go to state 29
    FALSE           shift and go to state 30
    OPENPAR         shift and go to state 44
    INTVAL          shift and go to state 47
    FLOATVAL        shift and go to state 48

    Ex                             shift and go to state 116
    EA                             shift and go to state 39
    ES                             shift and go to state 40
    EL                             shift and go to state 41
    P                              shift and go to state 43
    N                              shift and go to state 45
    cte                            shift and go to state 46

state 83

    (75) O -> Ex error . Ex
    (43) Ex -> . EA
    (44) Ex -> . ES
    (45) Ex -> . EL
    (46) Ex -> . ID
    (48) EA -> . EA PLUS P
    (49) EA -> . EA MINUS P
    (50) EA -> . P
    (47) ES -> . WORDVAL
    (62) EL -> . TRUE
    (63) EL -> . FALSE
    (64) EL -> . OPENPAR O CLOSINGPAR
    (65) EL -> . OPENPAR O CLOSINGPAR OL EL
    (51) P -> . P MULTIPLY N
    (52) P -> . P DIVIDE N
    (53) P -> . N
    (54) N -> . cte saveID
    (55) N -> . ID saveID
    (56) N -> . OPENPAR EA CLOSINGPAR
    (57) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (58) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (60) cte -> . INTVAL
    (61) cte -> . FLOATVAL

    ID              shift and go to state 42
    WORDVAL         shift and go to state 37
    TRUE            shift and go to state 29
    FALSE           shift and go to state 30
    OPENPAR         shift and go to state 44
    INTVAL          shift and go to state 47
    FLOATVAL        shift and go to state 48

    Ex                             shift and go to state 117
    EA                             shift and go to state 39
    ES                             shift and go to state 40
    EL                             shift and go to state 41
    P                              shift and go to state 43
    N                              shift and go to state 45
    cte                            shift and go to state 46

state 84

    (55) N -> ID . saveID
    (57) N -> ID . OPENBRACKET INTVAL CLOSINGBRACKET
    (58) N -> ID . OPENBRACKET setType Idv CLOSINGBRACKET
    (59) saveID -> .

    OPENBRACKET     shift and go to state 65
    MULTIPLY        reduce using rule 59 (saveID -> .)
    DIVIDE          reduce using rule 59 (saveID -> .)
    PLUS            reduce using rule 59 (saveID -> .)
    MINUS           reduce using rule 59 (saveID -> .)
    TO              reduce using rule 59 (saveID -> .)
    LET             reduce using rule 59 (saveID -> .)
    DIM             reduce using rule 59 (saveID -> .)
    IF              reduce using rule 59 (saveID -> .)
    FOR             reduce using rule 59 (saveID -> .)
    WHILE           reduce using rule 59 (saveID -> .)
    REPEAT          reduce using rule 59 (saveID -> .)
    GOSUB           reduce using rule 59 (saveID -> .)
    INPUT           reduce using rule 59 (saveID -> .)
    PRINT           reduce using rule 59 (saveID -> .)
    SUBPROCEDURE    reduce using rule 59 (saveID -> .)
    END             reduce using rule 59 (saveID -> .)
    RETURN          reduce using rule 59 (saveID -> .)
    UNTIL           reduce using rule 59 (saveID -> .)
    ELSE            reduce using rule 59 (saveID -> .)
    EIF             reduce using rule 59 (saveID -> .)
    WEND            reduce using rule 59 (saveID -> .)
    NEXT            reduce using rule 59 (saveID -> .)
    GREATHER        reduce using rule 59 (saveID -> .)
    GREATHEREQUAL   reduce using rule 59 (saveID -> .)
    SMALLER         reduce using rule 59 (saveID -> .)
    SMALLEREQUAL    reduce using rule 59 (saveID -> .)
    NOTEQUAL        reduce using rule 59 (saveID -> .)
    EQUALTO         reduce using rule 59 (saveID -> .)
    error           reduce using rule 59 (saveID -> .)
    CLOSINGPAR      reduce using rule 59 (saveID -> .)
    CLOSINGBRACKET  reduce using rule 59 (saveID -> .)
    DO              reduce using rule 59 (saveID -> .)

    saveID                         shift and go to state 64

state 85

    (19) E -> FOR ID EQUALS EA . for_assignation TO Ex for_conditional DO for_save_conditional F NEXT ID for_conditional_end
    (48) EA -> EA . PLUS P
    (49) EA -> EA . MINUS P
    (25) for_assignation -> .

    PLUS            shift and go to state 62
    MINUS           shift and go to state 63
    TO              reduce using rule 25 (for_assignation -> .)

    for_assignation                shift and go to state 118

state 86

    (56) N -> OPENPAR . EA CLOSINGPAR
    (48) EA -> . EA PLUS P
    (49) EA -> . EA MINUS P
    (50) EA -> . P
    (51) P -> . P MULTIPLY N
    (52) P -> . P DIVIDE N
    (53) P -> . N
    (54) N -> . cte saveID
    (55) N -> . ID saveID
    (56) N -> . OPENPAR EA CLOSINGPAR
    (57) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (58) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (60) cte -> . INTVAL
    (61) cte -> . FLOATVAL

    ID              shift and go to state 84
    OPENPAR         shift and go to state 86
    INTVAL          shift and go to state 47
    FLOATVAL        shift and go to state 48

    EA                             shift and go to state 119
    P                              shift and go to state 43
    N                              shift and go to state 45
    cte                            shift and go to state 46

state 87

    (20) E -> WHILE while_first_conditional EL DO . while_second_conditional F WEND while_final_conditional
    (31) while_second_conditional -> .

    LET             reduce using rule 31 (while_second_conditional -> .)
    DIM             reduce using rule 31 (while_second_conditional -> .)
    IF              reduce using rule 31 (while_second_conditional -> .)
    FOR             reduce using rule 31 (while_second_conditional -> .)
    WHILE           reduce using rule 31 (while_second_conditional -> .)
    REPEAT          reduce using rule 31 (while_second_conditional -> .)
    GOSUB           reduce using rule 31 (while_second_conditional -> .)
    INPUT           reduce using rule 31 (while_second_conditional -> .)
    PRINT           reduce using rule 31 (while_second_conditional -> .)
    WEND            reduce using rule 31 (while_second_conditional -> .)

    while_second_conditional       shift and go to state 120

state 88

    (21) E -> REPEAT while_first_conditional F UNTIL . EL repeat_conditional
    (62) EL -> . TRUE
    (63) EL -> . FALSE
    (64) EL -> . OPENPAR O CLOSINGPAR
    (65) EL -> . OPENPAR O CLOSINGPAR OL EL

    TRUE            shift and go to state 29
    FALSE           shift and go to state 30
    OPENPAR         shift and go to state 31

    EL                             shift and go to state 121

state 89

    (23) E -> INPUT ES COMA IDEx .

    LET             reduce using rule 23 (E -> INPUT ES COMA IDEx .)
    DIM             reduce using rule 23 (E -> INPUT ES COMA IDEx .)
    IF              reduce using rule 23 (E -> INPUT ES COMA IDEx .)
    FOR             reduce using rule 23 (E -> INPUT ES COMA IDEx .)
    WHILE           reduce using rule 23 (E -> INPUT ES COMA IDEx .)
    REPEAT          reduce using rule 23 (E -> INPUT ES COMA IDEx .)
    GOSUB           reduce using rule 23 (E -> INPUT ES COMA IDEx .)
    INPUT           reduce using rule 23 (E -> INPUT ES COMA IDEx .)
    PRINT           reduce using rule 23 (E -> INPUT ES COMA IDEx .)
    SUBPROCEDURE    reduce using rule 23 (E -> INPUT ES COMA IDEx .)
    END             reduce using rule 23 (E -> INPUT ES COMA IDEx .)
    RETURN          reduce using rule 23 (E -> INPUT ES COMA IDEx .)
    UNTIL           reduce using rule 23 (E -> INPUT ES COMA IDEx .)
    ELSE            reduce using rule 23 (E -> INPUT ES COMA IDEx .)
    EIF             reduce using rule 23 (E -> INPUT ES COMA IDEx .)
    WEND            reduce using rule 23 (E -> INPUT ES COMA IDEx .)
    NEXT            reduce using rule 23 (E -> INPUT ES COMA IDEx .)


state 90

    (41) IDEx -> ID .
    (42) IDEx -> ID . OPENBRACKET setType Idv CLOSINGBRACKET

    LET             reduce using rule 41 (IDEx -> ID .)
    DIM             reduce using rule 41 (IDEx -> ID .)
    IF              reduce using rule 41 (IDEx -> ID .)
    FOR             reduce using rule 41 (IDEx -> ID .)
    WHILE           reduce using rule 41 (IDEx -> ID .)
    REPEAT          reduce using rule 41 (IDEx -> ID .)
    GOSUB           reduce using rule 41 (IDEx -> ID .)
    INPUT           reduce using rule 41 (IDEx -> ID .)
    PRINT           reduce using rule 41 (IDEx -> ID .)
    SUBPROCEDURE    reduce using rule 41 (IDEx -> ID .)
    END             reduce using rule 41 (IDEx -> ID .)
    RETURN          reduce using rule 41 (IDEx -> ID .)
    UNTIL           reduce using rule 41 (IDEx -> ID .)
    ELSE            reduce using rule 41 (IDEx -> ID .)
    EIF             reduce using rule 41 (IDEx -> ID .)
    WEND            reduce using rule 41 (IDEx -> ID .)
    NEXT            reduce using rule 41 (IDEx -> ID .)
    OPENBRACKET     shift and go to state 122


state 91

    (48) EA -> EA PLUS P .
    (51) P -> P . MULTIPLY N
    (52) P -> P . DIVIDE N

    PLUS            reduce using rule 48 (EA -> EA PLUS P .)
    MINUS           reduce using rule 48 (EA -> EA PLUS P .)
    LET             reduce using rule 48 (EA -> EA PLUS P .)
    DIM             reduce using rule 48 (EA -> EA PLUS P .)
    IF              reduce using rule 48 (EA -> EA PLUS P .)
    FOR             reduce using rule 48 (EA -> EA PLUS P .)
    WHILE           reduce using rule 48 (EA -> EA PLUS P .)
    REPEAT          reduce using rule 48 (EA -> EA PLUS P .)
    GOSUB           reduce using rule 48 (EA -> EA PLUS P .)
    INPUT           reduce using rule 48 (EA -> EA PLUS P .)
    PRINT           reduce using rule 48 (EA -> EA PLUS P .)
    SUBPROCEDURE    reduce using rule 48 (EA -> EA PLUS P .)
    END             reduce using rule 48 (EA -> EA PLUS P .)
    RETURN          reduce using rule 48 (EA -> EA PLUS P .)
    UNTIL           reduce using rule 48 (EA -> EA PLUS P .)
    ELSE            reduce using rule 48 (EA -> EA PLUS P .)
    EIF             reduce using rule 48 (EA -> EA PLUS P .)
    WEND            reduce using rule 48 (EA -> EA PLUS P .)
    NEXT            reduce using rule 48 (EA -> EA PLUS P .)
    GREATHER        reduce using rule 48 (EA -> EA PLUS P .)
    GREATHEREQUAL   reduce using rule 48 (EA -> EA PLUS P .)
    SMALLER         reduce using rule 48 (EA -> EA PLUS P .)
    SMALLEREQUAL    reduce using rule 48 (EA -> EA PLUS P .)
    NOTEQUAL        reduce using rule 48 (EA -> EA PLUS P .)
    EQUALTO         reduce using rule 48 (EA -> EA PLUS P .)
    error           reduce using rule 48 (EA -> EA PLUS P .)
    CLOSINGPAR      reduce using rule 48 (EA -> EA PLUS P .)
    TO              reduce using rule 48 (EA -> EA PLUS P .)
    CLOSINGBRACKET  reduce using rule 48 (EA -> EA PLUS P .)
    DO              reduce using rule 48 (EA -> EA PLUS P .)
    MULTIPLY        shift and go to state 66
    DIVIDE          shift and go to state 67


state 92

    (49) EA -> EA MINUS P .
    (51) P -> P . MULTIPLY N
    (52) P -> P . DIVIDE N

    PLUS            reduce using rule 49 (EA -> EA MINUS P .)
    MINUS           reduce using rule 49 (EA -> EA MINUS P .)
    LET             reduce using rule 49 (EA -> EA MINUS P .)
    DIM             reduce using rule 49 (EA -> EA MINUS P .)
    IF              reduce using rule 49 (EA -> EA MINUS P .)
    FOR             reduce using rule 49 (EA -> EA MINUS P .)
    WHILE           reduce using rule 49 (EA -> EA MINUS P .)
    REPEAT          reduce using rule 49 (EA -> EA MINUS P .)
    GOSUB           reduce using rule 49 (EA -> EA MINUS P .)
    INPUT           reduce using rule 49 (EA -> EA MINUS P .)
    PRINT           reduce using rule 49 (EA -> EA MINUS P .)
    SUBPROCEDURE    reduce using rule 49 (EA -> EA MINUS P .)
    END             reduce using rule 49 (EA -> EA MINUS P .)
    RETURN          reduce using rule 49 (EA -> EA MINUS P .)
    UNTIL           reduce using rule 49 (EA -> EA MINUS P .)
    ELSE            reduce using rule 49 (EA -> EA MINUS P .)
    EIF             reduce using rule 49 (EA -> EA MINUS P .)
    WEND            reduce using rule 49 (EA -> EA MINUS P .)
    NEXT            reduce using rule 49 (EA -> EA MINUS P .)
    GREATHER        reduce using rule 49 (EA -> EA MINUS P .)
    GREATHEREQUAL   reduce using rule 49 (EA -> EA MINUS P .)
    SMALLER         reduce using rule 49 (EA -> EA MINUS P .)
    SMALLEREQUAL    reduce using rule 49 (EA -> EA MINUS P .)
    NOTEQUAL        reduce using rule 49 (EA -> EA MINUS P .)
    EQUALTO         reduce using rule 49 (EA -> EA MINUS P .)
    error           reduce using rule 49 (EA -> EA MINUS P .)
    CLOSINGPAR      reduce using rule 49 (EA -> EA MINUS P .)
    TO              reduce using rule 49 (EA -> EA MINUS P .)
    CLOSINGBRACKET  reduce using rule 49 (EA -> EA MINUS P .)
    DO              reduce using rule 49 (EA -> EA MINUS P .)
    MULTIPLY        shift and go to state 66
    DIVIDE          shift and go to state 67


state 93

    (57) N -> ID OPENBRACKET INTVAL . CLOSINGBRACKET

    CLOSINGBRACKET  shift and go to state 123


state 94

    (58) N -> ID OPENBRACKET setType . Idv CLOSINGBRACKET
    (38) Idv -> . ID COMA Idv
    (39) Idv -> . ID

    ID              shift and go to state 50

    Idv                            shift and go to state 124

state 95

    (51) P -> P MULTIPLY N .

    MULTIPLY        reduce using rule 51 (P -> P MULTIPLY N .)
    DIVIDE          reduce using rule 51 (P -> P MULTIPLY N .)
    PLUS            reduce using rule 51 (P -> P MULTIPLY N .)
    MINUS           reduce using rule 51 (P -> P MULTIPLY N .)
    LET             reduce using rule 51 (P -> P MULTIPLY N .)
    DIM             reduce using rule 51 (P -> P MULTIPLY N .)
    IF              reduce using rule 51 (P -> P MULTIPLY N .)
    FOR             reduce using rule 51 (P -> P MULTIPLY N .)
    WHILE           reduce using rule 51 (P -> P MULTIPLY N .)
    REPEAT          reduce using rule 51 (P -> P MULTIPLY N .)
    GOSUB           reduce using rule 51 (P -> P MULTIPLY N .)
    INPUT           reduce using rule 51 (P -> P MULTIPLY N .)
    PRINT           reduce using rule 51 (P -> P MULTIPLY N .)
    SUBPROCEDURE    reduce using rule 51 (P -> P MULTIPLY N .)
    END             reduce using rule 51 (P -> P MULTIPLY N .)
    RETURN          reduce using rule 51 (P -> P MULTIPLY N .)
    UNTIL           reduce using rule 51 (P -> P MULTIPLY N .)
    ELSE            reduce using rule 51 (P -> P MULTIPLY N .)
    EIF             reduce using rule 51 (P -> P MULTIPLY N .)
    WEND            reduce using rule 51 (P -> P MULTIPLY N .)
    NEXT            reduce using rule 51 (P -> P MULTIPLY N .)
    GREATHER        reduce using rule 51 (P -> P MULTIPLY N .)
    GREATHEREQUAL   reduce using rule 51 (P -> P MULTIPLY N .)
    SMALLER         reduce using rule 51 (P -> P MULTIPLY N .)
    SMALLEREQUAL    reduce using rule 51 (P -> P MULTIPLY N .)
    NOTEQUAL        reduce using rule 51 (P -> P MULTIPLY N .)
    EQUALTO         reduce using rule 51 (P -> P MULTIPLY N .)
    error           reduce using rule 51 (P -> P MULTIPLY N .)
    CLOSINGPAR      reduce using rule 51 (P -> P MULTIPLY N .)
    TO              reduce using rule 51 (P -> P MULTIPLY N .)
    CLOSINGBRACKET  reduce using rule 51 (P -> P MULTIPLY N .)
    DO              reduce using rule 51 (P -> P MULTIPLY N .)


state 96

    (52) P -> P DIVIDE N .

    MULTIPLY        reduce using rule 52 (P -> P DIVIDE N .)
    DIVIDE          reduce using rule 52 (P -> P DIVIDE N .)
    PLUS            reduce using rule 52 (P -> P DIVIDE N .)
    MINUS           reduce using rule 52 (P -> P DIVIDE N .)
    LET             reduce using rule 52 (P -> P DIVIDE N .)
    DIM             reduce using rule 52 (P -> P DIVIDE N .)
    IF              reduce using rule 52 (P -> P DIVIDE N .)
    FOR             reduce using rule 52 (P -> P DIVIDE N .)
    WHILE           reduce using rule 52 (P -> P DIVIDE N .)
    REPEAT          reduce using rule 52 (P -> P DIVIDE N .)
    GOSUB           reduce using rule 52 (P -> P DIVIDE N .)
    INPUT           reduce using rule 52 (P -> P DIVIDE N .)
    PRINT           reduce using rule 52 (P -> P DIVIDE N .)
    SUBPROCEDURE    reduce using rule 52 (P -> P DIVIDE N .)
    END             reduce using rule 52 (P -> P DIVIDE N .)
    RETURN          reduce using rule 52 (P -> P DIVIDE N .)
    UNTIL           reduce using rule 52 (P -> P DIVIDE N .)
    ELSE            reduce using rule 52 (P -> P DIVIDE N .)
    EIF             reduce using rule 52 (P -> P DIVIDE N .)
    WEND            reduce using rule 52 (P -> P DIVIDE N .)
    NEXT            reduce using rule 52 (P -> P DIVIDE N .)
    GREATHER        reduce using rule 52 (P -> P DIVIDE N .)
    GREATHEREQUAL   reduce using rule 52 (P -> P DIVIDE N .)
    SMALLER         reduce using rule 52 (P -> P DIVIDE N .)
    SMALLEREQUAL    reduce using rule 52 (P -> P DIVIDE N .)
    NOTEQUAL        reduce using rule 52 (P -> P DIVIDE N .)
    EQUALTO         reduce using rule 52 (P -> P DIVIDE N .)
    error           reduce using rule 52 (P -> P DIVIDE N .)
    CLOSINGPAR      reduce using rule 52 (P -> P DIVIDE N .)
    TO              reduce using rule 52 (P -> P DIVIDE N .)
    CLOSINGBRACKET  reduce using rule 52 (P -> P DIVIDE N .)
    DO              reduce using rule 52 (P -> P DIVIDE N .)


state 97

    (56) N -> OPENPAR EA CLOSINGPAR .

    MULTIPLY        reduce using rule 56 (N -> OPENPAR EA CLOSINGPAR .)
    DIVIDE          reduce using rule 56 (N -> OPENPAR EA CLOSINGPAR .)
    PLUS            reduce using rule 56 (N -> OPENPAR EA CLOSINGPAR .)
    MINUS           reduce using rule 56 (N -> OPENPAR EA CLOSINGPAR .)
    LET             reduce using rule 56 (N -> OPENPAR EA CLOSINGPAR .)
    DIM             reduce using rule 56 (N -> OPENPAR EA CLOSINGPAR .)
    IF              reduce using rule 56 (N -> OPENPAR EA CLOSINGPAR .)
    FOR             reduce using rule 56 (N -> OPENPAR EA CLOSINGPAR .)
    WHILE           reduce using rule 56 (N -> OPENPAR EA CLOSINGPAR .)
    REPEAT          reduce using rule 56 (N -> OPENPAR EA CLOSINGPAR .)
    GOSUB           reduce using rule 56 (N -> OPENPAR EA CLOSINGPAR .)
    INPUT           reduce using rule 56 (N -> OPENPAR EA CLOSINGPAR .)
    PRINT           reduce using rule 56 (N -> OPENPAR EA CLOSINGPAR .)
    SUBPROCEDURE    reduce using rule 56 (N -> OPENPAR EA CLOSINGPAR .)
    END             reduce using rule 56 (N -> OPENPAR EA CLOSINGPAR .)
    RETURN          reduce using rule 56 (N -> OPENPAR EA CLOSINGPAR .)
    UNTIL           reduce using rule 56 (N -> OPENPAR EA CLOSINGPAR .)
    ELSE            reduce using rule 56 (N -> OPENPAR EA CLOSINGPAR .)
    EIF             reduce using rule 56 (N -> OPENPAR EA CLOSINGPAR .)
    WEND            reduce using rule 56 (N -> OPENPAR EA CLOSINGPAR .)
    NEXT            reduce using rule 56 (N -> OPENPAR EA CLOSINGPAR .)
    GREATHER        reduce using rule 56 (N -> OPENPAR EA CLOSINGPAR .)
    GREATHEREQUAL   reduce using rule 56 (N -> OPENPAR EA CLOSINGPAR .)
    SMALLER         reduce using rule 56 (N -> OPENPAR EA CLOSINGPAR .)
    SMALLEREQUAL    reduce using rule 56 (N -> OPENPAR EA CLOSINGPAR .)
    NOTEQUAL        reduce using rule 56 (N -> OPENPAR EA CLOSINGPAR .)
    EQUALTO         reduce using rule 56 (N -> OPENPAR EA CLOSINGPAR .)
    error           reduce using rule 56 (N -> OPENPAR EA CLOSINGPAR .)
    CLOSINGPAR      reduce using rule 56 (N -> OPENPAR EA CLOSINGPAR .)
    TO              reduce using rule 56 (N -> OPENPAR EA CLOSINGPAR .)
    CLOSINGBRACKET  reduce using rule 56 (N -> OPENPAR EA CLOSINGPAR .)
    DO              reduce using rule 56 (N -> OPENPAR EA CLOSINGPAR .)


state 98

    (2) V -> DIM setType Idv AS T . Arr
    (4) Arr -> . OPENBRACKET EA CLOSINGBRACKET Arr
    (5) Arr -> . OPENBRACKET ID CLOSINGBRACKET Arr
    (6) Arr -> . empty
    (76) empty -> .

    OPENBRACKET     shift and go to state 126
    LET             reduce using rule 76 (empty -> .)
    DIM             reduce using rule 76 (empty -> .)
    IF              reduce using rule 76 (empty -> .)
    FOR             reduce using rule 76 (empty -> .)
    WHILE           reduce using rule 76 (empty -> .)
    REPEAT          reduce using rule 76 (empty -> .)
    GOSUB           reduce using rule 76 (empty -> .)
    INPUT           reduce using rule 76 (empty -> .)
    PRINT           reduce using rule 76 (empty -> .)
    SUBPROCEDURE    reduce using rule 76 (empty -> .)
    END             reduce using rule 76 (empty -> .)

    Arr                            shift and go to state 125
    empty                          shift and go to state 127

state 99

    (7) T -> INT .

    OPENBRACKET     reduce using rule 7 (T -> INT .)
    LET             reduce using rule 7 (T -> INT .)
    DIM             reduce using rule 7 (T -> INT .)
    IF              reduce using rule 7 (T -> INT .)
    FOR             reduce using rule 7 (T -> INT .)
    WHILE           reduce using rule 7 (T -> INT .)
    REPEAT          reduce using rule 7 (T -> INT .)
    GOSUB           reduce using rule 7 (T -> INT .)
    INPUT           reduce using rule 7 (T -> INT .)
    PRINT           reduce using rule 7 (T -> INT .)
    SUBPROCEDURE    reduce using rule 7 (T -> INT .)
    END             reduce using rule 7 (T -> INT .)
    RETURN          reduce using rule 7 (T -> INT .)
    UNTIL           reduce using rule 7 (T -> INT .)
    ELSE            reduce using rule 7 (T -> INT .)
    EIF             reduce using rule 7 (T -> INT .)
    WEND            reduce using rule 7 (T -> INT .)
    NEXT            reduce using rule 7 (T -> INT .)


state 100

    (8) T -> FLOAT .

    OPENBRACKET     reduce using rule 8 (T -> FLOAT .)
    LET             reduce using rule 8 (T -> FLOAT .)
    DIM             reduce using rule 8 (T -> FLOAT .)
    IF              reduce using rule 8 (T -> FLOAT .)
    FOR             reduce using rule 8 (T -> FLOAT .)
    WHILE           reduce using rule 8 (T -> FLOAT .)
    REPEAT          reduce using rule 8 (T -> FLOAT .)
    GOSUB           reduce using rule 8 (T -> FLOAT .)
    INPUT           reduce using rule 8 (T -> FLOAT .)
    PRINT           reduce using rule 8 (T -> FLOAT .)
    SUBPROCEDURE    reduce using rule 8 (T -> FLOAT .)
    END             reduce using rule 8 (T -> FLOAT .)
    RETURN          reduce using rule 8 (T -> FLOAT .)
    UNTIL           reduce using rule 8 (T -> FLOAT .)
    ELSE            reduce using rule 8 (T -> FLOAT .)
    EIF             reduce using rule 8 (T -> FLOAT .)
    WEND            reduce using rule 8 (T -> FLOAT .)
    NEXT            reduce using rule 8 (T -> FLOAT .)


state 101

    (9) T -> WORD .

    OPENBRACKET     reduce using rule 9 (T -> WORD .)
    LET             reduce using rule 9 (T -> WORD .)
    DIM             reduce using rule 9 (T -> WORD .)
    IF              reduce using rule 9 (T -> WORD .)
    FOR             reduce using rule 9 (T -> WORD .)
    WHILE           reduce using rule 9 (T -> WORD .)
    REPEAT          reduce using rule 9 (T -> WORD .)
    GOSUB           reduce using rule 9 (T -> WORD .)
    INPUT           reduce using rule 9 (T -> WORD .)
    PRINT           reduce using rule 9 (T -> WORD .)
    SUBPROCEDURE    reduce using rule 9 (T -> WORD .)
    END             reduce using rule 9 (T -> WORD .)
    RETURN          reduce using rule 9 (T -> WORD .)
    UNTIL           reduce using rule 9 (T -> WORD .)
    ELSE            reduce using rule 9 (T -> WORD .)
    EIF             reduce using rule 9 (T -> WORD .)
    WEND            reduce using rule 9 (T -> WORD .)
    NEXT            reduce using rule 9 (T -> WORD .)


state 102

    (38) Idv -> ID COMA Idv .

    AS              reduce using rule 38 (Idv -> ID COMA Idv .)
    EQUALS          reduce using rule 38 (Idv -> ID COMA Idv .)
    CLOSINGBRACKET  reduce using rule 38 (Idv -> ID COMA Idv .)


state 103

    (10) S -> SUBPROCEDURE ID TWOPOINTS M . RETURN S

    RETURN          shift and go to state 128


state 104

    (16) E -> LET setType Idv EQUALS Ex .

    LET             reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    DIM             reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    IF              reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    FOR             reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    WHILE           reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    REPEAT          reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    GOSUB           reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    INPUT           reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    PRINT           reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    SUBPROCEDURE    reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    END             reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    RETURN          reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    UNTIL           reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    ELSE            reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    EIF             reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    WEND            reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    NEXT            reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)


state 105

    (17) E -> DIM setType Idv AS T . Arr
    (4) Arr -> . OPENBRACKET EA CLOSINGBRACKET Arr
    (5) Arr -> . OPENBRACKET ID CLOSINGBRACKET Arr
    (6) Arr -> . empty
    (76) empty -> .

    OPENBRACKET     shift and go to state 126
    LET             reduce using rule 76 (empty -> .)
    DIM             reduce using rule 76 (empty -> .)
    IF              reduce using rule 76 (empty -> .)
    FOR             reduce using rule 76 (empty -> .)
    WHILE           reduce using rule 76 (empty -> .)
    REPEAT          reduce using rule 76 (empty -> .)
    GOSUB           reduce using rule 76 (empty -> .)
    INPUT           reduce using rule 76 (empty -> .)
    PRINT           reduce using rule 76 (empty -> .)
    SUBPROCEDURE    reduce using rule 76 (empty -> .)
    END             reduce using rule 76 (empty -> .)
    RETURN          reduce using rule 76 (empty -> .)
    UNTIL           reduce using rule 76 (empty -> .)
    ELSE            reduce using rule 76 (empty -> .)
    EIF             reduce using rule 76 (empty -> .)
    WEND            reduce using rule 76 (empty -> .)
    NEXT            reduce using rule 76 (empty -> .)

    Arr                            shift and go to state 129
    empty                          shift and go to state 127

state 106

    (18) E -> IF EL THEN first_conditional F . Esf EIF final_conditional
    (36) Esf -> . ELSE second_conditional F
    (37) Esf -> . empty
    (76) empty -> .

    ELSE            shift and go to state 131
    EIF             reduce using rule 76 (empty -> .)

    Esf                            shift and go to state 130
    empty                          shift and go to state 132

state 107

    (65) EL -> OPENPAR O CLOSINGPAR OL . EL
    (62) EL -> . TRUE
    (63) EL -> . FALSE
    (64) EL -> . OPENPAR O CLOSINGPAR
    (65) EL -> . OPENPAR O CLOSINGPAR OL EL

    TRUE            shift and go to state 29
    FALSE           shift and go to state 30
    OPENPAR         shift and go to state 31

    EL                             shift and go to state 133

state 108

    (66) OL -> AND .

    TRUE            reduce using rule 66 (OL -> AND .)
    FALSE           reduce using rule 66 (OL -> AND .)
    OPENPAR         reduce using rule 66 (OL -> AND .)


state 109

    (67) OL -> OR .

    TRUE            reduce using rule 67 (OL -> OR .)
    FALSE           reduce using rule 67 (OL -> OR .)
    OPENPAR         reduce using rule 67 (OL -> OR .)


state 110

    (68) OL -> NOT .

    TRUE            reduce using rule 68 (OL -> NOT .)
    FALSE           reduce using rule 68 (OL -> NOT .)
    OPENPAR         reduce using rule 68 (OL -> NOT .)


state 111

    (69) O -> Ex GREATHER Ex .

    CLOSINGPAR      reduce using rule 69 (O -> Ex GREATHER Ex .)


state 112

    (70) O -> Ex GREATHEREQUAL Ex .

    CLOSINGPAR      reduce using rule 70 (O -> Ex GREATHEREQUAL Ex .)


state 113

    (71) O -> Ex SMALLER Ex .

    CLOSINGPAR      reduce using rule 71 (O -> Ex SMALLER Ex .)


state 114

    (72) O -> Ex SMALLEREQUAL Ex .

    CLOSINGPAR      reduce using rule 72 (O -> Ex SMALLEREQUAL Ex .)


state 115

    (73) O -> Ex NOTEQUAL Ex .

    CLOSINGPAR      reduce using rule 73 (O -> Ex NOTEQUAL Ex .)


state 116

    (74) O -> Ex EQUALTO Ex .

    CLOSINGPAR      reduce using rule 74 (O -> Ex EQUALTO Ex .)


state 117

    (75) O -> Ex error Ex .

    CLOSINGPAR      reduce using rule 75 (O -> Ex error Ex .)


state 118

    (19) E -> FOR ID EQUALS EA for_assignation . TO Ex for_conditional DO for_save_conditional F NEXT ID for_conditional_end

    TO              shift and go to state 134


state 119

    (56) N -> OPENPAR EA . CLOSINGPAR
    (48) EA -> EA . PLUS P
    (49) EA -> EA . MINUS P

    CLOSINGPAR      shift and go to state 97
    PLUS            shift and go to state 62
    MINUS           shift and go to state 63


state 120

    (20) E -> WHILE while_first_conditional EL DO while_second_conditional . F WEND while_final_conditional
    (14) F -> . E F
    (15) F -> . empty
    (16) E -> . LET setType Idv EQUALS Ex
    (17) E -> . DIM setType Idv AS T Arr
    (18) E -> . IF EL THEN first_conditional F Esf EIF final_conditional
    (19) E -> . FOR ID EQUALS EA for_assignation TO Ex for_conditional DO for_save_conditional F NEXT ID for_conditional_end
    (20) E -> . WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional
    (21) E -> . REPEAT while_first_conditional F UNTIL EL repeat_conditional
    (22) E -> . GOSUB ID
    (23) E -> . INPUT ES COMA IDEx
    (24) E -> . PRINT Ex
    (76) empty -> .

    LET             shift and go to state 10
    DIM             shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    REPEAT          shift and go to state 15
    GOSUB           shift and go to state 16
    INPUT           shift and go to state 17
    PRINT           shift and go to state 18
    WEND            reduce using rule 76 (empty -> .)

    F                              shift and go to state 135
    E                              shift and go to state 9
    empty                          shift and go to state 25

state 121

    (21) E -> REPEAT while_first_conditional F UNTIL EL . repeat_conditional
    (29) repeat_conditional -> .

    LET             reduce using rule 29 (repeat_conditional -> .)
    DIM             reduce using rule 29 (repeat_conditional -> .)
    IF              reduce using rule 29 (repeat_conditional -> .)
    FOR             reduce using rule 29 (repeat_conditional -> .)
    WHILE           reduce using rule 29 (repeat_conditional -> .)
    REPEAT          reduce using rule 29 (repeat_conditional -> .)
    GOSUB           reduce using rule 29 (repeat_conditional -> .)
    INPUT           reduce using rule 29 (repeat_conditional -> .)
    PRINT           reduce using rule 29 (repeat_conditional -> .)
    SUBPROCEDURE    reduce using rule 29 (repeat_conditional -> .)
    END             reduce using rule 29 (repeat_conditional -> .)
    RETURN          reduce using rule 29 (repeat_conditional -> .)
    UNTIL           reduce using rule 29 (repeat_conditional -> .)
    ELSE            reduce using rule 29 (repeat_conditional -> .)
    EIF             reduce using rule 29 (repeat_conditional -> .)
    WEND            reduce using rule 29 (repeat_conditional -> .)
    NEXT            reduce using rule 29 (repeat_conditional -> .)

    repeat_conditional             shift and go to state 136

state 122

    (42) IDEx -> ID OPENBRACKET . setType Idv CLOSINGBRACKET
    (40) setType -> .

    ID              reduce using rule 40 (setType -> .)

    setType                        shift and go to state 137

state 123

    (57) N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .

    MULTIPLY        reduce using rule 57 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    DIVIDE          reduce using rule 57 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    PLUS            reduce using rule 57 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    MINUS           reduce using rule 57 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    LET             reduce using rule 57 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    DIM             reduce using rule 57 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    IF              reduce using rule 57 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    FOR             reduce using rule 57 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    WHILE           reduce using rule 57 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    REPEAT          reduce using rule 57 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    GOSUB           reduce using rule 57 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    INPUT           reduce using rule 57 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    PRINT           reduce using rule 57 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    SUBPROCEDURE    reduce using rule 57 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    END             reduce using rule 57 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    RETURN          reduce using rule 57 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    UNTIL           reduce using rule 57 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    ELSE            reduce using rule 57 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    EIF             reduce using rule 57 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    WEND            reduce using rule 57 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    NEXT            reduce using rule 57 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    GREATHER        reduce using rule 57 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    GREATHEREQUAL   reduce using rule 57 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    SMALLER         reduce using rule 57 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    SMALLEREQUAL    reduce using rule 57 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    NOTEQUAL        reduce using rule 57 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    EQUALTO         reduce using rule 57 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    error           reduce using rule 57 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    CLOSINGPAR      reduce using rule 57 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    TO              reduce using rule 57 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    CLOSINGBRACKET  reduce using rule 57 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    DO              reduce using rule 57 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)


state 124

    (58) N -> ID OPENBRACKET setType Idv . CLOSINGBRACKET

    CLOSINGBRACKET  shift and go to state 138


state 125

    (2) V -> DIM setType Idv AS T Arr .

    LET             reduce using rule 2 (V -> DIM setType Idv AS T Arr .)
    DIM             reduce using rule 2 (V -> DIM setType Idv AS T Arr .)
    IF              reduce using rule 2 (V -> DIM setType Idv AS T Arr .)
    FOR             reduce using rule 2 (V -> DIM setType Idv AS T Arr .)
    WHILE           reduce using rule 2 (V -> DIM setType Idv AS T Arr .)
    REPEAT          reduce using rule 2 (V -> DIM setType Idv AS T Arr .)
    GOSUB           reduce using rule 2 (V -> DIM setType Idv AS T Arr .)
    INPUT           reduce using rule 2 (V -> DIM setType Idv AS T Arr .)
    PRINT           reduce using rule 2 (V -> DIM setType Idv AS T Arr .)
    SUBPROCEDURE    reduce using rule 2 (V -> DIM setType Idv AS T Arr .)
    END             reduce using rule 2 (V -> DIM setType Idv AS T Arr .)


state 126

    (4) Arr -> OPENBRACKET . EA CLOSINGBRACKET Arr
    (5) Arr -> OPENBRACKET . ID CLOSINGBRACKET Arr
    (48) EA -> . EA PLUS P
    (49) EA -> . EA MINUS P
    (50) EA -> . P
    (51) P -> . P MULTIPLY N
    (52) P -> . P DIVIDE N
    (53) P -> . N
    (54) N -> . cte saveID
    (55) N -> . ID saveID
    (56) N -> . OPENPAR EA CLOSINGPAR
    (57) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (58) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (60) cte -> . INTVAL
    (61) cte -> . FLOATVAL

    ID              shift and go to state 140
    OPENPAR         shift and go to state 86
    INTVAL          shift and go to state 47
    FLOATVAL        shift and go to state 48

    EA                             shift and go to state 139
    P                              shift and go to state 43
    N                              shift and go to state 45
    cte                            shift and go to state 46

state 127

    (6) Arr -> empty .

    LET             reduce using rule 6 (Arr -> empty .)
    DIM             reduce using rule 6 (Arr -> empty .)
    IF              reduce using rule 6 (Arr -> empty .)
    FOR             reduce using rule 6 (Arr -> empty .)
    WHILE           reduce using rule 6 (Arr -> empty .)
    REPEAT          reduce using rule 6 (Arr -> empty .)
    GOSUB           reduce using rule 6 (Arr -> empty .)
    INPUT           reduce using rule 6 (Arr -> empty .)
    PRINT           reduce using rule 6 (Arr -> empty .)
    SUBPROCEDURE    reduce using rule 6 (Arr -> empty .)
    END             reduce using rule 6 (Arr -> empty .)
    RETURN          reduce using rule 6 (Arr -> empty .)
    UNTIL           reduce using rule 6 (Arr -> empty .)
    ELSE            reduce using rule 6 (Arr -> empty .)
    EIF             reduce using rule 6 (Arr -> empty .)
    WEND            reduce using rule 6 (Arr -> empty .)
    NEXT            reduce using rule 6 (Arr -> empty .)


state 128

    (10) S -> SUBPROCEDURE ID TWOPOINTS M RETURN . S
    (10) S -> . SUBPROCEDURE ID TWOPOINTS M RETURN S
    (11) S -> . empty
    (76) empty -> .

    SUBPROCEDURE    shift and go to state 21
    END             reduce using rule 76 (empty -> .)

    S                              shift and go to state 141
    empty                          shift and go to state 22

state 129

    (17) E -> DIM setType Idv AS T Arr .

    LET             reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    DIM             reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    IF              reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    FOR             reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    WHILE           reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    REPEAT          reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    GOSUB           reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    INPUT           reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    PRINT           reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    SUBPROCEDURE    reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    END             reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    RETURN          reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    UNTIL           reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    ELSE            reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    EIF             reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    WEND            reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    NEXT            reduce using rule 17 (E -> DIM setType Idv AS T Arr .)


state 130

    (18) E -> IF EL THEN first_conditional F Esf . EIF final_conditional

    EIF             shift and go to state 142


state 131

    (36) Esf -> ELSE . second_conditional F
    (34) second_conditional -> .

    LET             reduce using rule 34 (second_conditional -> .)
    DIM             reduce using rule 34 (second_conditional -> .)
    IF              reduce using rule 34 (second_conditional -> .)
    FOR             reduce using rule 34 (second_conditional -> .)
    WHILE           reduce using rule 34 (second_conditional -> .)
    REPEAT          reduce using rule 34 (second_conditional -> .)
    GOSUB           reduce using rule 34 (second_conditional -> .)
    INPUT           reduce using rule 34 (second_conditional -> .)
    PRINT           reduce using rule 34 (second_conditional -> .)
    EIF             reduce using rule 34 (second_conditional -> .)

    second_conditional             shift and go to state 143

state 132

    (37) Esf -> empty .

    EIF             reduce using rule 37 (Esf -> empty .)


state 133

    (65) EL -> OPENPAR O CLOSINGPAR OL EL .

    THEN            reduce using rule 65 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    LET             reduce using rule 65 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    DIM             reduce using rule 65 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    IF              reduce using rule 65 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    FOR             reduce using rule 65 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    WHILE           reduce using rule 65 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    REPEAT          reduce using rule 65 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    GOSUB           reduce using rule 65 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    INPUT           reduce using rule 65 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    PRINT           reduce using rule 65 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    SUBPROCEDURE    reduce using rule 65 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    END             reduce using rule 65 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    RETURN          reduce using rule 65 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    UNTIL           reduce using rule 65 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    ELSE            reduce using rule 65 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    EIF             reduce using rule 65 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    WEND            reduce using rule 65 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    NEXT            reduce using rule 65 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    GREATHER        reduce using rule 65 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    GREATHEREQUAL   reduce using rule 65 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    SMALLER         reduce using rule 65 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    SMALLEREQUAL    reduce using rule 65 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    NOTEQUAL        reduce using rule 65 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    EQUALTO         reduce using rule 65 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    error           reduce using rule 65 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    DO              reduce using rule 65 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    CLOSINGPAR      reduce using rule 65 (EL -> OPENPAR O CLOSINGPAR OL EL .)


state 134

    (19) E -> FOR ID EQUALS EA for_assignation TO . Ex for_conditional DO for_save_conditional F NEXT ID for_conditional_end
    (43) Ex -> . EA
    (44) Ex -> . ES
    (45) Ex -> . EL
    (46) Ex -> . ID
    (48) EA -> . EA PLUS P
    (49) EA -> . EA MINUS P
    (50) EA -> . P
    (47) ES -> . WORDVAL
    (62) EL -> . TRUE
    (63) EL -> . FALSE
    (64) EL -> . OPENPAR O CLOSINGPAR
    (65) EL -> . OPENPAR O CLOSINGPAR OL EL
    (51) P -> . P MULTIPLY N
    (52) P -> . P DIVIDE N
    (53) P -> . N
    (54) N -> . cte saveID
    (55) N -> . ID saveID
    (56) N -> . OPENPAR EA CLOSINGPAR
    (57) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (58) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (60) cte -> . INTVAL
    (61) cte -> . FLOATVAL

    ID              shift and go to state 42
    WORDVAL         shift and go to state 37
    TRUE            shift and go to state 29
    FALSE           shift and go to state 30
    OPENPAR         shift and go to state 44
    INTVAL          shift and go to state 47
    FLOATVAL        shift and go to state 48

    EA                             shift and go to state 39
    Ex                             shift and go to state 144
    ES                             shift and go to state 40
    EL                             shift and go to state 41
    P                              shift and go to state 43
    N                              shift and go to state 45
    cte                            shift and go to state 46

state 135

    (20) E -> WHILE while_first_conditional EL DO while_second_conditional F . WEND while_final_conditional

    WEND            shift and go to state 145


state 136

    (21) E -> REPEAT while_first_conditional F UNTIL EL repeat_conditional .

    LET             reduce using rule 21 (E -> REPEAT while_first_conditional F UNTIL EL repeat_conditional .)
    DIM             reduce using rule 21 (E -> REPEAT while_first_conditional F UNTIL EL repeat_conditional .)
    IF              reduce using rule 21 (E -> REPEAT while_first_conditional F UNTIL EL repeat_conditional .)
    FOR             reduce using rule 21 (E -> REPEAT while_first_conditional F UNTIL EL repeat_conditional .)
    WHILE           reduce using rule 21 (E -> REPEAT while_first_conditional F UNTIL EL repeat_conditional .)
    REPEAT          reduce using rule 21 (E -> REPEAT while_first_conditional F UNTIL EL repeat_conditional .)
    GOSUB           reduce using rule 21 (E -> REPEAT while_first_conditional F UNTIL EL repeat_conditional .)
    INPUT           reduce using rule 21 (E -> REPEAT while_first_conditional F UNTIL EL repeat_conditional .)
    PRINT           reduce using rule 21 (E -> REPEAT while_first_conditional F UNTIL EL repeat_conditional .)
    SUBPROCEDURE    reduce using rule 21 (E -> REPEAT while_first_conditional F UNTIL EL repeat_conditional .)
    END             reduce using rule 21 (E -> REPEAT while_first_conditional F UNTIL EL repeat_conditional .)
    RETURN          reduce using rule 21 (E -> REPEAT while_first_conditional F UNTIL EL repeat_conditional .)
    UNTIL           reduce using rule 21 (E -> REPEAT while_first_conditional F UNTIL EL repeat_conditional .)
    ELSE            reduce using rule 21 (E -> REPEAT while_first_conditional F UNTIL EL repeat_conditional .)
    EIF             reduce using rule 21 (E -> REPEAT while_first_conditional F UNTIL EL repeat_conditional .)
    WEND            reduce using rule 21 (E -> REPEAT while_first_conditional F UNTIL EL repeat_conditional .)
    NEXT            reduce using rule 21 (E -> REPEAT while_first_conditional F UNTIL EL repeat_conditional .)


state 137

    (42) IDEx -> ID OPENBRACKET setType . Idv CLOSINGBRACKET
    (38) Idv -> . ID COMA Idv
    (39) Idv -> . ID

    ID              shift and go to state 50

    Idv                            shift and go to state 146

state 138

    (58) N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .

    MULTIPLY        reduce using rule 58 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    DIVIDE          reduce using rule 58 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    PLUS            reduce using rule 58 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    MINUS           reduce using rule 58 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    LET             reduce using rule 58 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    DIM             reduce using rule 58 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    IF              reduce using rule 58 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    FOR             reduce using rule 58 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    WHILE           reduce using rule 58 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    REPEAT          reduce using rule 58 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    GOSUB           reduce using rule 58 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    INPUT           reduce using rule 58 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    PRINT           reduce using rule 58 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    SUBPROCEDURE    reduce using rule 58 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    END             reduce using rule 58 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    RETURN          reduce using rule 58 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    UNTIL           reduce using rule 58 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    ELSE            reduce using rule 58 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    EIF             reduce using rule 58 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    WEND            reduce using rule 58 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    NEXT            reduce using rule 58 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    GREATHER        reduce using rule 58 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    GREATHEREQUAL   reduce using rule 58 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    SMALLER         reduce using rule 58 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    SMALLEREQUAL    reduce using rule 58 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    NOTEQUAL        reduce using rule 58 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    EQUALTO         reduce using rule 58 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    error           reduce using rule 58 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    CLOSINGPAR      reduce using rule 58 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    TO              reduce using rule 58 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    CLOSINGBRACKET  reduce using rule 58 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    DO              reduce using rule 58 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)


state 139

    (4) Arr -> OPENBRACKET EA . CLOSINGBRACKET Arr
    (48) EA -> EA . PLUS P
    (49) EA -> EA . MINUS P

    CLOSINGBRACKET  shift and go to state 147
    PLUS            shift and go to state 62
    MINUS           shift and go to state 63


state 140

    (5) Arr -> OPENBRACKET ID . CLOSINGBRACKET Arr
    (55) N -> ID . saveID
    (57) N -> ID . OPENBRACKET INTVAL CLOSINGBRACKET
    (58) N -> ID . OPENBRACKET setType Idv CLOSINGBRACKET
    (59) saveID -> .

  ! shift/reduce conflict for CLOSINGBRACKET resolved as shift
    CLOSINGBRACKET  shift and go to state 148
    OPENBRACKET     shift and go to state 65
    MULTIPLY        reduce using rule 59 (saveID -> .)
    DIVIDE          reduce using rule 59 (saveID -> .)
    PLUS            reduce using rule 59 (saveID -> .)
    MINUS           reduce using rule 59 (saveID -> .)

  ! CLOSINGBRACKET  [ reduce using rule 59 (saveID -> .) ]

    saveID                         shift and go to state 64

state 141

    (10) S -> SUBPROCEDURE ID TWOPOINTS M RETURN S .

    END             reduce using rule 10 (S -> SUBPROCEDURE ID TWOPOINTS M RETURN S .)


state 142

    (18) E -> IF EL THEN first_conditional F Esf EIF . final_conditional
    (35) final_conditional -> .

    LET             reduce using rule 35 (final_conditional -> .)
    DIM             reduce using rule 35 (final_conditional -> .)
    IF              reduce using rule 35 (final_conditional -> .)
    FOR             reduce using rule 35 (final_conditional -> .)
    WHILE           reduce using rule 35 (final_conditional -> .)
    REPEAT          reduce using rule 35 (final_conditional -> .)
    GOSUB           reduce using rule 35 (final_conditional -> .)
    INPUT           reduce using rule 35 (final_conditional -> .)
    PRINT           reduce using rule 35 (final_conditional -> .)
    SUBPROCEDURE    reduce using rule 35 (final_conditional -> .)
    END             reduce using rule 35 (final_conditional -> .)
    RETURN          reduce using rule 35 (final_conditional -> .)
    UNTIL           reduce using rule 35 (final_conditional -> .)
    ELSE            reduce using rule 35 (final_conditional -> .)
    EIF             reduce using rule 35 (final_conditional -> .)
    WEND            reduce using rule 35 (final_conditional -> .)
    NEXT            reduce using rule 35 (final_conditional -> .)

    final_conditional              shift and go to state 149

state 143

    (36) Esf -> ELSE second_conditional . F
    (14) F -> . E F
    (15) F -> . empty
    (16) E -> . LET setType Idv EQUALS Ex
    (17) E -> . DIM setType Idv AS T Arr
    (18) E -> . IF EL THEN first_conditional F Esf EIF final_conditional
    (19) E -> . FOR ID EQUALS EA for_assignation TO Ex for_conditional DO for_save_conditional F NEXT ID for_conditional_end
    (20) E -> . WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional
    (21) E -> . REPEAT while_first_conditional F UNTIL EL repeat_conditional
    (22) E -> . GOSUB ID
    (23) E -> . INPUT ES COMA IDEx
    (24) E -> . PRINT Ex
    (76) empty -> .

    LET             shift and go to state 10
    DIM             shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    REPEAT          shift and go to state 15
    GOSUB           shift and go to state 16
    INPUT           shift and go to state 17
    PRINT           shift and go to state 18
    EIF             reduce using rule 76 (empty -> .)

    F                              shift and go to state 150
    E                              shift and go to state 9
    empty                          shift and go to state 25

state 144

    (19) E -> FOR ID EQUALS EA for_assignation TO Ex . for_conditional DO for_save_conditional F NEXT ID for_conditional_end
    (26) for_conditional -> .

    DO              reduce using rule 26 (for_conditional -> .)

    for_conditional                shift and go to state 151

state 145

    (20) E -> WHILE while_first_conditional EL DO while_second_conditional F WEND . while_final_conditional
    (32) while_final_conditional -> .

    LET             reduce using rule 32 (while_final_conditional -> .)
    DIM             reduce using rule 32 (while_final_conditional -> .)
    IF              reduce using rule 32 (while_final_conditional -> .)
    FOR             reduce using rule 32 (while_final_conditional -> .)
    WHILE           reduce using rule 32 (while_final_conditional -> .)
    REPEAT          reduce using rule 32 (while_final_conditional -> .)
    GOSUB           reduce using rule 32 (while_final_conditional -> .)
    INPUT           reduce using rule 32 (while_final_conditional -> .)
    PRINT           reduce using rule 32 (while_final_conditional -> .)
    SUBPROCEDURE    reduce using rule 32 (while_final_conditional -> .)
    END             reduce using rule 32 (while_final_conditional -> .)
    RETURN          reduce using rule 32 (while_final_conditional -> .)
    UNTIL           reduce using rule 32 (while_final_conditional -> .)
    ELSE            reduce using rule 32 (while_final_conditional -> .)
    EIF             reduce using rule 32 (while_final_conditional -> .)
    WEND            reduce using rule 32 (while_final_conditional -> .)
    NEXT            reduce using rule 32 (while_final_conditional -> .)

    while_final_conditional        shift and go to state 152

state 146

    (42) IDEx -> ID OPENBRACKET setType Idv . CLOSINGBRACKET

    CLOSINGBRACKET  shift and go to state 153


state 147

    (4) Arr -> OPENBRACKET EA CLOSINGBRACKET . Arr
    (4) Arr -> . OPENBRACKET EA CLOSINGBRACKET Arr
    (5) Arr -> . OPENBRACKET ID CLOSINGBRACKET Arr
    (6) Arr -> . empty
    (76) empty -> .

    OPENBRACKET     shift and go to state 126
    LET             reduce using rule 76 (empty -> .)
    DIM             reduce using rule 76 (empty -> .)
    IF              reduce using rule 76 (empty -> .)
    FOR             reduce using rule 76 (empty -> .)
    WHILE           reduce using rule 76 (empty -> .)
    REPEAT          reduce using rule 76 (empty -> .)
    GOSUB           reduce using rule 76 (empty -> .)
    INPUT           reduce using rule 76 (empty -> .)
    PRINT           reduce using rule 76 (empty -> .)
    SUBPROCEDURE    reduce using rule 76 (empty -> .)
    END             reduce using rule 76 (empty -> .)
    RETURN          reduce using rule 76 (empty -> .)
    UNTIL           reduce using rule 76 (empty -> .)
    ELSE            reduce using rule 76 (empty -> .)
    EIF             reduce using rule 76 (empty -> .)
    WEND            reduce using rule 76 (empty -> .)
    NEXT            reduce using rule 76 (empty -> .)

    Arr                            shift and go to state 154
    empty                          shift and go to state 127

state 148

    (5) Arr -> OPENBRACKET ID CLOSINGBRACKET . Arr
    (4) Arr -> . OPENBRACKET EA CLOSINGBRACKET Arr
    (5) Arr -> . OPENBRACKET ID CLOSINGBRACKET Arr
    (6) Arr -> . empty
    (76) empty -> .

    OPENBRACKET     shift and go to state 126
    LET             reduce using rule 76 (empty -> .)
    DIM             reduce using rule 76 (empty -> .)
    IF              reduce using rule 76 (empty -> .)
    FOR             reduce using rule 76 (empty -> .)
    WHILE           reduce using rule 76 (empty -> .)
    REPEAT          reduce using rule 76 (empty -> .)
    GOSUB           reduce using rule 76 (empty -> .)
    INPUT           reduce using rule 76 (empty -> .)
    PRINT           reduce using rule 76 (empty -> .)
    SUBPROCEDURE    reduce using rule 76 (empty -> .)
    END             reduce using rule 76 (empty -> .)
    RETURN          reduce using rule 76 (empty -> .)
    UNTIL           reduce using rule 76 (empty -> .)
    ELSE            reduce using rule 76 (empty -> .)
    EIF             reduce using rule 76 (empty -> .)
    WEND            reduce using rule 76 (empty -> .)
    NEXT            reduce using rule 76 (empty -> .)

    Arr                            shift and go to state 155
    empty                          shift and go to state 127

state 149

    (18) E -> IF EL THEN first_conditional F Esf EIF final_conditional .

    LET             reduce using rule 18 (E -> IF EL THEN first_conditional F Esf EIF final_conditional .)
    DIM             reduce using rule 18 (E -> IF EL THEN first_conditional F Esf EIF final_conditional .)
    IF              reduce using rule 18 (E -> IF EL THEN first_conditional F Esf EIF final_conditional .)
    FOR             reduce using rule 18 (E -> IF EL THEN first_conditional F Esf EIF final_conditional .)
    WHILE           reduce using rule 18 (E -> IF EL THEN first_conditional F Esf EIF final_conditional .)
    REPEAT          reduce using rule 18 (E -> IF EL THEN first_conditional F Esf EIF final_conditional .)
    GOSUB           reduce using rule 18 (E -> IF EL THEN first_conditional F Esf EIF final_conditional .)
    INPUT           reduce using rule 18 (E -> IF EL THEN first_conditional F Esf EIF final_conditional .)
    PRINT           reduce using rule 18 (E -> IF EL THEN first_conditional F Esf EIF final_conditional .)
    SUBPROCEDURE    reduce using rule 18 (E -> IF EL THEN first_conditional F Esf EIF final_conditional .)
    END             reduce using rule 18 (E -> IF EL THEN first_conditional F Esf EIF final_conditional .)
    RETURN          reduce using rule 18 (E -> IF EL THEN first_conditional F Esf EIF final_conditional .)
    UNTIL           reduce using rule 18 (E -> IF EL THEN first_conditional F Esf EIF final_conditional .)
    ELSE            reduce using rule 18 (E -> IF EL THEN first_conditional F Esf EIF final_conditional .)
    EIF             reduce using rule 18 (E -> IF EL THEN first_conditional F Esf EIF final_conditional .)
    WEND            reduce using rule 18 (E -> IF EL THEN first_conditional F Esf EIF final_conditional .)
    NEXT            reduce using rule 18 (E -> IF EL THEN first_conditional F Esf EIF final_conditional .)


state 150

    (36) Esf -> ELSE second_conditional F .

    EIF             reduce using rule 36 (Esf -> ELSE second_conditional F .)


state 151

    (19) E -> FOR ID EQUALS EA for_assignation TO Ex for_conditional . DO for_save_conditional F NEXT ID for_conditional_end

    DO              shift and go to state 156


state 152

    (20) E -> WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional .

    LET             reduce using rule 20 (E -> WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional .)
    DIM             reduce using rule 20 (E -> WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional .)
    IF              reduce using rule 20 (E -> WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional .)
    FOR             reduce using rule 20 (E -> WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional .)
    WHILE           reduce using rule 20 (E -> WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional .)
    REPEAT          reduce using rule 20 (E -> WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional .)
    GOSUB           reduce using rule 20 (E -> WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional .)
    INPUT           reduce using rule 20 (E -> WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional .)
    PRINT           reduce using rule 20 (E -> WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional .)
    SUBPROCEDURE    reduce using rule 20 (E -> WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional .)
    END             reduce using rule 20 (E -> WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional .)
    RETURN          reduce using rule 20 (E -> WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional .)
    UNTIL           reduce using rule 20 (E -> WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional .)
    ELSE            reduce using rule 20 (E -> WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional .)
    EIF             reduce using rule 20 (E -> WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional .)
    WEND            reduce using rule 20 (E -> WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional .)
    NEXT            reduce using rule 20 (E -> WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional .)


state 153

    (42) IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .

    LET             reduce using rule 42 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    DIM             reduce using rule 42 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    IF              reduce using rule 42 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    FOR             reduce using rule 42 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    WHILE           reduce using rule 42 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    REPEAT          reduce using rule 42 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    GOSUB           reduce using rule 42 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    INPUT           reduce using rule 42 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    PRINT           reduce using rule 42 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    SUBPROCEDURE    reduce using rule 42 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    END             reduce using rule 42 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    RETURN          reduce using rule 42 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    UNTIL           reduce using rule 42 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    ELSE            reduce using rule 42 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    EIF             reduce using rule 42 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    WEND            reduce using rule 42 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    NEXT            reduce using rule 42 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)


state 154

    (4) Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .

    LET             reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    DIM             reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    IF              reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    FOR             reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    WHILE           reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    REPEAT          reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    GOSUB           reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    INPUT           reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    PRINT           reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    SUBPROCEDURE    reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    END             reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    RETURN          reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    UNTIL           reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    ELSE            reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    EIF             reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    WEND            reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    NEXT            reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)


state 155

    (5) Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .

    LET             reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    DIM             reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    IF              reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    FOR             reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    WHILE           reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    REPEAT          reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    GOSUB           reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    INPUT           reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    PRINT           reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    SUBPROCEDURE    reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    END             reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    RETURN          reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    UNTIL           reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    ELSE            reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    EIF             reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    WEND            reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    NEXT            reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)


state 156

    (19) E -> FOR ID EQUALS EA for_assignation TO Ex for_conditional DO . for_save_conditional F NEXT ID for_conditional_end
    (27) for_save_conditional -> .

    LET             reduce using rule 27 (for_save_conditional -> .)
    DIM             reduce using rule 27 (for_save_conditional -> .)
    IF              reduce using rule 27 (for_save_conditional -> .)
    FOR             reduce using rule 27 (for_save_conditional -> .)
    WHILE           reduce using rule 27 (for_save_conditional -> .)
    REPEAT          reduce using rule 27 (for_save_conditional -> .)
    GOSUB           reduce using rule 27 (for_save_conditional -> .)
    INPUT           reduce using rule 27 (for_save_conditional -> .)
    PRINT           reduce using rule 27 (for_save_conditional -> .)
    NEXT            reduce using rule 27 (for_save_conditional -> .)

    for_save_conditional           shift and go to state 157

state 157

    (19) E -> FOR ID EQUALS EA for_assignation TO Ex for_conditional DO for_save_conditional . F NEXT ID for_conditional_end
    (14) F -> . E F
    (15) F -> . empty
    (16) E -> . LET setType Idv EQUALS Ex
    (17) E -> . DIM setType Idv AS T Arr
    (18) E -> . IF EL THEN first_conditional F Esf EIF final_conditional
    (19) E -> . FOR ID EQUALS EA for_assignation TO Ex for_conditional DO for_save_conditional F NEXT ID for_conditional_end
    (20) E -> . WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional
    (21) E -> . REPEAT while_first_conditional F UNTIL EL repeat_conditional
    (22) E -> . GOSUB ID
    (23) E -> . INPUT ES COMA IDEx
    (24) E -> . PRINT Ex
    (76) empty -> .

    LET             shift and go to state 10
    DIM             shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    REPEAT          shift and go to state 15
    GOSUB           shift and go to state 16
    INPUT           shift and go to state 17
    PRINT           shift and go to state 18
    NEXT            reduce using rule 76 (empty -> .)

    F                              shift and go to state 158
    E                              shift and go to state 9
    empty                          shift and go to state 25

state 158

    (19) E -> FOR ID EQUALS EA for_assignation TO Ex for_conditional DO for_save_conditional F . NEXT ID for_conditional_end

    NEXT            shift and go to state 159


state 159

    (19) E -> FOR ID EQUALS EA for_assignation TO Ex for_conditional DO for_save_conditional F NEXT . ID for_conditional_end

    ID              shift and go to state 160


state 160

    (19) E -> FOR ID EQUALS EA for_assignation TO Ex for_conditional DO for_save_conditional F NEXT ID . for_conditional_end
    (28) for_conditional_end -> .

    LET             reduce using rule 28 (for_conditional_end -> .)
    DIM             reduce using rule 28 (for_conditional_end -> .)
    IF              reduce using rule 28 (for_conditional_end -> .)
    FOR             reduce using rule 28 (for_conditional_end -> .)
    WHILE           reduce using rule 28 (for_conditional_end -> .)
    REPEAT          reduce using rule 28 (for_conditional_end -> .)
    GOSUB           reduce using rule 28 (for_conditional_end -> .)
    INPUT           reduce using rule 28 (for_conditional_end -> .)
    PRINT           reduce using rule 28 (for_conditional_end -> .)
    SUBPROCEDURE    reduce using rule 28 (for_conditional_end -> .)
    END             reduce using rule 28 (for_conditional_end -> .)
    RETURN          reduce using rule 28 (for_conditional_end -> .)
    UNTIL           reduce using rule 28 (for_conditional_end -> .)
    ELSE            reduce using rule 28 (for_conditional_end -> .)
    EIF             reduce using rule 28 (for_conditional_end -> .)
    WEND            reduce using rule 28 (for_conditional_end -> .)
    NEXT            reduce using rule 28 (for_conditional_end -> .)

    for_conditional_end            shift and go to state 161

state 161

    (19) E -> FOR ID EQUALS EA for_assignation TO Ex for_conditional DO for_save_conditional F NEXT ID for_conditional_end .

    LET             reduce using rule 19 (E -> FOR ID EQUALS EA for_assignation TO Ex for_conditional DO for_save_conditional F NEXT ID for_conditional_end .)
    DIM             reduce using rule 19 (E -> FOR ID EQUALS EA for_assignation TO Ex for_conditional DO for_save_conditional F NEXT ID for_conditional_end .)
    IF              reduce using rule 19 (E -> FOR ID EQUALS EA for_assignation TO Ex for_conditional DO for_save_conditional F NEXT ID for_conditional_end .)
    FOR             reduce using rule 19 (E -> FOR ID EQUALS EA for_assignation TO Ex for_conditional DO for_save_conditional F NEXT ID for_conditional_end .)
    WHILE           reduce using rule 19 (E -> FOR ID EQUALS EA for_assignation TO Ex for_conditional DO for_save_conditional F NEXT ID for_conditional_end .)
    REPEAT          reduce using rule 19 (E -> FOR ID EQUALS EA for_assignation TO Ex for_conditional DO for_save_conditional F NEXT ID for_conditional_end .)
    GOSUB           reduce using rule 19 (E -> FOR ID EQUALS EA for_assignation TO Ex for_conditional DO for_save_conditional F NEXT ID for_conditional_end .)
    INPUT           reduce using rule 19 (E -> FOR ID EQUALS EA for_assignation TO Ex for_conditional DO for_save_conditional F NEXT ID for_conditional_end .)
    PRINT           reduce using rule 19 (E -> FOR ID EQUALS EA for_assignation TO Ex for_conditional DO for_save_conditional F NEXT ID for_conditional_end .)
    SUBPROCEDURE    reduce using rule 19 (E -> FOR ID EQUALS EA for_assignation TO Ex for_conditional DO for_save_conditional F NEXT ID for_conditional_end .)
    END             reduce using rule 19 (E -> FOR ID EQUALS EA for_assignation TO Ex for_conditional DO for_save_conditional F NEXT ID for_conditional_end .)
    RETURN          reduce using rule 19 (E -> FOR ID EQUALS EA for_assignation TO Ex for_conditional DO for_save_conditional F NEXT ID for_conditional_end .)
    UNTIL           reduce using rule 19 (E -> FOR ID EQUALS EA for_assignation TO Ex for_conditional DO for_save_conditional F NEXT ID for_conditional_end .)
    ELSE            reduce using rule 19 (E -> FOR ID EQUALS EA for_assignation TO Ex for_conditional DO for_save_conditional F NEXT ID for_conditional_end .)
    EIF             reduce using rule 19 (E -> FOR ID EQUALS EA for_assignation TO Ex for_conditional DO for_save_conditional F NEXT ID for_conditional_end .)
    WEND            reduce using rule 19 (E -> FOR ID EQUALS EA for_assignation TO Ex for_conditional DO for_save_conditional F NEXT ID for_conditional_end .)
    NEXT            reduce using rule 19 (E -> FOR ID EQUALS EA for_assignation TO Ex for_conditional DO for_save_conditional F NEXT ID for_conditional_end .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for DIM in state 2 resolved as shift
WARNING: shift/reduce conflict for LET in state 3 resolved as shift
WARNING: shift/reduce conflict for DIM in state 3 resolved as shift
WARNING: shift/reduce conflict for IF in state 3 resolved as shift
WARNING: shift/reduce conflict for FOR in state 3 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 3 resolved as shift
WARNING: shift/reduce conflict for REPEAT in state 3 resolved as shift
WARNING: shift/reduce conflict for GOSUB in state 3 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 3 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 3 resolved as shift
WARNING: shift/reduce conflict for LET in state 7 resolved as shift
WARNING: shift/reduce conflict for DIM in state 7 resolved as shift
WARNING: shift/reduce conflict for IF in state 7 resolved as shift
WARNING: shift/reduce conflict for FOR in state 7 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 7 resolved as shift
WARNING: shift/reduce conflict for REPEAT in state 7 resolved as shift
WARNING: shift/reduce conflict for GOSUB in state 7 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 7 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 7 resolved as shift
WARNING: shift/reduce conflict for LET in state 9 resolved as shift
WARNING: shift/reduce conflict for DIM in state 9 resolved as shift
WARNING: shift/reduce conflict for IF in state 9 resolved as shift
WARNING: shift/reduce conflict for FOR in state 9 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 9 resolved as shift
WARNING: shift/reduce conflict for REPEAT in state 9 resolved as shift
WARNING: shift/reduce conflict for GOSUB in state 9 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 9 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 9 resolved as shift
WARNING: shift/reduce conflict for LET in state 72 resolved as shift
WARNING: shift/reduce conflict for DIM in state 72 resolved as shift
WARNING: shift/reduce conflict for IF in state 72 resolved as shift
WARNING: shift/reduce conflict for FOR in state 72 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 72 resolved as shift
WARNING: shift/reduce conflict for REPEAT in state 72 resolved as shift
WARNING: shift/reduce conflict for GOSUB in state 72 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 72 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 72 resolved as shift
WARNING: shift/reduce conflict for CLOSINGBRACKET in state 140 resolved as shift
WARNING: reduce/reduce conflict in state 8 resolved using rule (M -> empty)
WARNING: rejected rule (F -> empty) in state 8
WARNING: reduce/reduce conflict in state 42 resolved using rule (Ex -> ID)
WARNING: rejected rule (saveID -> <empty>) in state 42
