Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT

Grammar

Rule 0     S' -> PROGRAMA
Rule 1     PROGRAMA -> PROGRAM V M S END
Rule 2     V -> DIM Idv AS T Arr V
Rule 3     V -> empty
Rule 4     Idv -> ID COMA Idv
Rule 5     Idv -> ID
Rule 6     Arr -> OPENBRACKET EA CLOSINGBRACKET Arr
Rule 7     Arr -> OPENBRACKET ID CLOSINGBRACKET Arr
Rule 8     Arr -> empty
Rule 9     T -> INT
Rule 10    T -> FLOAT
Rule 11    T -> WORD
Rule 12    S -> SUBPROCEDURE ID TWOPOINTS M RETURN S
Rule 13    S -> empty
Rule 14    M -> F M
Rule 15    M -> empty
Rule 16    F -> E F
Rule 17    F -> empty
Rule 18    E -> LET Idv EQUALS Ex
Rule 19    E -> DIM Idv AS T Arr
Rule 20    E -> IF EL THEN F Esf EIF
Rule 21    E -> FOR ID EQUALS EA TO Ex F NEXT ID
Rule 22    E -> WHILE OPENPAR EL CLOSINGPAR F WEND
Rule 23    E -> GOSUB ID
Rule 24    E -> INPUT ES COMA IDEx
Rule 25    E -> PRINT Ex
Rule 26    Esf -> ELSE F
Rule 27    Esf -> empty
Rule 28    IDEx -> ID
Rule 29    IDEx -> ID OPENBRACKET Idv CLOSINGBRACKET
Rule 30    Ex -> EA
Rule 31    Ex -> ES
Rule 32    Ex -> EL
Rule 33    Ex -> ID
Rule 34    ES -> WORDVAL
Rule 35    EA -> P PLUS EA
Rule 36    EA -> P MINUS EA
Rule 37    EA -> P
Rule 38    P -> N MULTIPLY P
Rule 39    P -> N DIVIDE P
Rule 40    P -> N
Rule 41    N -> cte
Rule 42    N -> ID
Rule 43    N -> OPENPAR EA CLOSINGPAR
Rule 44    N -> ID OPENBRACKET INTVAL CLOSINGBRACKET
Rule 45    N -> ID OPENBRACKET Idv CLOSINGBRACKET
Rule 46    cte -> INTVAL
Rule 47    cte -> FLOATVAL
Rule 48    EL -> TRUE
Rule 49    EL -> FALSE
Rule 50    EL -> OPENPAR O CLOSINGPAR Olt
Rule 51    Olt -> OL OPENPAR O CLOSINGPAR Olt
Rule 52    Olt -> empty
Rule 53    OL -> AND
Rule 54    OL -> OR
Rule 55    OL -> NOT
Rule 56    O -> WORD EQUALTO WORD
Rule 57    O -> EA OPR EA
Rule 58    O -> ID OPR ID
Rule 59    O -> ID OPR EA
Rule 60    O -> EA OPR ID
Rule 61    OPR -> EQUALTO
Rule 62    OPR -> GREATHER
Rule 63    OPR -> GREATHEREQUAL
Rule 64    OPR -> SMALLER
Rule 65    OPR -> SMALLEREQUAL
Rule 66    OPR -> NOTEQUAL
Rule 67    empty -> <empty>

Terminals, with rules where they appear

AND                  : 53
AS                   : 2 19
CLOSINGBRACKET       : 6 7 29 44 45
CLOSINGPAR           : 22 43 50 51
COMA                 : 4 24
COMMENT              : 
DIM                  : 2 19
DIVIDE               : 39
EIF                  : 20
ELSE                 : 26
END                  : 1
EQUALS               : 18 21
EQUALTO              : 56 61
FALSE                : 49
FLOAT                : 10
FLOATVAL             : 47
FOR                  : 21
GOSUB                : 23
GREATHER             : 62
GREATHEREQUAL        : 63
ID                   : 4 5 7 12 21 21 23 28 29 33 42 44 45 58 58 59 60
IF                   : 20
INPUT                : 24
INT                  : 9
INTVAL               : 44 46
LET                  : 18
MINUS                : 36
MULTIPLY             : 38
NEXT                 : 21
NOT                  : 55
NOTEQUAL             : 66
OPENBRACKET          : 6 7 29 44 45
OPENPAR              : 22 43 50 51
OR                   : 54
PLUS                 : 35
PRINT                : 25
PROGRAM              : 1
RETURN               : 12
SMALLER              : 64
SMALLEREQUAL         : 65
SUBPROCEDURE         : 12
THEN                 : 20
TO                   : 21
TRUE                 : 48
TWOPOINTS            : 12
WEND                 : 22
WHILE                : 22
WORD                 : 11 56 56
WORDVAL              : 34
error                : 

Nonterminals, with rules where they appear

Arr                  : 2 6 7 19
E                    : 16
EA                   : 6 21 30 35 36 43 57 57 59 60
EL                   : 20 22 32
ES                   : 24 31
Esf                  : 20
Ex                   : 18 21 25
F                    : 14 16 20 21 22 26
IDEx                 : 24
Idv                  : 2 4 18 19 29 45
M                    : 1 12 14
N                    : 38 39 40
O                    : 50 51
OL                   : 51
OPR                  : 57 58 59 60
Olt                  : 50 51
P                    : 35 36 37 38 39
PROGRAMA             : 0
S                    : 1 12
T                    : 2 19
V                    : 1 2
cte                  : 41
empty                : 3 8 13 15 17 27 52

Parsing method: LALR

state 0

    (0) S' -> . PROGRAMA
    (1) PROGRAMA -> . PROGRAM V M S END

    PROGRAM         shift and go to state 2

    PROGRAMA                       shift and go to state 1

state 1

    (0) S' -> PROGRAMA .



state 2

    (1) PROGRAMA -> PROGRAM . V M S END
    (2) V -> . DIM Idv AS T Arr V
    (3) V -> . empty
    (67) empty -> .

  ! shift/reduce conflict for DIM resolved as shift
    DIM             shift and go to state 4
    LET             reduce using rule 67 (empty -> .)
    IF              reduce using rule 67 (empty -> .)
    FOR             reduce using rule 67 (empty -> .)
    WHILE           reduce using rule 67 (empty -> .)
    GOSUB           reduce using rule 67 (empty -> .)
    INPUT           reduce using rule 67 (empty -> .)
    PRINT           reduce using rule 67 (empty -> .)
    SUBPROCEDURE    reduce using rule 67 (empty -> .)
    END             reduce using rule 67 (empty -> .)

  ! DIM             [ reduce using rule 67 (empty -> .) ]

    V                              shift and go to state 3
    empty                          shift and go to state 5

state 3

    (1) PROGRAMA -> PROGRAM V . M S END
    (14) M -> . F M
    (15) M -> . empty
    (16) F -> . E F
    (17) F -> . empty
    (67) empty -> .
    (18) E -> . LET Idv EQUALS Ex
    (19) E -> . DIM Idv AS T Arr
    (20) E -> . IF EL THEN F Esf EIF
    (21) E -> . FOR ID EQUALS EA TO Ex F NEXT ID
    (22) E -> . WHILE OPENPAR EL CLOSINGPAR F WEND
    (23) E -> . GOSUB ID
    (24) E -> . INPUT ES COMA IDEx
    (25) E -> . PRINT Ex

  ! shift/reduce conflict for LET resolved as shift
  ! shift/reduce conflict for DIM resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for GOSUB resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
    SUBPROCEDURE    reduce using rule 67 (empty -> .)
    END             reduce using rule 67 (empty -> .)
    LET             shift and go to state 10
    DIM             shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    GOSUB           shift and go to state 15
    INPUT           shift and go to state 16
    PRINT           shift and go to state 17

  ! LET             [ reduce using rule 67 (empty -> .) ]
  ! DIM             [ reduce using rule 67 (empty -> .) ]
  ! IF              [ reduce using rule 67 (empty -> .) ]
  ! FOR             [ reduce using rule 67 (empty -> .) ]
  ! WHILE           [ reduce using rule 67 (empty -> .) ]
  ! GOSUB           [ reduce using rule 67 (empty -> .) ]
  ! INPUT           [ reduce using rule 67 (empty -> .) ]
  ! PRINT           [ reduce using rule 67 (empty -> .) ]

    M                              shift and go to state 6
    F                              shift and go to state 7
    empty                          shift and go to state 8
    E                              shift and go to state 9

state 4

    (2) V -> DIM . Idv AS T Arr V
    (4) Idv -> . ID COMA Idv
    (5) Idv -> . ID

    ID              shift and go to state 19

    Idv                            shift and go to state 18

state 5

    (3) V -> empty .

    LET             reduce using rule 3 (V -> empty .)
    DIM             reduce using rule 3 (V -> empty .)
    IF              reduce using rule 3 (V -> empty .)
    FOR             reduce using rule 3 (V -> empty .)
    WHILE           reduce using rule 3 (V -> empty .)
    GOSUB           reduce using rule 3 (V -> empty .)
    INPUT           reduce using rule 3 (V -> empty .)
    PRINT           reduce using rule 3 (V -> empty .)
    SUBPROCEDURE    reduce using rule 3 (V -> empty .)
    END             reduce using rule 3 (V -> empty .)


state 6

    (1) PROGRAMA -> PROGRAM V M . S END
    (12) S -> . SUBPROCEDURE ID TWOPOINTS M RETURN S
    (13) S -> . empty
    (67) empty -> .

    SUBPROCEDURE    shift and go to state 21
    END             reduce using rule 67 (empty -> .)

    S                              shift and go to state 20
    empty                          shift and go to state 22

state 7

    (14) M -> F . M
    (14) M -> . F M
    (15) M -> . empty
    (16) F -> . E F
    (17) F -> . empty
    (67) empty -> .
    (18) E -> . LET Idv EQUALS Ex
    (19) E -> . DIM Idv AS T Arr
    (20) E -> . IF EL THEN F Esf EIF
    (21) E -> . FOR ID EQUALS EA TO Ex F NEXT ID
    (22) E -> . WHILE OPENPAR EL CLOSINGPAR F WEND
    (23) E -> . GOSUB ID
    (24) E -> . INPUT ES COMA IDEx
    (25) E -> . PRINT Ex

  ! shift/reduce conflict for LET resolved as shift
  ! shift/reduce conflict for DIM resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for GOSUB resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
    SUBPROCEDURE    reduce using rule 67 (empty -> .)
    END             reduce using rule 67 (empty -> .)
    RETURN          reduce using rule 67 (empty -> .)
    LET             shift and go to state 10
    DIM             shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    GOSUB           shift and go to state 15
    INPUT           shift and go to state 16
    PRINT           shift and go to state 17

  ! LET             [ reduce using rule 67 (empty -> .) ]
  ! DIM             [ reduce using rule 67 (empty -> .) ]
  ! IF              [ reduce using rule 67 (empty -> .) ]
  ! FOR             [ reduce using rule 67 (empty -> .) ]
  ! WHILE           [ reduce using rule 67 (empty -> .) ]
  ! GOSUB           [ reduce using rule 67 (empty -> .) ]
  ! INPUT           [ reduce using rule 67 (empty -> .) ]
  ! PRINT           [ reduce using rule 67 (empty -> .) ]

    F                              shift and go to state 7
    M                              shift and go to state 23
    empty                          shift and go to state 8
    E                              shift and go to state 9

state 8

    (15) M -> empty .
    (17) F -> empty .

  ! reduce/reduce conflict for SUBPROCEDURE resolved using rule 15 (M -> empty .)
  ! reduce/reduce conflict for END resolved using rule 15 (M -> empty .)
  ! reduce/reduce conflict for RETURN resolved using rule 15 (M -> empty .)
    SUBPROCEDURE    reduce using rule 15 (M -> empty .)
    END             reduce using rule 15 (M -> empty .)
    RETURN          reduce using rule 15 (M -> empty .)
    LET             reduce using rule 17 (F -> empty .)
    DIM             reduce using rule 17 (F -> empty .)
    IF              reduce using rule 17 (F -> empty .)
    FOR             reduce using rule 17 (F -> empty .)
    WHILE           reduce using rule 17 (F -> empty .)
    GOSUB           reduce using rule 17 (F -> empty .)
    INPUT           reduce using rule 17 (F -> empty .)
    PRINT           reduce using rule 17 (F -> empty .)

  ! SUBPROCEDURE    [ reduce using rule 17 (F -> empty .) ]
  ! END             [ reduce using rule 17 (F -> empty .) ]
  ! RETURN          [ reduce using rule 17 (F -> empty .) ]


state 9

    (16) F -> E . F
    (16) F -> . E F
    (17) F -> . empty
    (18) E -> . LET Idv EQUALS Ex
    (19) E -> . DIM Idv AS T Arr
    (20) E -> . IF EL THEN F Esf EIF
    (21) E -> . FOR ID EQUALS EA TO Ex F NEXT ID
    (22) E -> . WHILE OPENPAR EL CLOSINGPAR F WEND
    (23) E -> . GOSUB ID
    (24) E -> . INPUT ES COMA IDEx
    (25) E -> . PRINT Ex
    (67) empty -> .

  ! shift/reduce conflict for LET resolved as shift
  ! shift/reduce conflict for DIM resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for GOSUB resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
    LET             shift and go to state 10
    DIM             shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    GOSUB           shift and go to state 15
    INPUT           shift and go to state 16
    PRINT           shift and go to state 17
    SUBPROCEDURE    reduce using rule 67 (empty -> .)
    END             reduce using rule 67 (empty -> .)
    RETURN          reduce using rule 67 (empty -> .)
    ELSE            reduce using rule 67 (empty -> .)
    EIF             reduce using rule 67 (empty -> .)
    WEND            reduce using rule 67 (empty -> .)
    NEXT            reduce using rule 67 (empty -> .)

  ! LET             [ reduce using rule 67 (empty -> .) ]
  ! DIM             [ reduce using rule 67 (empty -> .) ]
  ! IF              [ reduce using rule 67 (empty -> .) ]
  ! FOR             [ reduce using rule 67 (empty -> .) ]
  ! WHILE           [ reduce using rule 67 (empty -> .) ]
  ! GOSUB           [ reduce using rule 67 (empty -> .) ]
  ! INPUT           [ reduce using rule 67 (empty -> .) ]
  ! PRINT           [ reduce using rule 67 (empty -> .) ]

    E                              shift and go to state 9
    F                              shift and go to state 24
    empty                          shift and go to state 25

state 10

    (18) E -> LET . Idv EQUALS Ex
    (4) Idv -> . ID COMA Idv
    (5) Idv -> . ID

    ID              shift and go to state 19

    Idv                            shift and go to state 26

state 11

    (19) E -> DIM . Idv AS T Arr
    (4) Idv -> . ID COMA Idv
    (5) Idv -> . ID

    ID              shift and go to state 19

    Idv                            shift and go to state 27

state 12

    (20) E -> IF . EL THEN F Esf EIF
    (48) EL -> . TRUE
    (49) EL -> . FALSE
    (50) EL -> . OPENPAR O CLOSINGPAR Olt

    TRUE            shift and go to state 29
    FALSE           shift and go to state 30
    OPENPAR         shift and go to state 31

    EL                             shift and go to state 28

state 13

    (21) E -> FOR . ID EQUALS EA TO Ex F NEXT ID

    ID              shift and go to state 32


state 14

    (22) E -> WHILE . OPENPAR EL CLOSINGPAR F WEND

    OPENPAR         shift and go to state 33


state 15

    (23) E -> GOSUB . ID

    ID              shift and go to state 34


state 16

    (24) E -> INPUT . ES COMA IDEx
    (34) ES -> . WORDVAL

    WORDVAL         shift and go to state 36

    ES                             shift and go to state 35

state 17

    (25) E -> PRINT . Ex
    (30) Ex -> . EA
    (31) Ex -> . ES
    (32) Ex -> . EL
    (33) Ex -> . ID
    (35) EA -> . P PLUS EA
    (36) EA -> . P MINUS EA
    (37) EA -> . P
    (34) ES -> . WORDVAL
    (48) EL -> . TRUE
    (49) EL -> . FALSE
    (50) EL -> . OPENPAR O CLOSINGPAR Olt
    (38) P -> . N MULTIPLY P
    (39) P -> . N DIVIDE P
    (40) P -> . N
    (41) N -> . cte
    (42) N -> . ID
    (43) N -> . OPENPAR EA CLOSINGPAR
    (44) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (45) N -> . ID OPENBRACKET Idv CLOSINGBRACKET
    (46) cte -> . INTVAL
    (47) cte -> . FLOATVAL

    ID              shift and go to state 41
    WORDVAL         shift and go to state 36
    TRUE            shift and go to state 29
    FALSE           shift and go to state 30
    OPENPAR         shift and go to state 43
    INTVAL          shift and go to state 46
    FLOATVAL        shift and go to state 47

    Ex                             shift and go to state 37
    EA                             shift and go to state 38
    ES                             shift and go to state 39
    EL                             shift and go to state 40
    P                              shift and go to state 42
    N                              shift and go to state 44
    cte                            shift and go to state 45

state 18

    (2) V -> DIM Idv . AS T Arr V

    AS              shift and go to state 48


state 19

    (4) Idv -> ID . COMA Idv
    (5) Idv -> ID .

    COMA            shift and go to state 49
    AS              reduce using rule 5 (Idv -> ID .)
    EQUALS          reduce using rule 5 (Idv -> ID .)
    CLOSINGBRACKET  reduce using rule 5 (Idv -> ID .)


state 20

    (1) PROGRAMA -> PROGRAM V M S . END

    END             shift and go to state 50


state 21

    (12) S -> SUBPROCEDURE . ID TWOPOINTS M RETURN S

    ID              shift and go to state 51


state 22

    (13) S -> empty .

    END             reduce using rule 13 (S -> empty .)


state 23

    (14) M -> F M .

    SUBPROCEDURE    reduce using rule 14 (M -> F M .)
    END             reduce using rule 14 (M -> F M .)
    RETURN          reduce using rule 14 (M -> F M .)


state 24

    (16) F -> E F .

    LET             reduce using rule 16 (F -> E F .)
    DIM             reduce using rule 16 (F -> E F .)
    IF              reduce using rule 16 (F -> E F .)
    FOR             reduce using rule 16 (F -> E F .)
    WHILE           reduce using rule 16 (F -> E F .)
    GOSUB           reduce using rule 16 (F -> E F .)
    INPUT           reduce using rule 16 (F -> E F .)
    PRINT           reduce using rule 16 (F -> E F .)
    SUBPROCEDURE    reduce using rule 16 (F -> E F .)
    END             reduce using rule 16 (F -> E F .)
    RETURN          reduce using rule 16 (F -> E F .)
    ELSE            reduce using rule 16 (F -> E F .)
    EIF             reduce using rule 16 (F -> E F .)
    WEND            reduce using rule 16 (F -> E F .)
    NEXT            reduce using rule 16 (F -> E F .)


state 25

    (17) F -> empty .

    LET             reduce using rule 17 (F -> empty .)
    DIM             reduce using rule 17 (F -> empty .)
    IF              reduce using rule 17 (F -> empty .)
    FOR             reduce using rule 17 (F -> empty .)
    WHILE           reduce using rule 17 (F -> empty .)
    GOSUB           reduce using rule 17 (F -> empty .)
    INPUT           reduce using rule 17 (F -> empty .)
    PRINT           reduce using rule 17 (F -> empty .)
    SUBPROCEDURE    reduce using rule 17 (F -> empty .)
    END             reduce using rule 17 (F -> empty .)
    RETURN          reduce using rule 17 (F -> empty .)
    ELSE            reduce using rule 17 (F -> empty .)
    EIF             reduce using rule 17 (F -> empty .)
    WEND            reduce using rule 17 (F -> empty .)
    NEXT            reduce using rule 17 (F -> empty .)


state 26

    (18) E -> LET Idv . EQUALS Ex

    EQUALS          shift and go to state 52


state 27

    (19) E -> DIM Idv . AS T Arr

    AS              shift and go to state 53


state 28

    (20) E -> IF EL . THEN F Esf EIF

    THEN            shift and go to state 54


state 29

    (48) EL -> TRUE .

    THEN            reduce using rule 48 (EL -> TRUE .)
    LET             reduce using rule 48 (EL -> TRUE .)
    DIM             reduce using rule 48 (EL -> TRUE .)
    IF              reduce using rule 48 (EL -> TRUE .)
    FOR             reduce using rule 48 (EL -> TRUE .)
    WHILE           reduce using rule 48 (EL -> TRUE .)
    GOSUB           reduce using rule 48 (EL -> TRUE .)
    INPUT           reduce using rule 48 (EL -> TRUE .)
    PRINT           reduce using rule 48 (EL -> TRUE .)
    SUBPROCEDURE    reduce using rule 48 (EL -> TRUE .)
    END             reduce using rule 48 (EL -> TRUE .)
    RETURN          reduce using rule 48 (EL -> TRUE .)
    ELSE            reduce using rule 48 (EL -> TRUE .)
    EIF             reduce using rule 48 (EL -> TRUE .)
    WEND            reduce using rule 48 (EL -> TRUE .)
    NEXT            reduce using rule 48 (EL -> TRUE .)
    CLOSINGPAR      reduce using rule 48 (EL -> TRUE .)


state 30

    (49) EL -> FALSE .

    THEN            reduce using rule 49 (EL -> FALSE .)
    LET             reduce using rule 49 (EL -> FALSE .)
    DIM             reduce using rule 49 (EL -> FALSE .)
    IF              reduce using rule 49 (EL -> FALSE .)
    FOR             reduce using rule 49 (EL -> FALSE .)
    WHILE           reduce using rule 49 (EL -> FALSE .)
    GOSUB           reduce using rule 49 (EL -> FALSE .)
    INPUT           reduce using rule 49 (EL -> FALSE .)
    PRINT           reduce using rule 49 (EL -> FALSE .)
    SUBPROCEDURE    reduce using rule 49 (EL -> FALSE .)
    END             reduce using rule 49 (EL -> FALSE .)
    RETURN          reduce using rule 49 (EL -> FALSE .)
    ELSE            reduce using rule 49 (EL -> FALSE .)
    EIF             reduce using rule 49 (EL -> FALSE .)
    WEND            reduce using rule 49 (EL -> FALSE .)
    NEXT            reduce using rule 49 (EL -> FALSE .)
    CLOSINGPAR      reduce using rule 49 (EL -> FALSE .)


state 31

    (50) EL -> OPENPAR . O CLOSINGPAR Olt
    (56) O -> . WORD EQUALTO WORD
    (57) O -> . EA OPR EA
    (58) O -> . ID OPR ID
    (59) O -> . ID OPR EA
    (60) O -> . EA OPR ID
    (35) EA -> . P PLUS EA
    (36) EA -> . P MINUS EA
    (37) EA -> . P
    (38) P -> . N MULTIPLY P
    (39) P -> . N DIVIDE P
    (40) P -> . N
    (41) N -> . cte
    (42) N -> . ID
    (43) N -> . OPENPAR EA CLOSINGPAR
    (44) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (45) N -> . ID OPENBRACKET Idv CLOSINGBRACKET
    (46) cte -> . INTVAL
    (47) cte -> . FLOATVAL

    WORD            shift and go to state 57
    ID              shift and go to state 59
    OPENPAR         shift and go to state 55
    INTVAL          shift and go to state 46
    FLOATVAL        shift and go to state 47

    O                              shift and go to state 56
    EA                             shift and go to state 58
    P                              shift and go to state 42
    N                              shift and go to state 44
    cte                            shift and go to state 45

state 32

    (21) E -> FOR ID . EQUALS EA TO Ex F NEXT ID

    EQUALS          shift and go to state 60


state 33

    (22) E -> WHILE OPENPAR . EL CLOSINGPAR F WEND
    (48) EL -> . TRUE
    (49) EL -> . FALSE
    (50) EL -> . OPENPAR O CLOSINGPAR Olt

    TRUE            shift and go to state 29
    FALSE           shift and go to state 30
    OPENPAR         shift and go to state 31

    EL                             shift and go to state 61

state 34

    (23) E -> GOSUB ID .

    LET             reduce using rule 23 (E -> GOSUB ID .)
    DIM             reduce using rule 23 (E -> GOSUB ID .)
    IF              reduce using rule 23 (E -> GOSUB ID .)
    FOR             reduce using rule 23 (E -> GOSUB ID .)
    WHILE           reduce using rule 23 (E -> GOSUB ID .)
    GOSUB           reduce using rule 23 (E -> GOSUB ID .)
    INPUT           reduce using rule 23 (E -> GOSUB ID .)
    PRINT           reduce using rule 23 (E -> GOSUB ID .)
    SUBPROCEDURE    reduce using rule 23 (E -> GOSUB ID .)
    END             reduce using rule 23 (E -> GOSUB ID .)
    RETURN          reduce using rule 23 (E -> GOSUB ID .)
    ELSE            reduce using rule 23 (E -> GOSUB ID .)
    EIF             reduce using rule 23 (E -> GOSUB ID .)
    WEND            reduce using rule 23 (E -> GOSUB ID .)
    NEXT            reduce using rule 23 (E -> GOSUB ID .)


state 35

    (24) E -> INPUT ES . COMA IDEx

    COMA            shift and go to state 62


state 36

    (34) ES -> WORDVAL .

    COMA            reduce using rule 34 (ES -> WORDVAL .)
    LET             reduce using rule 34 (ES -> WORDVAL .)
    DIM             reduce using rule 34 (ES -> WORDVAL .)
    IF              reduce using rule 34 (ES -> WORDVAL .)
    FOR             reduce using rule 34 (ES -> WORDVAL .)
    WHILE           reduce using rule 34 (ES -> WORDVAL .)
    GOSUB           reduce using rule 34 (ES -> WORDVAL .)
    INPUT           reduce using rule 34 (ES -> WORDVAL .)
    PRINT           reduce using rule 34 (ES -> WORDVAL .)
    SUBPROCEDURE    reduce using rule 34 (ES -> WORDVAL .)
    END             reduce using rule 34 (ES -> WORDVAL .)
    RETURN          reduce using rule 34 (ES -> WORDVAL .)
    ELSE            reduce using rule 34 (ES -> WORDVAL .)
    EIF             reduce using rule 34 (ES -> WORDVAL .)
    WEND            reduce using rule 34 (ES -> WORDVAL .)
    NEXT            reduce using rule 34 (ES -> WORDVAL .)


state 37

    (25) E -> PRINT Ex .

    LET             reduce using rule 25 (E -> PRINT Ex .)
    DIM             reduce using rule 25 (E -> PRINT Ex .)
    IF              reduce using rule 25 (E -> PRINT Ex .)
    FOR             reduce using rule 25 (E -> PRINT Ex .)
    WHILE           reduce using rule 25 (E -> PRINT Ex .)
    GOSUB           reduce using rule 25 (E -> PRINT Ex .)
    INPUT           reduce using rule 25 (E -> PRINT Ex .)
    PRINT           reduce using rule 25 (E -> PRINT Ex .)
    SUBPROCEDURE    reduce using rule 25 (E -> PRINT Ex .)
    END             reduce using rule 25 (E -> PRINT Ex .)
    RETURN          reduce using rule 25 (E -> PRINT Ex .)
    ELSE            reduce using rule 25 (E -> PRINT Ex .)
    EIF             reduce using rule 25 (E -> PRINT Ex .)
    WEND            reduce using rule 25 (E -> PRINT Ex .)
    NEXT            reduce using rule 25 (E -> PRINT Ex .)


state 38

    (30) Ex -> EA .

    LET             reduce using rule 30 (Ex -> EA .)
    DIM             reduce using rule 30 (Ex -> EA .)
    IF              reduce using rule 30 (Ex -> EA .)
    FOR             reduce using rule 30 (Ex -> EA .)
    WHILE           reduce using rule 30 (Ex -> EA .)
    GOSUB           reduce using rule 30 (Ex -> EA .)
    INPUT           reduce using rule 30 (Ex -> EA .)
    PRINT           reduce using rule 30 (Ex -> EA .)
    SUBPROCEDURE    reduce using rule 30 (Ex -> EA .)
    END             reduce using rule 30 (Ex -> EA .)
    RETURN          reduce using rule 30 (Ex -> EA .)
    ELSE            reduce using rule 30 (Ex -> EA .)
    EIF             reduce using rule 30 (Ex -> EA .)
    WEND            reduce using rule 30 (Ex -> EA .)
    NEXT            reduce using rule 30 (Ex -> EA .)


state 39

    (31) Ex -> ES .

    LET             reduce using rule 31 (Ex -> ES .)
    DIM             reduce using rule 31 (Ex -> ES .)
    IF              reduce using rule 31 (Ex -> ES .)
    FOR             reduce using rule 31 (Ex -> ES .)
    WHILE           reduce using rule 31 (Ex -> ES .)
    GOSUB           reduce using rule 31 (Ex -> ES .)
    INPUT           reduce using rule 31 (Ex -> ES .)
    PRINT           reduce using rule 31 (Ex -> ES .)
    SUBPROCEDURE    reduce using rule 31 (Ex -> ES .)
    END             reduce using rule 31 (Ex -> ES .)
    RETURN          reduce using rule 31 (Ex -> ES .)
    ELSE            reduce using rule 31 (Ex -> ES .)
    EIF             reduce using rule 31 (Ex -> ES .)
    WEND            reduce using rule 31 (Ex -> ES .)
    NEXT            reduce using rule 31 (Ex -> ES .)


state 40

    (32) Ex -> EL .

    LET             reduce using rule 32 (Ex -> EL .)
    DIM             reduce using rule 32 (Ex -> EL .)
    IF              reduce using rule 32 (Ex -> EL .)
    FOR             reduce using rule 32 (Ex -> EL .)
    WHILE           reduce using rule 32 (Ex -> EL .)
    GOSUB           reduce using rule 32 (Ex -> EL .)
    INPUT           reduce using rule 32 (Ex -> EL .)
    PRINT           reduce using rule 32 (Ex -> EL .)
    SUBPROCEDURE    reduce using rule 32 (Ex -> EL .)
    END             reduce using rule 32 (Ex -> EL .)
    RETURN          reduce using rule 32 (Ex -> EL .)
    ELSE            reduce using rule 32 (Ex -> EL .)
    EIF             reduce using rule 32 (Ex -> EL .)
    WEND            reduce using rule 32 (Ex -> EL .)
    NEXT            reduce using rule 32 (Ex -> EL .)


state 41

    (33) Ex -> ID .
    (42) N -> ID .
    (44) N -> ID . OPENBRACKET INTVAL CLOSINGBRACKET
    (45) N -> ID . OPENBRACKET Idv CLOSINGBRACKET

  ! reduce/reduce conflict for LET resolved using rule 33 (Ex -> ID .)
  ! reduce/reduce conflict for DIM resolved using rule 33 (Ex -> ID .)
  ! reduce/reduce conflict for IF resolved using rule 33 (Ex -> ID .)
  ! reduce/reduce conflict for FOR resolved using rule 33 (Ex -> ID .)
  ! reduce/reduce conflict for WHILE resolved using rule 33 (Ex -> ID .)
  ! reduce/reduce conflict for GOSUB resolved using rule 33 (Ex -> ID .)
  ! reduce/reduce conflict for INPUT resolved using rule 33 (Ex -> ID .)
  ! reduce/reduce conflict for PRINT resolved using rule 33 (Ex -> ID .)
  ! reduce/reduce conflict for SUBPROCEDURE resolved using rule 33 (Ex -> ID .)
  ! reduce/reduce conflict for END resolved using rule 33 (Ex -> ID .)
  ! reduce/reduce conflict for RETURN resolved using rule 33 (Ex -> ID .)
  ! reduce/reduce conflict for ELSE resolved using rule 33 (Ex -> ID .)
  ! reduce/reduce conflict for EIF resolved using rule 33 (Ex -> ID .)
  ! reduce/reduce conflict for WEND resolved using rule 33 (Ex -> ID .)
  ! reduce/reduce conflict for NEXT resolved using rule 33 (Ex -> ID .)
    LET             reduce using rule 33 (Ex -> ID .)
    DIM             reduce using rule 33 (Ex -> ID .)
    IF              reduce using rule 33 (Ex -> ID .)
    FOR             reduce using rule 33 (Ex -> ID .)
    WHILE           reduce using rule 33 (Ex -> ID .)
    GOSUB           reduce using rule 33 (Ex -> ID .)
    INPUT           reduce using rule 33 (Ex -> ID .)
    PRINT           reduce using rule 33 (Ex -> ID .)
    SUBPROCEDURE    reduce using rule 33 (Ex -> ID .)
    END             reduce using rule 33 (Ex -> ID .)
    RETURN          reduce using rule 33 (Ex -> ID .)
    ELSE            reduce using rule 33 (Ex -> ID .)
    EIF             reduce using rule 33 (Ex -> ID .)
    WEND            reduce using rule 33 (Ex -> ID .)
    NEXT            reduce using rule 33 (Ex -> ID .)
    MULTIPLY        reduce using rule 42 (N -> ID .)
    DIVIDE          reduce using rule 42 (N -> ID .)
    PLUS            reduce using rule 42 (N -> ID .)
    MINUS           reduce using rule 42 (N -> ID .)
    OPENBRACKET     shift and go to state 63

  ! LET             [ reduce using rule 42 (N -> ID .) ]
  ! DIM             [ reduce using rule 42 (N -> ID .) ]
  ! IF              [ reduce using rule 42 (N -> ID .) ]
  ! FOR             [ reduce using rule 42 (N -> ID .) ]
  ! WHILE           [ reduce using rule 42 (N -> ID .) ]
  ! GOSUB           [ reduce using rule 42 (N -> ID .) ]
  ! INPUT           [ reduce using rule 42 (N -> ID .) ]
  ! PRINT           [ reduce using rule 42 (N -> ID .) ]
  ! SUBPROCEDURE    [ reduce using rule 42 (N -> ID .) ]
  ! END             [ reduce using rule 42 (N -> ID .) ]
  ! RETURN          [ reduce using rule 42 (N -> ID .) ]
  ! ELSE            [ reduce using rule 42 (N -> ID .) ]
  ! EIF             [ reduce using rule 42 (N -> ID .) ]
  ! WEND            [ reduce using rule 42 (N -> ID .) ]
  ! NEXT            [ reduce using rule 42 (N -> ID .) ]


state 42

    (35) EA -> P . PLUS EA
    (36) EA -> P . MINUS EA
    (37) EA -> P .

    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    LET             reduce using rule 37 (EA -> P .)
    DIM             reduce using rule 37 (EA -> P .)
    IF              reduce using rule 37 (EA -> P .)
    FOR             reduce using rule 37 (EA -> P .)
    WHILE           reduce using rule 37 (EA -> P .)
    GOSUB           reduce using rule 37 (EA -> P .)
    INPUT           reduce using rule 37 (EA -> P .)
    PRINT           reduce using rule 37 (EA -> P .)
    SUBPROCEDURE    reduce using rule 37 (EA -> P .)
    END             reduce using rule 37 (EA -> P .)
    RETURN          reduce using rule 37 (EA -> P .)
    ELSE            reduce using rule 37 (EA -> P .)
    EIF             reduce using rule 37 (EA -> P .)
    WEND            reduce using rule 37 (EA -> P .)
    NEXT            reduce using rule 37 (EA -> P .)
    EQUALTO         reduce using rule 37 (EA -> P .)
    GREATHER        reduce using rule 37 (EA -> P .)
    GREATHEREQUAL   reduce using rule 37 (EA -> P .)
    SMALLER         reduce using rule 37 (EA -> P .)
    SMALLEREQUAL    reduce using rule 37 (EA -> P .)
    NOTEQUAL        reduce using rule 37 (EA -> P .)
    CLOSINGPAR      reduce using rule 37 (EA -> P .)
    TO              reduce using rule 37 (EA -> P .)
    CLOSINGBRACKET  reduce using rule 37 (EA -> P .)


state 43

    (50) EL -> OPENPAR . O CLOSINGPAR Olt
    (43) N -> OPENPAR . EA CLOSINGPAR
    (56) O -> . WORD EQUALTO WORD
    (57) O -> . EA OPR EA
    (58) O -> . ID OPR ID
    (59) O -> . ID OPR EA
    (60) O -> . EA OPR ID
    (35) EA -> . P PLUS EA
    (36) EA -> . P MINUS EA
    (37) EA -> . P
    (38) P -> . N MULTIPLY P
    (39) P -> . N DIVIDE P
    (40) P -> . N
    (41) N -> . cte
    (42) N -> . ID
    (43) N -> . OPENPAR EA CLOSINGPAR
    (44) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (45) N -> . ID OPENBRACKET Idv CLOSINGBRACKET
    (46) cte -> . INTVAL
    (47) cte -> . FLOATVAL

    WORD            shift and go to state 57
    ID              shift and go to state 59
    OPENPAR         shift and go to state 55
    INTVAL          shift and go to state 46
    FLOATVAL        shift and go to state 47

    O                              shift and go to state 56
    EA                             shift and go to state 66
    P                              shift and go to state 42
    N                              shift and go to state 44
    cte                            shift and go to state 45

state 44

    (38) P -> N . MULTIPLY P
    (39) P -> N . DIVIDE P
    (40) P -> N .

    MULTIPLY        shift and go to state 67
    DIVIDE          shift and go to state 68
    PLUS            reduce using rule 40 (P -> N .)
    MINUS           reduce using rule 40 (P -> N .)
    LET             reduce using rule 40 (P -> N .)
    DIM             reduce using rule 40 (P -> N .)
    IF              reduce using rule 40 (P -> N .)
    FOR             reduce using rule 40 (P -> N .)
    WHILE           reduce using rule 40 (P -> N .)
    GOSUB           reduce using rule 40 (P -> N .)
    INPUT           reduce using rule 40 (P -> N .)
    PRINT           reduce using rule 40 (P -> N .)
    SUBPROCEDURE    reduce using rule 40 (P -> N .)
    END             reduce using rule 40 (P -> N .)
    RETURN          reduce using rule 40 (P -> N .)
    ELSE            reduce using rule 40 (P -> N .)
    EIF             reduce using rule 40 (P -> N .)
    WEND            reduce using rule 40 (P -> N .)
    NEXT            reduce using rule 40 (P -> N .)
    EQUALTO         reduce using rule 40 (P -> N .)
    GREATHER        reduce using rule 40 (P -> N .)
    GREATHEREQUAL   reduce using rule 40 (P -> N .)
    SMALLER         reduce using rule 40 (P -> N .)
    SMALLEREQUAL    reduce using rule 40 (P -> N .)
    NOTEQUAL        reduce using rule 40 (P -> N .)
    CLOSINGPAR      reduce using rule 40 (P -> N .)
    TO              reduce using rule 40 (P -> N .)
    CLOSINGBRACKET  reduce using rule 40 (P -> N .)


state 45

    (41) N -> cte .

    MULTIPLY        reduce using rule 41 (N -> cte .)
    DIVIDE          reduce using rule 41 (N -> cte .)
    PLUS            reduce using rule 41 (N -> cte .)
    MINUS           reduce using rule 41 (N -> cte .)
    LET             reduce using rule 41 (N -> cte .)
    DIM             reduce using rule 41 (N -> cte .)
    IF              reduce using rule 41 (N -> cte .)
    FOR             reduce using rule 41 (N -> cte .)
    WHILE           reduce using rule 41 (N -> cte .)
    GOSUB           reduce using rule 41 (N -> cte .)
    INPUT           reduce using rule 41 (N -> cte .)
    PRINT           reduce using rule 41 (N -> cte .)
    SUBPROCEDURE    reduce using rule 41 (N -> cte .)
    END             reduce using rule 41 (N -> cte .)
    RETURN          reduce using rule 41 (N -> cte .)
    ELSE            reduce using rule 41 (N -> cte .)
    EIF             reduce using rule 41 (N -> cte .)
    WEND            reduce using rule 41 (N -> cte .)
    NEXT            reduce using rule 41 (N -> cte .)
    EQUALTO         reduce using rule 41 (N -> cte .)
    GREATHER        reduce using rule 41 (N -> cte .)
    GREATHEREQUAL   reduce using rule 41 (N -> cte .)
    SMALLER         reduce using rule 41 (N -> cte .)
    SMALLEREQUAL    reduce using rule 41 (N -> cte .)
    NOTEQUAL        reduce using rule 41 (N -> cte .)
    CLOSINGPAR      reduce using rule 41 (N -> cte .)
    TO              reduce using rule 41 (N -> cte .)
    CLOSINGBRACKET  reduce using rule 41 (N -> cte .)


state 46

    (46) cte -> INTVAL .

    MULTIPLY        reduce using rule 46 (cte -> INTVAL .)
    DIVIDE          reduce using rule 46 (cte -> INTVAL .)
    PLUS            reduce using rule 46 (cte -> INTVAL .)
    MINUS           reduce using rule 46 (cte -> INTVAL .)
    LET             reduce using rule 46 (cte -> INTVAL .)
    DIM             reduce using rule 46 (cte -> INTVAL .)
    IF              reduce using rule 46 (cte -> INTVAL .)
    FOR             reduce using rule 46 (cte -> INTVAL .)
    WHILE           reduce using rule 46 (cte -> INTVAL .)
    GOSUB           reduce using rule 46 (cte -> INTVAL .)
    INPUT           reduce using rule 46 (cte -> INTVAL .)
    PRINT           reduce using rule 46 (cte -> INTVAL .)
    SUBPROCEDURE    reduce using rule 46 (cte -> INTVAL .)
    END             reduce using rule 46 (cte -> INTVAL .)
    RETURN          reduce using rule 46 (cte -> INTVAL .)
    ELSE            reduce using rule 46 (cte -> INTVAL .)
    EIF             reduce using rule 46 (cte -> INTVAL .)
    WEND            reduce using rule 46 (cte -> INTVAL .)
    NEXT            reduce using rule 46 (cte -> INTVAL .)
    EQUALTO         reduce using rule 46 (cte -> INTVAL .)
    GREATHER        reduce using rule 46 (cte -> INTVAL .)
    GREATHEREQUAL   reduce using rule 46 (cte -> INTVAL .)
    SMALLER         reduce using rule 46 (cte -> INTVAL .)
    SMALLEREQUAL    reduce using rule 46 (cte -> INTVAL .)
    NOTEQUAL        reduce using rule 46 (cte -> INTVAL .)
    CLOSINGPAR      reduce using rule 46 (cte -> INTVAL .)
    TO              reduce using rule 46 (cte -> INTVAL .)
    CLOSINGBRACKET  reduce using rule 46 (cte -> INTVAL .)


state 47

    (47) cte -> FLOATVAL .

    MULTIPLY        reduce using rule 47 (cte -> FLOATVAL .)
    DIVIDE          reduce using rule 47 (cte -> FLOATVAL .)
    PLUS            reduce using rule 47 (cte -> FLOATVAL .)
    MINUS           reduce using rule 47 (cte -> FLOATVAL .)
    LET             reduce using rule 47 (cte -> FLOATVAL .)
    DIM             reduce using rule 47 (cte -> FLOATVAL .)
    IF              reduce using rule 47 (cte -> FLOATVAL .)
    FOR             reduce using rule 47 (cte -> FLOATVAL .)
    WHILE           reduce using rule 47 (cte -> FLOATVAL .)
    GOSUB           reduce using rule 47 (cte -> FLOATVAL .)
    INPUT           reduce using rule 47 (cte -> FLOATVAL .)
    PRINT           reduce using rule 47 (cte -> FLOATVAL .)
    SUBPROCEDURE    reduce using rule 47 (cte -> FLOATVAL .)
    END             reduce using rule 47 (cte -> FLOATVAL .)
    RETURN          reduce using rule 47 (cte -> FLOATVAL .)
    ELSE            reduce using rule 47 (cte -> FLOATVAL .)
    EIF             reduce using rule 47 (cte -> FLOATVAL .)
    WEND            reduce using rule 47 (cte -> FLOATVAL .)
    NEXT            reduce using rule 47 (cte -> FLOATVAL .)
    EQUALTO         reduce using rule 47 (cte -> FLOATVAL .)
    GREATHER        reduce using rule 47 (cte -> FLOATVAL .)
    GREATHEREQUAL   reduce using rule 47 (cte -> FLOATVAL .)
    SMALLER         reduce using rule 47 (cte -> FLOATVAL .)
    SMALLEREQUAL    reduce using rule 47 (cte -> FLOATVAL .)
    NOTEQUAL        reduce using rule 47 (cte -> FLOATVAL .)
    CLOSINGPAR      reduce using rule 47 (cte -> FLOATVAL .)
    TO              reduce using rule 47 (cte -> FLOATVAL .)
    CLOSINGBRACKET  reduce using rule 47 (cte -> FLOATVAL .)


state 48

    (2) V -> DIM Idv AS . T Arr V
    (9) T -> . INT
    (10) T -> . FLOAT
    (11) T -> . WORD

    INT             shift and go to state 70
    FLOAT           shift and go to state 71
    WORD            shift and go to state 72

    T                              shift and go to state 69

state 49

    (4) Idv -> ID COMA . Idv
    (4) Idv -> . ID COMA Idv
    (5) Idv -> . ID

    ID              shift and go to state 19

    Idv                            shift and go to state 73

state 50

    (1) PROGRAMA -> PROGRAM V M S END .

    $end            reduce using rule 1 (PROGRAMA -> PROGRAM V M S END .)


state 51

    (12) S -> SUBPROCEDURE ID . TWOPOINTS M RETURN S

    TWOPOINTS       shift and go to state 74


state 52

    (18) E -> LET Idv EQUALS . Ex
    (30) Ex -> . EA
    (31) Ex -> . ES
    (32) Ex -> . EL
    (33) Ex -> . ID
    (35) EA -> . P PLUS EA
    (36) EA -> . P MINUS EA
    (37) EA -> . P
    (34) ES -> . WORDVAL
    (48) EL -> . TRUE
    (49) EL -> . FALSE
    (50) EL -> . OPENPAR O CLOSINGPAR Olt
    (38) P -> . N MULTIPLY P
    (39) P -> . N DIVIDE P
    (40) P -> . N
    (41) N -> . cte
    (42) N -> . ID
    (43) N -> . OPENPAR EA CLOSINGPAR
    (44) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (45) N -> . ID OPENBRACKET Idv CLOSINGBRACKET
    (46) cte -> . INTVAL
    (47) cte -> . FLOATVAL

    ID              shift and go to state 41
    WORDVAL         shift and go to state 36
    TRUE            shift and go to state 29
    FALSE           shift and go to state 30
    OPENPAR         shift and go to state 43
    INTVAL          shift and go to state 46
    FLOATVAL        shift and go to state 47

    Ex                             shift and go to state 75
    EA                             shift and go to state 38
    ES                             shift and go to state 39
    EL                             shift and go to state 40
    P                              shift and go to state 42
    N                              shift and go to state 44
    cte                            shift and go to state 45

state 53

    (19) E -> DIM Idv AS . T Arr
    (9) T -> . INT
    (10) T -> . FLOAT
    (11) T -> . WORD

    INT             shift and go to state 70
    FLOAT           shift and go to state 71
    WORD            shift and go to state 72

    T                              shift and go to state 76

state 54

    (20) E -> IF EL THEN . F Esf EIF
    (16) F -> . E F
    (17) F -> . empty
    (18) E -> . LET Idv EQUALS Ex
    (19) E -> . DIM Idv AS T Arr
    (20) E -> . IF EL THEN F Esf EIF
    (21) E -> . FOR ID EQUALS EA TO Ex F NEXT ID
    (22) E -> . WHILE OPENPAR EL CLOSINGPAR F WEND
    (23) E -> . GOSUB ID
    (24) E -> . INPUT ES COMA IDEx
    (25) E -> . PRINT Ex
    (67) empty -> .

    LET             shift and go to state 10
    DIM             shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    GOSUB           shift and go to state 15
    INPUT           shift and go to state 16
    PRINT           shift and go to state 17
    ELSE            reduce using rule 67 (empty -> .)
    EIF             reduce using rule 67 (empty -> .)

    F                              shift and go to state 77
    E                              shift and go to state 9
    empty                          shift and go to state 25

state 55

    (43) N -> OPENPAR . EA CLOSINGPAR
    (35) EA -> . P PLUS EA
    (36) EA -> . P MINUS EA
    (37) EA -> . P
    (38) P -> . N MULTIPLY P
    (39) P -> . N DIVIDE P
    (40) P -> . N
    (41) N -> . cte
    (42) N -> . ID
    (43) N -> . OPENPAR EA CLOSINGPAR
    (44) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (45) N -> . ID OPENBRACKET Idv CLOSINGBRACKET
    (46) cte -> . INTVAL
    (47) cte -> . FLOATVAL

    ID              shift and go to state 79
    OPENPAR         shift and go to state 55
    INTVAL          shift and go to state 46
    FLOATVAL        shift and go to state 47

    EA                             shift and go to state 78
    P                              shift and go to state 42
    N                              shift and go to state 44
    cte                            shift and go to state 45

state 56

    (50) EL -> OPENPAR O . CLOSINGPAR Olt

    CLOSINGPAR      shift and go to state 80


state 57

    (56) O -> WORD . EQUALTO WORD

    EQUALTO         shift and go to state 81


state 58

    (57) O -> EA . OPR EA
    (60) O -> EA . OPR ID
    (61) OPR -> . EQUALTO
    (62) OPR -> . GREATHER
    (63) OPR -> . GREATHEREQUAL
    (64) OPR -> . SMALLER
    (65) OPR -> . SMALLEREQUAL
    (66) OPR -> . NOTEQUAL

    EQUALTO         shift and go to state 83
    GREATHER        shift and go to state 84
    GREATHEREQUAL   shift and go to state 85
    SMALLER         shift and go to state 86
    SMALLEREQUAL    shift and go to state 87
    NOTEQUAL        shift and go to state 88

    OPR                            shift and go to state 82

state 59

    (58) O -> ID . OPR ID
    (59) O -> ID . OPR EA
    (42) N -> ID .
    (44) N -> ID . OPENBRACKET INTVAL CLOSINGBRACKET
    (45) N -> ID . OPENBRACKET Idv CLOSINGBRACKET
    (61) OPR -> . EQUALTO
    (62) OPR -> . GREATHER
    (63) OPR -> . GREATHEREQUAL
    (64) OPR -> . SMALLER
    (65) OPR -> . SMALLEREQUAL
    (66) OPR -> . NOTEQUAL

  ! shift/reduce conflict for EQUALTO resolved as shift
  ! shift/reduce conflict for GREATHER resolved as shift
  ! shift/reduce conflict for GREATHEREQUAL resolved as shift
  ! shift/reduce conflict for SMALLER resolved as shift
  ! shift/reduce conflict for SMALLEREQUAL resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
    MULTIPLY        reduce using rule 42 (N -> ID .)
    DIVIDE          reduce using rule 42 (N -> ID .)
    PLUS            reduce using rule 42 (N -> ID .)
    MINUS           reduce using rule 42 (N -> ID .)
    CLOSINGPAR      reduce using rule 42 (N -> ID .)
    OPENBRACKET     shift and go to state 63
    EQUALTO         shift and go to state 83
    GREATHER        shift and go to state 84
    GREATHEREQUAL   shift and go to state 85
    SMALLER         shift and go to state 86
    SMALLEREQUAL    shift and go to state 87
    NOTEQUAL        shift and go to state 88

  ! EQUALTO         [ reduce using rule 42 (N -> ID .) ]
  ! GREATHER        [ reduce using rule 42 (N -> ID .) ]
  ! GREATHEREQUAL   [ reduce using rule 42 (N -> ID .) ]
  ! SMALLER         [ reduce using rule 42 (N -> ID .) ]
  ! SMALLEREQUAL    [ reduce using rule 42 (N -> ID .) ]
  ! NOTEQUAL        [ reduce using rule 42 (N -> ID .) ]

    OPR                            shift and go to state 89

state 60

    (21) E -> FOR ID EQUALS . EA TO Ex F NEXT ID
    (35) EA -> . P PLUS EA
    (36) EA -> . P MINUS EA
    (37) EA -> . P
    (38) P -> . N MULTIPLY P
    (39) P -> . N DIVIDE P
    (40) P -> . N
    (41) N -> . cte
    (42) N -> . ID
    (43) N -> . OPENPAR EA CLOSINGPAR
    (44) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (45) N -> . ID OPENBRACKET Idv CLOSINGBRACKET
    (46) cte -> . INTVAL
    (47) cte -> . FLOATVAL

    ID              shift and go to state 79
    OPENPAR         shift and go to state 55
    INTVAL          shift and go to state 46
    FLOATVAL        shift and go to state 47

    EA                             shift and go to state 90
    P                              shift and go to state 42
    N                              shift and go to state 44
    cte                            shift and go to state 45

state 61

    (22) E -> WHILE OPENPAR EL . CLOSINGPAR F WEND

    CLOSINGPAR      shift and go to state 91


state 62

    (24) E -> INPUT ES COMA . IDEx
    (28) IDEx -> . ID
    (29) IDEx -> . ID OPENBRACKET Idv CLOSINGBRACKET

    ID              shift and go to state 93

    IDEx                           shift and go to state 92

state 63

    (44) N -> ID OPENBRACKET . INTVAL CLOSINGBRACKET
    (45) N -> ID OPENBRACKET . Idv CLOSINGBRACKET
    (4) Idv -> . ID COMA Idv
    (5) Idv -> . ID

    INTVAL          shift and go to state 94
    ID              shift and go to state 19

    Idv                            shift and go to state 95

state 64

    (35) EA -> P PLUS . EA
    (35) EA -> . P PLUS EA
    (36) EA -> . P MINUS EA
    (37) EA -> . P
    (38) P -> . N MULTIPLY P
    (39) P -> . N DIVIDE P
    (40) P -> . N
    (41) N -> . cte
    (42) N -> . ID
    (43) N -> . OPENPAR EA CLOSINGPAR
    (44) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (45) N -> . ID OPENBRACKET Idv CLOSINGBRACKET
    (46) cte -> . INTVAL
    (47) cte -> . FLOATVAL

    ID              shift and go to state 79
    OPENPAR         shift and go to state 55
    INTVAL          shift and go to state 46
    FLOATVAL        shift and go to state 47

    P                              shift and go to state 42
    EA                             shift and go to state 96
    N                              shift and go to state 44
    cte                            shift and go to state 45

state 65

    (36) EA -> P MINUS . EA
    (35) EA -> . P PLUS EA
    (36) EA -> . P MINUS EA
    (37) EA -> . P
    (38) P -> . N MULTIPLY P
    (39) P -> . N DIVIDE P
    (40) P -> . N
    (41) N -> . cte
    (42) N -> . ID
    (43) N -> . OPENPAR EA CLOSINGPAR
    (44) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (45) N -> . ID OPENBRACKET Idv CLOSINGBRACKET
    (46) cte -> . INTVAL
    (47) cte -> . FLOATVAL

    ID              shift and go to state 79
    OPENPAR         shift and go to state 55
    INTVAL          shift and go to state 46
    FLOATVAL        shift and go to state 47

    P                              shift and go to state 42
    EA                             shift and go to state 97
    N                              shift and go to state 44
    cte                            shift and go to state 45

state 66

    (43) N -> OPENPAR EA . CLOSINGPAR
    (57) O -> EA . OPR EA
    (60) O -> EA . OPR ID
    (61) OPR -> . EQUALTO
    (62) OPR -> . GREATHER
    (63) OPR -> . GREATHEREQUAL
    (64) OPR -> . SMALLER
    (65) OPR -> . SMALLEREQUAL
    (66) OPR -> . NOTEQUAL

    CLOSINGPAR      shift and go to state 98
    EQUALTO         shift and go to state 83
    GREATHER        shift and go to state 84
    GREATHEREQUAL   shift and go to state 85
    SMALLER         shift and go to state 86
    SMALLEREQUAL    shift and go to state 87
    NOTEQUAL        shift and go to state 88

    OPR                            shift and go to state 82

state 67

    (38) P -> N MULTIPLY . P
    (38) P -> . N MULTIPLY P
    (39) P -> . N DIVIDE P
    (40) P -> . N
    (41) N -> . cte
    (42) N -> . ID
    (43) N -> . OPENPAR EA CLOSINGPAR
    (44) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (45) N -> . ID OPENBRACKET Idv CLOSINGBRACKET
    (46) cte -> . INTVAL
    (47) cte -> . FLOATVAL

    ID              shift and go to state 79
    OPENPAR         shift and go to state 55
    INTVAL          shift and go to state 46
    FLOATVAL        shift and go to state 47

    N                              shift and go to state 44
    P                              shift and go to state 99
    cte                            shift and go to state 45

state 68

    (39) P -> N DIVIDE . P
    (38) P -> . N MULTIPLY P
    (39) P -> . N DIVIDE P
    (40) P -> . N
    (41) N -> . cte
    (42) N -> . ID
    (43) N -> . OPENPAR EA CLOSINGPAR
    (44) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (45) N -> . ID OPENBRACKET Idv CLOSINGBRACKET
    (46) cte -> . INTVAL
    (47) cte -> . FLOATVAL

    ID              shift and go to state 79
    OPENPAR         shift and go to state 55
    INTVAL          shift and go to state 46
    FLOATVAL        shift and go to state 47

    N                              shift and go to state 44
    P                              shift and go to state 100
    cte                            shift and go to state 45

state 69

    (2) V -> DIM Idv AS T . Arr V
    (6) Arr -> . OPENBRACKET EA CLOSINGBRACKET Arr
    (7) Arr -> . OPENBRACKET ID CLOSINGBRACKET Arr
    (8) Arr -> . empty
    (67) empty -> .

    OPENBRACKET     shift and go to state 102
    DIM             reduce using rule 67 (empty -> .)
    LET             reduce using rule 67 (empty -> .)
    IF              reduce using rule 67 (empty -> .)
    FOR             reduce using rule 67 (empty -> .)
    WHILE           reduce using rule 67 (empty -> .)
    GOSUB           reduce using rule 67 (empty -> .)
    INPUT           reduce using rule 67 (empty -> .)
    PRINT           reduce using rule 67 (empty -> .)
    SUBPROCEDURE    reduce using rule 67 (empty -> .)
    END             reduce using rule 67 (empty -> .)

    Arr                            shift and go to state 101
    empty                          shift and go to state 103

state 70

    (9) T -> INT .

    OPENBRACKET     reduce using rule 9 (T -> INT .)
    DIM             reduce using rule 9 (T -> INT .)
    LET             reduce using rule 9 (T -> INT .)
    IF              reduce using rule 9 (T -> INT .)
    FOR             reduce using rule 9 (T -> INT .)
    WHILE           reduce using rule 9 (T -> INT .)
    GOSUB           reduce using rule 9 (T -> INT .)
    INPUT           reduce using rule 9 (T -> INT .)
    PRINT           reduce using rule 9 (T -> INT .)
    SUBPROCEDURE    reduce using rule 9 (T -> INT .)
    END             reduce using rule 9 (T -> INT .)
    RETURN          reduce using rule 9 (T -> INT .)
    ELSE            reduce using rule 9 (T -> INT .)
    EIF             reduce using rule 9 (T -> INT .)
    WEND            reduce using rule 9 (T -> INT .)
    NEXT            reduce using rule 9 (T -> INT .)


state 71

    (10) T -> FLOAT .

    OPENBRACKET     reduce using rule 10 (T -> FLOAT .)
    DIM             reduce using rule 10 (T -> FLOAT .)
    LET             reduce using rule 10 (T -> FLOAT .)
    IF              reduce using rule 10 (T -> FLOAT .)
    FOR             reduce using rule 10 (T -> FLOAT .)
    WHILE           reduce using rule 10 (T -> FLOAT .)
    GOSUB           reduce using rule 10 (T -> FLOAT .)
    INPUT           reduce using rule 10 (T -> FLOAT .)
    PRINT           reduce using rule 10 (T -> FLOAT .)
    SUBPROCEDURE    reduce using rule 10 (T -> FLOAT .)
    END             reduce using rule 10 (T -> FLOAT .)
    RETURN          reduce using rule 10 (T -> FLOAT .)
    ELSE            reduce using rule 10 (T -> FLOAT .)
    EIF             reduce using rule 10 (T -> FLOAT .)
    WEND            reduce using rule 10 (T -> FLOAT .)
    NEXT            reduce using rule 10 (T -> FLOAT .)


state 72

    (11) T -> WORD .

    OPENBRACKET     reduce using rule 11 (T -> WORD .)
    DIM             reduce using rule 11 (T -> WORD .)
    LET             reduce using rule 11 (T -> WORD .)
    IF              reduce using rule 11 (T -> WORD .)
    FOR             reduce using rule 11 (T -> WORD .)
    WHILE           reduce using rule 11 (T -> WORD .)
    GOSUB           reduce using rule 11 (T -> WORD .)
    INPUT           reduce using rule 11 (T -> WORD .)
    PRINT           reduce using rule 11 (T -> WORD .)
    SUBPROCEDURE    reduce using rule 11 (T -> WORD .)
    END             reduce using rule 11 (T -> WORD .)
    RETURN          reduce using rule 11 (T -> WORD .)
    ELSE            reduce using rule 11 (T -> WORD .)
    EIF             reduce using rule 11 (T -> WORD .)
    WEND            reduce using rule 11 (T -> WORD .)
    NEXT            reduce using rule 11 (T -> WORD .)


state 73

    (4) Idv -> ID COMA Idv .

    AS              reduce using rule 4 (Idv -> ID COMA Idv .)
    EQUALS          reduce using rule 4 (Idv -> ID COMA Idv .)
    CLOSINGBRACKET  reduce using rule 4 (Idv -> ID COMA Idv .)


state 74

    (12) S -> SUBPROCEDURE ID TWOPOINTS . M RETURN S
    (14) M -> . F M
    (15) M -> . empty
    (16) F -> . E F
    (17) F -> . empty
    (67) empty -> .
    (18) E -> . LET Idv EQUALS Ex
    (19) E -> . DIM Idv AS T Arr
    (20) E -> . IF EL THEN F Esf EIF
    (21) E -> . FOR ID EQUALS EA TO Ex F NEXT ID
    (22) E -> . WHILE OPENPAR EL CLOSINGPAR F WEND
    (23) E -> . GOSUB ID
    (24) E -> . INPUT ES COMA IDEx
    (25) E -> . PRINT Ex

  ! shift/reduce conflict for LET resolved as shift
  ! shift/reduce conflict for DIM resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for GOSUB resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
    RETURN          reduce using rule 67 (empty -> .)
    LET             shift and go to state 10
    DIM             shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    GOSUB           shift and go to state 15
    INPUT           shift and go to state 16
    PRINT           shift and go to state 17

  ! LET             [ reduce using rule 67 (empty -> .) ]
  ! DIM             [ reduce using rule 67 (empty -> .) ]
  ! IF              [ reduce using rule 67 (empty -> .) ]
  ! FOR             [ reduce using rule 67 (empty -> .) ]
  ! WHILE           [ reduce using rule 67 (empty -> .) ]
  ! GOSUB           [ reduce using rule 67 (empty -> .) ]
  ! INPUT           [ reduce using rule 67 (empty -> .) ]
  ! PRINT           [ reduce using rule 67 (empty -> .) ]

    M                              shift and go to state 104
    F                              shift and go to state 7
    empty                          shift and go to state 8
    E                              shift and go to state 9

state 75

    (18) E -> LET Idv EQUALS Ex .

    LET             reduce using rule 18 (E -> LET Idv EQUALS Ex .)
    DIM             reduce using rule 18 (E -> LET Idv EQUALS Ex .)
    IF              reduce using rule 18 (E -> LET Idv EQUALS Ex .)
    FOR             reduce using rule 18 (E -> LET Idv EQUALS Ex .)
    WHILE           reduce using rule 18 (E -> LET Idv EQUALS Ex .)
    GOSUB           reduce using rule 18 (E -> LET Idv EQUALS Ex .)
    INPUT           reduce using rule 18 (E -> LET Idv EQUALS Ex .)
    PRINT           reduce using rule 18 (E -> LET Idv EQUALS Ex .)
    SUBPROCEDURE    reduce using rule 18 (E -> LET Idv EQUALS Ex .)
    END             reduce using rule 18 (E -> LET Idv EQUALS Ex .)
    RETURN          reduce using rule 18 (E -> LET Idv EQUALS Ex .)
    ELSE            reduce using rule 18 (E -> LET Idv EQUALS Ex .)
    EIF             reduce using rule 18 (E -> LET Idv EQUALS Ex .)
    WEND            reduce using rule 18 (E -> LET Idv EQUALS Ex .)
    NEXT            reduce using rule 18 (E -> LET Idv EQUALS Ex .)


state 76

    (19) E -> DIM Idv AS T . Arr
    (6) Arr -> . OPENBRACKET EA CLOSINGBRACKET Arr
    (7) Arr -> . OPENBRACKET ID CLOSINGBRACKET Arr
    (8) Arr -> . empty
    (67) empty -> .

    OPENBRACKET     shift and go to state 102
    LET             reduce using rule 67 (empty -> .)
    DIM             reduce using rule 67 (empty -> .)
    IF              reduce using rule 67 (empty -> .)
    FOR             reduce using rule 67 (empty -> .)
    WHILE           reduce using rule 67 (empty -> .)
    GOSUB           reduce using rule 67 (empty -> .)
    INPUT           reduce using rule 67 (empty -> .)
    PRINT           reduce using rule 67 (empty -> .)
    SUBPROCEDURE    reduce using rule 67 (empty -> .)
    END             reduce using rule 67 (empty -> .)
    RETURN          reduce using rule 67 (empty -> .)
    ELSE            reduce using rule 67 (empty -> .)
    EIF             reduce using rule 67 (empty -> .)
    WEND            reduce using rule 67 (empty -> .)
    NEXT            reduce using rule 67 (empty -> .)

    Arr                            shift and go to state 105
    empty                          shift and go to state 103

state 77

    (20) E -> IF EL THEN F . Esf EIF
    (26) Esf -> . ELSE F
    (27) Esf -> . empty
    (67) empty -> .

    ELSE            shift and go to state 107
    EIF             reduce using rule 67 (empty -> .)

    Esf                            shift and go to state 106
    empty                          shift and go to state 108

state 78

    (43) N -> OPENPAR EA . CLOSINGPAR

    CLOSINGPAR      shift and go to state 98


state 79

    (42) N -> ID .
    (44) N -> ID . OPENBRACKET INTVAL CLOSINGBRACKET
    (45) N -> ID . OPENBRACKET Idv CLOSINGBRACKET

    MULTIPLY        reduce using rule 42 (N -> ID .)
    DIVIDE          reduce using rule 42 (N -> ID .)
    PLUS            reduce using rule 42 (N -> ID .)
    MINUS           reduce using rule 42 (N -> ID .)
    CLOSINGPAR      reduce using rule 42 (N -> ID .)
    TO              reduce using rule 42 (N -> ID .)
    LET             reduce using rule 42 (N -> ID .)
    DIM             reduce using rule 42 (N -> ID .)
    IF              reduce using rule 42 (N -> ID .)
    FOR             reduce using rule 42 (N -> ID .)
    WHILE           reduce using rule 42 (N -> ID .)
    GOSUB           reduce using rule 42 (N -> ID .)
    INPUT           reduce using rule 42 (N -> ID .)
    PRINT           reduce using rule 42 (N -> ID .)
    SUBPROCEDURE    reduce using rule 42 (N -> ID .)
    END             reduce using rule 42 (N -> ID .)
    RETURN          reduce using rule 42 (N -> ID .)
    ELSE            reduce using rule 42 (N -> ID .)
    EIF             reduce using rule 42 (N -> ID .)
    WEND            reduce using rule 42 (N -> ID .)
    NEXT            reduce using rule 42 (N -> ID .)
    EQUALTO         reduce using rule 42 (N -> ID .)
    GREATHER        reduce using rule 42 (N -> ID .)
    GREATHEREQUAL   reduce using rule 42 (N -> ID .)
    SMALLER         reduce using rule 42 (N -> ID .)
    SMALLEREQUAL    reduce using rule 42 (N -> ID .)
    NOTEQUAL        reduce using rule 42 (N -> ID .)
    CLOSINGBRACKET  reduce using rule 42 (N -> ID .)
    OPENBRACKET     shift and go to state 63


state 80

    (50) EL -> OPENPAR O CLOSINGPAR . Olt
    (51) Olt -> . OL OPENPAR O CLOSINGPAR Olt
    (52) Olt -> . empty
    (53) OL -> . AND
    (54) OL -> . OR
    (55) OL -> . NOT
    (67) empty -> .

    AND             shift and go to state 112
    OR              shift and go to state 113
    NOT             shift and go to state 114
    THEN            reduce using rule 67 (empty -> .)
    LET             reduce using rule 67 (empty -> .)
    DIM             reduce using rule 67 (empty -> .)
    IF              reduce using rule 67 (empty -> .)
    FOR             reduce using rule 67 (empty -> .)
    WHILE           reduce using rule 67 (empty -> .)
    GOSUB           reduce using rule 67 (empty -> .)
    INPUT           reduce using rule 67 (empty -> .)
    PRINT           reduce using rule 67 (empty -> .)
    SUBPROCEDURE    reduce using rule 67 (empty -> .)
    END             reduce using rule 67 (empty -> .)
    RETURN          reduce using rule 67 (empty -> .)
    ELSE            reduce using rule 67 (empty -> .)
    EIF             reduce using rule 67 (empty -> .)
    WEND            reduce using rule 67 (empty -> .)
    NEXT            reduce using rule 67 (empty -> .)
    CLOSINGPAR      reduce using rule 67 (empty -> .)

    Olt                            shift and go to state 109
    OL                             shift and go to state 110
    empty                          shift and go to state 111

state 81

    (56) O -> WORD EQUALTO . WORD

    WORD            shift and go to state 115


state 82

    (57) O -> EA OPR . EA
    (60) O -> EA OPR . ID
    (35) EA -> . P PLUS EA
    (36) EA -> . P MINUS EA
    (37) EA -> . P
    (38) P -> . N MULTIPLY P
    (39) P -> . N DIVIDE P
    (40) P -> . N
    (41) N -> . cte
    (42) N -> . ID
    (43) N -> . OPENPAR EA CLOSINGPAR
    (44) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (45) N -> . ID OPENBRACKET Idv CLOSINGBRACKET
    (46) cte -> . INTVAL
    (47) cte -> . FLOATVAL

    ID              shift and go to state 117
    OPENPAR         shift and go to state 55
    INTVAL          shift and go to state 46
    FLOATVAL        shift and go to state 47

    EA                             shift and go to state 116
    P                              shift and go to state 42
    N                              shift and go to state 44
    cte                            shift and go to state 45

state 83

    (61) OPR -> EQUALTO .

    ID              reduce using rule 61 (OPR -> EQUALTO .)
    OPENPAR         reduce using rule 61 (OPR -> EQUALTO .)
    INTVAL          reduce using rule 61 (OPR -> EQUALTO .)
    FLOATVAL        reduce using rule 61 (OPR -> EQUALTO .)


state 84

    (62) OPR -> GREATHER .

    ID              reduce using rule 62 (OPR -> GREATHER .)
    OPENPAR         reduce using rule 62 (OPR -> GREATHER .)
    INTVAL          reduce using rule 62 (OPR -> GREATHER .)
    FLOATVAL        reduce using rule 62 (OPR -> GREATHER .)


state 85

    (63) OPR -> GREATHEREQUAL .

    ID              reduce using rule 63 (OPR -> GREATHEREQUAL .)
    OPENPAR         reduce using rule 63 (OPR -> GREATHEREQUAL .)
    INTVAL          reduce using rule 63 (OPR -> GREATHEREQUAL .)
    FLOATVAL        reduce using rule 63 (OPR -> GREATHEREQUAL .)


state 86

    (64) OPR -> SMALLER .

    ID              reduce using rule 64 (OPR -> SMALLER .)
    OPENPAR         reduce using rule 64 (OPR -> SMALLER .)
    INTVAL          reduce using rule 64 (OPR -> SMALLER .)
    FLOATVAL        reduce using rule 64 (OPR -> SMALLER .)


state 87

    (65) OPR -> SMALLEREQUAL .

    ID              reduce using rule 65 (OPR -> SMALLEREQUAL .)
    OPENPAR         reduce using rule 65 (OPR -> SMALLEREQUAL .)
    INTVAL          reduce using rule 65 (OPR -> SMALLEREQUAL .)
    FLOATVAL        reduce using rule 65 (OPR -> SMALLEREQUAL .)


state 88

    (66) OPR -> NOTEQUAL .

    ID              reduce using rule 66 (OPR -> NOTEQUAL .)
    OPENPAR         reduce using rule 66 (OPR -> NOTEQUAL .)
    INTVAL          reduce using rule 66 (OPR -> NOTEQUAL .)
    FLOATVAL        reduce using rule 66 (OPR -> NOTEQUAL .)


state 89

    (58) O -> ID OPR . ID
    (59) O -> ID OPR . EA
    (35) EA -> . P PLUS EA
    (36) EA -> . P MINUS EA
    (37) EA -> . P
    (38) P -> . N MULTIPLY P
    (39) P -> . N DIVIDE P
    (40) P -> . N
    (41) N -> . cte
    (42) N -> . ID
    (43) N -> . OPENPAR EA CLOSINGPAR
    (44) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (45) N -> . ID OPENBRACKET Idv CLOSINGBRACKET
    (46) cte -> . INTVAL
    (47) cte -> . FLOATVAL

    ID              shift and go to state 118
    OPENPAR         shift and go to state 55
    INTVAL          shift and go to state 46
    FLOATVAL        shift and go to state 47

    EA                             shift and go to state 119
    P                              shift and go to state 42
    N                              shift and go to state 44
    cte                            shift and go to state 45

state 90

    (21) E -> FOR ID EQUALS EA . TO Ex F NEXT ID

    TO              shift and go to state 120


state 91

    (22) E -> WHILE OPENPAR EL CLOSINGPAR . F WEND
    (16) F -> . E F
    (17) F -> . empty
    (18) E -> . LET Idv EQUALS Ex
    (19) E -> . DIM Idv AS T Arr
    (20) E -> . IF EL THEN F Esf EIF
    (21) E -> . FOR ID EQUALS EA TO Ex F NEXT ID
    (22) E -> . WHILE OPENPAR EL CLOSINGPAR F WEND
    (23) E -> . GOSUB ID
    (24) E -> . INPUT ES COMA IDEx
    (25) E -> . PRINT Ex
    (67) empty -> .

    LET             shift and go to state 10
    DIM             shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    GOSUB           shift and go to state 15
    INPUT           shift and go to state 16
    PRINT           shift and go to state 17
    WEND            reduce using rule 67 (empty -> .)

    F                              shift and go to state 121
    E                              shift and go to state 9
    empty                          shift and go to state 25

state 92

    (24) E -> INPUT ES COMA IDEx .

    LET             reduce using rule 24 (E -> INPUT ES COMA IDEx .)
    DIM             reduce using rule 24 (E -> INPUT ES COMA IDEx .)
    IF              reduce using rule 24 (E -> INPUT ES COMA IDEx .)
    FOR             reduce using rule 24 (E -> INPUT ES COMA IDEx .)
    WHILE           reduce using rule 24 (E -> INPUT ES COMA IDEx .)
    GOSUB           reduce using rule 24 (E -> INPUT ES COMA IDEx .)
    INPUT           reduce using rule 24 (E -> INPUT ES COMA IDEx .)
    PRINT           reduce using rule 24 (E -> INPUT ES COMA IDEx .)
    SUBPROCEDURE    reduce using rule 24 (E -> INPUT ES COMA IDEx .)
    END             reduce using rule 24 (E -> INPUT ES COMA IDEx .)
    RETURN          reduce using rule 24 (E -> INPUT ES COMA IDEx .)
    ELSE            reduce using rule 24 (E -> INPUT ES COMA IDEx .)
    EIF             reduce using rule 24 (E -> INPUT ES COMA IDEx .)
    WEND            reduce using rule 24 (E -> INPUT ES COMA IDEx .)
    NEXT            reduce using rule 24 (E -> INPUT ES COMA IDEx .)


state 93

    (28) IDEx -> ID .
    (29) IDEx -> ID . OPENBRACKET Idv CLOSINGBRACKET

    LET             reduce using rule 28 (IDEx -> ID .)
    DIM             reduce using rule 28 (IDEx -> ID .)
    IF              reduce using rule 28 (IDEx -> ID .)
    FOR             reduce using rule 28 (IDEx -> ID .)
    WHILE           reduce using rule 28 (IDEx -> ID .)
    GOSUB           reduce using rule 28 (IDEx -> ID .)
    INPUT           reduce using rule 28 (IDEx -> ID .)
    PRINT           reduce using rule 28 (IDEx -> ID .)
    SUBPROCEDURE    reduce using rule 28 (IDEx -> ID .)
    END             reduce using rule 28 (IDEx -> ID .)
    RETURN          reduce using rule 28 (IDEx -> ID .)
    ELSE            reduce using rule 28 (IDEx -> ID .)
    EIF             reduce using rule 28 (IDEx -> ID .)
    WEND            reduce using rule 28 (IDEx -> ID .)
    NEXT            reduce using rule 28 (IDEx -> ID .)
    OPENBRACKET     shift and go to state 122


state 94

    (44) N -> ID OPENBRACKET INTVAL . CLOSINGBRACKET

    CLOSINGBRACKET  shift and go to state 123


state 95

    (45) N -> ID OPENBRACKET Idv . CLOSINGBRACKET

    CLOSINGBRACKET  shift and go to state 124


state 96

    (35) EA -> P PLUS EA .

    LET             reduce using rule 35 (EA -> P PLUS EA .)
    DIM             reduce using rule 35 (EA -> P PLUS EA .)
    IF              reduce using rule 35 (EA -> P PLUS EA .)
    FOR             reduce using rule 35 (EA -> P PLUS EA .)
    WHILE           reduce using rule 35 (EA -> P PLUS EA .)
    GOSUB           reduce using rule 35 (EA -> P PLUS EA .)
    INPUT           reduce using rule 35 (EA -> P PLUS EA .)
    PRINT           reduce using rule 35 (EA -> P PLUS EA .)
    SUBPROCEDURE    reduce using rule 35 (EA -> P PLUS EA .)
    END             reduce using rule 35 (EA -> P PLUS EA .)
    RETURN          reduce using rule 35 (EA -> P PLUS EA .)
    ELSE            reduce using rule 35 (EA -> P PLUS EA .)
    EIF             reduce using rule 35 (EA -> P PLUS EA .)
    WEND            reduce using rule 35 (EA -> P PLUS EA .)
    NEXT            reduce using rule 35 (EA -> P PLUS EA .)
    EQUALTO         reduce using rule 35 (EA -> P PLUS EA .)
    GREATHER        reduce using rule 35 (EA -> P PLUS EA .)
    GREATHEREQUAL   reduce using rule 35 (EA -> P PLUS EA .)
    SMALLER         reduce using rule 35 (EA -> P PLUS EA .)
    SMALLEREQUAL    reduce using rule 35 (EA -> P PLUS EA .)
    NOTEQUAL        reduce using rule 35 (EA -> P PLUS EA .)
    CLOSINGPAR      reduce using rule 35 (EA -> P PLUS EA .)
    TO              reduce using rule 35 (EA -> P PLUS EA .)
    CLOSINGBRACKET  reduce using rule 35 (EA -> P PLUS EA .)


state 97

    (36) EA -> P MINUS EA .

    LET             reduce using rule 36 (EA -> P MINUS EA .)
    DIM             reduce using rule 36 (EA -> P MINUS EA .)
    IF              reduce using rule 36 (EA -> P MINUS EA .)
    FOR             reduce using rule 36 (EA -> P MINUS EA .)
    WHILE           reduce using rule 36 (EA -> P MINUS EA .)
    GOSUB           reduce using rule 36 (EA -> P MINUS EA .)
    INPUT           reduce using rule 36 (EA -> P MINUS EA .)
    PRINT           reduce using rule 36 (EA -> P MINUS EA .)
    SUBPROCEDURE    reduce using rule 36 (EA -> P MINUS EA .)
    END             reduce using rule 36 (EA -> P MINUS EA .)
    RETURN          reduce using rule 36 (EA -> P MINUS EA .)
    ELSE            reduce using rule 36 (EA -> P MINUS EA .)
    EIF             reduce using rule 36 (EA -> P MINUS EA .)
    WEND            reduce using rule 36 (EA -> P MINUS EA .)
    NEXT            reduce using rule 36 (EA -> P MINUS EA .)
    EQUALTO         reduce using rule 36 (EA -> P MINUS EA .)
    GREATHER        reduce using rule 36 (EA -> P MINUS EA .)
    GREATHEREQUAL   reduce using rule 36 (EA -> P MINUS EA .)
    SMALLER         reduce using rule 36 (EA -> P MINUS EA .)
    SMALLEREQUAL    reduce using rule 36 (EA -> P MINUS EA .)
    NOTEQUAL        reduce using rule 36 (EA -> P MINUS EA .)
    CLOSINGPAR      reduce using rule 36 (EA -> P MINUS EA .)
    TO              reduce using rule 36 (EA -> P MINUS EA .)
    CLOSINGBRACKET  reduce using rule 36 (EA -> P MINUS EA .)


state 98

    (43) N -> OPENPAR EA CLOSINGPAR .

    MULTIPLY        reduce using rule 43 (N -> OPENPAR EA CLOSINGPAR .)
    DIVIDE          reduce using rule 43 (N -> OPENPAR EA CLOSINGPAR .)
    PLUS            reduce using rule 43 (N -> OPENPAR EA CLOSINGPAR .)
    MINUS           reduce using rule 43 (N -> OPENPAR EA CLOSINGPAR .)
    LET             reduce using rule 43 (N -> OPENPAR EA CLOSINGPAR .)
    DIM             reduce using rule 43 (N -> OPENPAR EA CLOSINGPAR .)
    IF              reduce using rule 43 (N -> OPENPAR EA CLOSINGPAR .)
    FOR             reduce using rule 43 (N -> OPENPAR EA CLOSINGPAR .)
    WHILE           reduce using rule 43 (N -> OPENPAR EA CLOSINGPAR .)
    GOSUB           reduce using rule 43 (N -> OPENPAR EA CLOSINGPAR .)
    INPUT           reduce using rule 43 (N -> OPENPAR EA CLOSINGPAR .)
    PRINT           reduce using rule 43 (N -> OPENPAR EA CLOSINGPAR .)
    SUBPROCEDURE    reduce using rule 43 (N -> OPENPAR EA CLOSINGPAR .)
    END             reduce using rule 43 (N -> OPENPAR EA CLOSINGPAR .)
    RETURN          reduce using rule 43 (N -> OPENPAR EA CLOSINGPAR .)
    ELSE            reduce using rule 43 (N -> OPENPAR EA CLOSINGPAR .)
    EIF             reduce using rule 43 (N -> OPENPAR EA CLOSINGPAR .)
    WEND            reduce using rule 43 (N -> OPENPAR EA CLOSINGPAR .)
    NEXT            reduce using rule 43 (N -> OPENPAR EA CLOSINGPAR .)
    EQUALTO         reduce using rule 43 (N -> OPENPAR EA CLOSINGPAR .)
    GREATHER        reduce using rule 43 (N -> OPENPAR EA CLOSINGPAR .)
    GREATHEREQUAL   reduce using rule 43 (N -> OPENPAR EA CLOSINGPAR .)
    SMALLER         reduce using rule 43 (N -> OPENPAR EA CLOSINGPAR .)
    SMALLEREQUAL    reduce using rule 43 (N -> OPENPAR EA CLOSINGPAR .)
    NOTEQUAL        reduce using rule 43 (N -> OPENPAR EA CLOSINGPAR .)
    CLOSINGPAR      reduce using rule 43 (N -> OPENPAR EA CLOSINGPAR .)
    TO              reduce using rule 43 (N -> OPENPAR EA CLOSINGPAR .)
    CLOSINGBRACKET  reduce using rule 43 (N -> OPENPAR EA CLOSINGPAR .)


state 99

    (38) P -> N MULTIPLY P .

    PLUS            reduce using rule 38 (P -> N MULTIPLY P .)
    MINUS           reduce using rule 38 (P -> N MULTIPLY P .)
    LET             reduce using rule 38 (P -> N MULTIPLY P .)
    DIM             reduce using rule 38 (P -> N MULTIPLY P .)
    IF              reduce using rule 38 (P -> N MULTIPLY P .)
    FOR             reduce using rule 38 (P -> N MULTIPLY P .)
    WHILE           reduce using rule 38 (P -> N MULTIPLY P .)
    GOSUB           reduce using rule 38 (P -> N MULTIPLY P .)
    INPUT           reduce using rule 38 (P -> N MULTIPLY P .)
    PRINT           reduce using rule 38 (P -> N MULTIPLY P .)
    SUBPROCEDURE    reduce using rule 38 (P -> N MULTIPLY P .)
    END             reduce using rule 38 (P -> N MULTIPLY P .)
    RETURN          reduce using rule 38 (P -> N MULTIPLY P .)
    ELSE            reduce using rule 38 (P -> N MULTIPLY P .)
    EIF             reduce using rule 38 (P -> N MULTIPLY P .)
    WEND            reduce using rule 38 (P -> N MULTIPLY P .)
    NEXT            reduce using rule 38 (P -> N MULTIPLY P .)
    EQUALTO         reduce using rule 38 (P -> N MULTIPLY P .)
    GREATHER        reduce using rule 38 (P -> N MULTIPLY P .)
    GREATHEREQUAL   reduce using rule 38 (P -> N MULTIPLY P .)
    SMALLER         reduce using rule 38 (P -> N MULTIPLY P .)
    SMALLEREQUAL    reduce using rule 38 (P -> N MULTIPLY P .)
    NOTEQUAL        reduce using rule 38 (P -> N MULTIPLY P .)
    CLOSINGPAR      reduce using rule 38 (P -> N MULTIPLY P .)
    TO              reduce using rule 38 (P -> N MULTIPLY P .)
    CLOSINGBRACKET  reduce using rule 38 (P -> N MULTIPLY P .)


state 100

    (39) P -> N DIVIDE P .

    PLUS            reduce using rule 39 (P -> N DIVIDE P .)
    MINUS           reduce using rule 39 (P -> N DIVIDE P .)
    LET             reduce using rule 39 (P -> N DIVIDE P .)
    DIM             reduce using rule 39 (P -> N DIVIDE P .)
    IF              reduce using rule 39 (P -> N DIVIDE P .)
    FOR             reduce using rule 39 (P -> N DIVIDE P .)
    WHILE           reduce using rule 39 (P -> N DIVIDE P .)
    GOSUB           reduce using rule 39 (P -> N DIVIDE P .)
    INPUT           reduce using rule 39 (P -> N DIVIDE P .)
    PRINT           reduce using rule 39 (P -> N DIVIDE P .)
    SUBPROCEDURE    reduce using rule 39 (P -> N DIVIDE P .)
    END             reduce using rule 39 (P -> N DIVIDE P .)
    RETURN          reduce using rule 39 (P -> N DIVIDE P .)
    ELSE            reduce using rule 39 (P -> N DIVIDE P .)
    EIF             reduce using rule 39 (P -> N DIVIDE P .)
    WEND            reduce using rule 39 (P -> N DIVIDE P .)
    NEXT            reduce using rule 39 (P -> N DIVIDE P .)
    EQUALTO         reduce using rule 39 (P -> N DIVIDE P .)
    GREATHER        reduce using rule 39 (P -> N DIVIDE P .)
    GREATHEREQUAL   reduce using rule 39 (P -> N DIVIDE P .)
    SMALLER         reduce using rule 39 (P -> N DIVIDE P .)
    SMALLEREQUAL    reduce using rule 39 (P -> N DIVIDE P .)
    NOTEQUAL        reduce using rule 39 (P -> N DIVIDE P .)
    CLOSINGPAR      reduce using rule 39 (P -> N DIVIDE P .)
    TO              reduce using rule 39 (P -> N DIVIDE P .)
    CLOSINGBRACKET  reduce using rule 39 (P -> N DIVIDE P .)


state 101

    (2) V -> DIM Idv AS T Arr . V
    (2) V -> . DIM Idv AS T Arr V
    (3) V -> . empty
    (67) empty -> .

  ! shift/reduce conflict for DIM resolved as shift
    DIM             shift and go to state 4
    LET             reduce using rule 67 (empty -> .)
    IF              reduce using rule 67 (empty -> .)
    FOR             reduce using rule 67 (empty -> .)
    WHILE           reduce using rule 67 (empty -> .)
    GOSUB           reduce using rule 67 (empty -> .)
    INPUT           reduce using rule 67 (empty -> .)
    PRINT           reduce using rule 67 (empty -> .)
    SUBPROCEDURE    reduce using rule 67 (empty -> .)
    END             reduce using rule 67 (empty -> .)

  ! DIM             [ reduce using rule 67 (empty -> .) ]

    V                              shift and go to state 125
    empty                          shift and go to state 5

state 102

    (6) Arr -> OPENBRACKET . EA CLOSINGBRACKET Arr
    (7) Arr -> OPENBRACKET . ID CLOSINGBRACKET Arr
    (35) EA -> . P PLUS EA
    (36) EA -> . P MINUS EA
    (37) EA -> . P
    (38) P -> . N MULTIPLY P
    (39) P -> . N DIVIDE P
    (40) P -> . N
    (41) N -> . cte
    (42) N -> . ID
    (43) N -> . OPENPAR EA CLOSINGPAR
    (44) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (45) N -> . ID OPENBRACKET Idv CLOSINGBRACKET
    (46) cte -> . INTVAL
    (47) cte -> . FLOATVAL

    ID              shift and go to state 127
    OPENPAR         shift and go to state 55
    INTVAL          shift and go to state 46
    FLOATVAL        shift and go to state 47

    EA                             shift and go to state 126
    P                              shift and go to state 42
    N                              shift and go to state 44
    cte                            shift and go to state 45

state 103

    (8) Arr -> empty .

    DIM             reduce using rule 8 (Arr -> empty .)
    LET             reduce using rule 8 (Arr -> empty .)
    IF              reduce using rule 8 (Arr -> empty .)
    FOR             reduce using rule 8 (Arr -> empty .)
    WHILE           reduce using rule 8 (Arr -> empty .)
    GOSUB           reduce using rule 8 (Arr -> empty .)
    INPUT           reduce using rule 8 (Arr -> empty .)
    PRINT           reduce using rule 8 (Arr -> empty .)
    SUBPROCEDURE    reduce using rule 8 (Arr -> empty .)
    END             reduce using rule 8 (Arr -> empty .)
    RETURN          reduce using rule 8 (Arr -> empty .)
    ELSE            reduce using rule 8 (Arr -> empty .)
    EIF             reduce using rule 8 (Arr -> empty .)
    WEND            reduce using rule 8 (Arr -> empty .)
    NEXT            reduce using rule 8 (Arr -> empty .)


state 104

    (12) S -> SUBPROCEDURE ID TWOPOINTS M . RETURN S

    RETURN          shift and go to state 128


state 105

    (19) E -> DIM Idv AS T Arr .

    LET             reduce using rule 19 (E -> DIM Idv AS T Arr .)
    DIM             reduce using rule 19 (E -> DIM Idv AS T Arr .)
    IF              reduce using rule 19 (E -> DIM Idv AS T Arr .)
    FOR             reduce using rule 19 (E -> DIM Idv AS T Arr .)
    WHILE           reduce using rule 19 (E -> DIM Idv AS T Arr .)
    GOSUB           reduce using rule 19 (E -> DIM Idv AS T Arr .)
    INPUT           reduce using rule 19 (E -> DIM Idv AS T Arr .)
    PRINT           reduce using rule 19 (E -> DIM Idv AS T Arr .)
    SUBPROCEDURE    reduce using rule 19 (E -> DIM Idv AS T Arr .)
    END             reduce using rule 19 (E -> DIM Idv AS T Arr .)
    RETURN          reduce using rule 19 (E -> DIM Idv AS T Arr .)
    ELSE            reduce using rule 19 (E -> DIM Idv AS T Arr .)
    EIF             reduce using rule 19 (E -> DIM Idv AS T Arr .)
    WEND            reduce using rule 19 (E -> DIM Idv AS T Arr .)
    NEXT            reduce using rule 19 (E -> DIM Idv AS T Arr .)


state 106

    (20) E -> IF EL THEN F Esf . EIF

    EIF             shift and go to state 129


state 107

    (26) Esf -> ELSE . F
    (16) F -> . E F
    (17) F -> . empty
    (18) E -> . LET Idv EQUALS Ex
    (19) E -> . DIM Idv AS T Arr
    (20) E -> . IF EL THEN F Esf EIF
    (21) E -> . FOR ID EQUALS EA TO Ex F NEXT ID
    (22) E -> . WHILE OPENPAR EL CLOSINGPAR F WEND
    (23) E -> . GOSUB ID
    (24) E -> . INPUT ES COMA IDEx
    (25) E -> . PRINT Ex
    (67) empty -> .

    LET             shift and go to state 10
    DIM             shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    GOSUB           shift and go to state 15
    INPUT           shift and go to state 16
    PRINT           shift and go to state 17
    EIF             reduce using rule 67 (empty -> .)

    F                              shift and go to state 130
    E                              shift and go to state 9
    empty                          shift and go to state 25

state 108

    (27) Esf -> empty .

    EIF             reduce using rule 27 (Esf -> empty .)


state 109

    (50) EL -> OPENPAR O CLOSINGPAR Olt .

    THEN            reduce using rule 50 (EL -> OPENPAR O CLOSINGPAR Olt .)
    LET             reduce using rule 50 (EL -> OPENPAR O CLOSINGPAR Olt .)
    DIM             reduce using rule 50 (EL -> OPENPAR O CLOSINGPAR Olt .)
    IF              reduce using rule 50 (EL -> OPENPAR O CLOSINGPAR Olt .)
    FOR             reduce using rule 50 (EL -> OPENPAR O CLOSINGPAR Olt .)
    WHILE           reduce using rule 50 (EL -> OPENPAR O CLOSINGPAR Olt .)
    GOSUB           reduce using rule 50 (EL -> OPENPAR O CLOSINGPAR Olt .)
    INPUT           reduce using rule 50 (EL -> OPENPAR O CLOSINGPAR Olt .)
    PRINT           reduce using rule 50 (EL -> OPENPAR O CLOSINGPAR Olt .)
    SUBPROCEDURE    reduce using rule 50 (EL -> OPENPAR O CLOSINGPAR Olt .)
    END             reduce using rule 50 (EL -> OPENPAR O CLOSINGPAR Olt .)
    RETURN          reduce using rule 50 (EL -> OPENPAR O CLOSINGPAR Olt .)
    ELSE            reduce using rule 50 (EL -> OPENPAR O CLOSINGPAR Olt .)
    EIF             reduce using rule 50 (EL -> OPENPAR O CLOSINGPAR Olt .)
    WEND            reduce using rule 50 (EL -> OPENPAR O CLOSINGPAR Olt .)
    NEXT            reduce using rule 50 (EL -> OPENPAR O CLOSINGPAR Olt .)
    CLOSINGPAR      reduce using rule 50 (EL -> OPENPAR O CLOSINGPAR Olt .)


state 110

    (51) Olt -> OL . OPENPAR O CLOSINGPAR Olt

    OPENPAR         shift and go to state 131


state 111

    (52) Olt -> empty .

    THEN            reduce using rule 52 (Olt -> empty .)
    LET             reduce using rule 52 (Olt -> empty .)
    DIM             reduce using rule 52 (Olt -> empty .)
    IF              reduce using rule 52 (Olt -> empty .)
    FOR             reduce using rule 52 (Olt -> empty .)
    WHILE           reduce using rule 52 (Olt -> empty .)
    GOSUB           reduce using rule 52 (Olt -> empty .)
    INPUT           reduce using rule 52 (Olt -> empty .)
    PRINT           reduce using rule 52 (Olt -> empty .)
    SUBPROCEDURE    reduce using rule 52 (Olt -> empty .)
    END             reduce using rule 52 (Olt -> empty .)
    RETURN          reduce using rule 52 (Olt -> empty .)
    ELSE            reduce using rule 52 (Olt -> empty .)
    EIF             reduce using rule 52 (Olt -> empty .)
    WEND            reduce using rule 52 (Olt -> empty .)
    NEXT            reduce using rule 52 (Olt -> empty .)
    CLOSINGPAR      reduce using rule 52 (Olt -> empty .)


state 112

    (53) OL -> AND .

    OPENPAR         reduce using rule 53 (OL -> AND .)


state 113

    (54) OL -> OR .

    OPENPAR         reduce using rule 54 (OL -> OR .)


state 114

    (55) OL -> NOT .

    OPENPAR         reduce using rule 55 (OL -> NOT .)


state 115

    (56) O -> WORD EQUALTO WORD .

    CLOSINGPAR      reduce using rule 56 (O -> WORD EQUALTO WORD .)


state 116

    (57) O -> EA OPR EA .

    CLOSINGPAR      reduce using rule 57 (O -> EA OPR EA .)


state 117

    (60) O -> EA OPR ID .
    (42) N -> ID .
    (44) N -> ID . OPENBRACKET INTVAL CLOSINGBRACKET
    (45) N -> ID . OPENBRACKET Idv CLOSINGBRACKET

  ! reduce/reduce conflict for CLOSINGPAR resolved using rule 42 (N -> ID .)
    MULTIPLY        reduce using rule 42 (N -> ID .)
    DIVIDE          reduce using rule 42 (N -> ID .)
    PLUS            reduce using rule 42 (N -> ID .)
    MINUS           reduce using rule 42 (N -> ID .)
    CLOSINGPAR      reduce using rule 42 (N -> ID .)
    OPENBRACKET     shift and go to state 63

  ! CLOSINGPAR      [ reduce using rule 60 (O -> EA OPR ID .) ]


state 118

    (58) O -> ID OPR ID .
    (42) N -> ID .
    (44) N -> ID . OPENBRACKET INTVAL CLOSINGBRACKET
    (45) N -> ID . OPENBRACKET Idv CLOSINGBRACKET

  ! reduce/reduce conflict for CLOSINGPAR resolved using rule 42 (N -> ID .)
    MULTIPLY        reduce using rule 42 (N -> ID .)
    DIVIDE          reduce using rule 42 (N -> ID .)
    PLUS            reduce using rule 42 (N -> ID .)
    MINUS           reduce using rule 42 (N -> ID .)
    CLOSINGPAR      reduce using rule 42 (N -> ID .)
    OPENBRACKET     shift and go to state 63

  ! CLOSINGPAR      [ reduce using rule 58 (O -> ID OPR ID .) ]


state 119

    (59) O -> ID OPR EA .

    CLOSINGPAR      reduce using rule 59 (O -> ID OPR EA .)


state 120

    (21) E -> FOR ID EQUALS EA TO . Ex F NEXT ID
    (30) Ex -> . EA
    (31) Ex -> . ES
    (32) Ex -> . EL
    (33) Ex -> . ID
    (35) EA -> . P PLUS EA
    (36) EA -> . P MINUS EA
    (37) EA -> . P
    (34) ES -> . WORDVAL
    (48) EL -> . TRUE
    (49) EL -> . FALSE
    (50) EL -> . OPENPAR O CLOSINGPAR Olt
    (38) P -> . N MULTIPLY P
    (39) P -> . N DIVIDE P
    (40) P -> . N
    (41) N -> . cte
    (42) N -> . ID
    (43) N -> . OPENPAR EA CLOSINGPAR
    (44) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (45) N -> . ID OPENBRACKET Idv CLOSINGBRACKET
    (46) cte -> . INTVAL
    (47) cte -> . FLOATVAL

    ID              shift and go to state 41
    WORDVAL         shift and go to state 36
    TRUE            shift and go to state 29
    FALSE           shift and go to state 30
    OPENPAR         shift and go to state 43
    INTVAL          shift and go to state 46
    FLOATVAL        shift and go to state 47

    EA                             shift and go to state 38
    Ex                             shift and go to state 132
    ES                             shift and go to state 39
    EL                             shift and go to state 40
    P                              shift and go to state 42
    N                              shift and go to state 44
    cte                            shift and go to state 45

state 121

    (22) E -> WHILE OPENPAR EL CLOSINGPAR F . WEND

    WEND            shift and go to state 133


state 122

    (29) IDEx -> ID OPENBRACKET . Idv CLOSINGBRACKET
    (4) Idv -> . ID COMA Idv
    (5) Idv -> . ID

    ID              shift and go to state 19

    Idv                            shift and go to state 134

state 123

    (44) N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .

    MULTIPLY        reduce using rule 44 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    DIVIDE          reduce using rule 44 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    PLUS            reduce using rule 44 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    MINUS           reduce using rule 44 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    LET             reduce using rule 44 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    DIM             reduce using rule 44 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    IF              reduce using rule 44 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    FOR             reduce using rule 44 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    WHILE           reduce using rule 44 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    GOSUB           reduce using rule 44 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    INPUT           reduce using rule 44 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    PRINT           reduce using rule 44 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    SUBPROCEDURE    reduce using rule 44 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    END             reduce using rule 44 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    RETURN          reduce using rule 44 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    ELSE            reduce using rule 44 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    EIF             reduce using rule 44 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    WEND            reduce using rule 44 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    NEXT            reduce using rule 44 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    EQUALTO         reduce using rule 44 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    GREATHER        reduce using rule 44 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    GREATHEREQUAL   reduce using rule 44 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    SMALLER         reduce using rule 44 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    SMALLEREQUAL    reduce using rule 44 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    NOTEQUAL        reduce using rule 44 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    CLOSINGPAR      reduce using rule 44 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    TO              reduce using rule 44 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    CLOSINGBRACKET  reduce using rule 44 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)


state 124

    (45) N -> ID OPENBRACKET Idv CLOSINGBRACKET .

    MULTIPLY        reduce using rule 45 (N -> ID OPENBRACKET Idv CLOSINGBRACKET .)
    DIVIDE          reduce using rule 45 (N -> ID OPENBRACKET Idv CLOSINGBRACKET .)
    PLUS            reduce using rule 45 (N -> ID OPENBRACKET Idv CLOSINGBRACKET .)
    MINUS           reduce using rule 45 (N -> ID OPENBRACKET Idv CLOSINGBRACKET .)
    LET             reduce using rule 45 (N -> ID OPENBRACKET Idv CLOSINGBRACKET .)
    DIM             reduce using rule 45 (N -> ID OPENBRACKET Idv CLOSINGBRACKET .)
    IF              reduce using rule 45 (N -> ID OPENBRACKET Idv CLOSINGBRACKET .)
    FOR             reduce using rule 45 (N -> ID OPENBRACKET Idv CLOSINGBRACKET .)
    WHILE           reduce using rule 45 (N -> ID OPENBRACKET Idv CLOSINGBRACKET .)
    GOSUB           reduce using rule 45 (N -> ID OPENBRACKET Idv CLOSINGBRACKET .)
    INPUT           reduce using rule 45 (N -> ID OPENBRACKET Idv CLOSINGBRACKET .)
    PRINT           reduce using rule 45 (N -> ID OPENBRACKET Idv CLOSINGBRACKET .)
    SUBPROCEDURE    reduce using rule 45 (N -> ID OPENBRACKET Idv CLOSINGBRACKET .)
    END             reduce using rule 45 (N -> ID OPENBRACKET Idv CLOSINGBRACKET .)
    RETURN          reduce using rule 45 (N -> ID OPENBRACKET Idv CLOSINGBRACKET .)
    ELSE            reduce using rule 45 (N -> ID OPENBRACKET Idv CLOSINGBRACKET .)
    EIF             reduce using rule 45 (N -> ID OPENBRACKET Idv CLOSINGBRACKET .)
    WEND            reduce using rule 45 (N -> ID OPENBRACKET Idv CLOSINGBRACKET .)
    NEXT            reduce using rule 45 (N -> ID OPENBRACKET Idv CLOSINGBRACKET .)
    EQUALTO         reduce using rule 45 (N -> ID OPENBRACKET Idv CLOSINGBRACKET .)
    GREATHER        reduce using rule 45 (N -> ID OPENBRACKET Idv CLOSINGBRACKET .)
    GREATHEREQUAL   reduce using rule 45 (N -> ID OPENBRACKET Idv CLOSINGBRACKET .)
    SMALLER         reduce using rule 45 (N -> ID OPENBRACKET Idv CLOSINGBRACKET .)
    SMALLEREQUAL    reduce using rule 45 (N -> ID OPENBRACKET Idv CLOSINGBRACKET .)
    NOTEQUAL        reduce using rule 45 (N -> ID OPENBRACKET Idv CLOSINGBRACKET .)
    CLOSINGPAR      reduce using rule 45 (N -> ID OPENBRACKET Idv CLOSINGBRACKET .)
    TO              reduce using rule 45 (N -> ID OPENBRACKET Idv CLOSINGBRACKET .)
    CLOSINGBRACKET  reduce using rule 45 (N -> ID OPENBRACKET Idv CLOSINGBRACKET .)


state 125

    (2) V -> DIM Idv AS T Arr V .

    LET             reduce using rule 2 (V -> DIM Idv AS T Arr V .)
    DIM             reduce using rule 2 (V -> DIM Idv AS T Arr V .)
    IF              reduce using rule 2 (V -> DIM Idv AS T Arr V .)
    FOR             reduce using rule 2 (V -> DIM Idv AS T Arr V .)
    WHILE           reduce using rule 2 (V -> DIM Idv AS T Arr V .)
    GOSUB           reduce using rule 2 (V -> DIM Idv AS T Arr V .)
    INPUT           reduce using rule 2 (V -> DIM Idv AS T Arr V .)
    PRINT           reduce using rule 2 (V -> DIM Idv AS T Arr V .)
    SUBPROCEDURE    reduce using rule 2 (V -> DIM Idv AS T Arr V .)
    END             reduce using rule 2 (V -> DIM Idv AS T Arr V .)


state 126

    (6) Arr -> OPENBRACKET EA . CLOSINGBRACKET Arr

    CLOSINGBRACKET  shift and go to state 135


state 127

    (7) Arr -> OPENBRACKET ID . CLOSINGBRACKET Arr
    (42) N -> ID .
    (44) N -> ID . OPENBRACKET INTVAL CLOSINGBRACKET
    (45) N -> ID . OPENBRACKET Idv CLOSINGBRACKET

  ! shift/reduce conflict for CLOSINGBRACKET resolved as shift
    CLOSINGBRACKET  shift and go to state 136
    MULTIPLY        reduce using rule 42 (N -> ID .)
    DIVIDE          reduce using rule 42 (N -> ID .)
    PLUS            reduce using rule 42 (N -> ID .)
    MINUS           reduce using rule 42 (N -> ID .)
    OPENBRACKET     shift and go to state 63

  ! CLOSINGBRACKET  [ reduce using rule 42 (N -> ID .) ]


state 128

    (12) S -> SUBPROCEDURE ID TWOPOINTS M RETURN . S
    (12) S -> . SUBPROCEDURE ID TWOPOINTS M RETURN S
    (13) S -> . empty
    (67) empty -> .

    SUBPROCEDURE    shift and go to state 21
    END             reduce using rule 67 (empty -> .)

    S                              shift and go to state 137
    empty                          shift and go to state 22

state 129

    (20) E -> IF EL THEN F Esf EIF .

    LET             reduce using rule 20 (E -> IF EL THEN F Esf EIF .)
    DIM             reduce using rule 20 (E -> IF EL THEN F Esf EIF .)
    IF              reduce using rule 20 (E -> IF EL THEN F Esf EIF .)
    FOR             reduce using rule 20 (E -> IF EL THEN F Esf EIF .)
    WHILE           reduce using rule 20 (E -> IF EL THEN F Esf EIF .)
    GOSUB           reduce using rule 20 (E -> IF EL THEN F Esf EIF .)
    INPUT           reduce using rule 20 (E -> IF EL THEN F Esf EIF .)
    PRINT           reduce using rule 20 (E -> IF EL THEN F Esf EIF .)
    SUBPROCEDURE    reduce using rule 20 (E -> IF EL THEN F Esf EIF .)
    END             reduce using rule 20 (E -> IF EL THEN F Esf EIF .)
    RETURN          reduce using rule 20 (E -> IF EL THEN F Esf EIF .)
    ELSE            reduce using rule 20 (E -> IF EL THEN F Esf EIF .)
    EIF             reduce using rule 20 (E -> IF EL THEN F Esf EIF .)
    WEND            reduce using rule 20 (E -> IF EL THEN F Esf EIF .)
    NEXT            reduce using rule 20 (E -> IF EL THEN F Esf EIF .)


state 130

    (26) Esf -> ELSE F .

    EIF             reduce using rule 26 (Esf -> ELSE F .)


state 131

    (51) Olt -> OL OPENPAR . O CLOSINGPAR Olt
    (56) O -> . WORD EQUALTO WORD
    (57) O -> . EA OPR EA
    (58) O -> . ID OPR ID
    (59) O -> . ID OPR EA
    (60) O -> . EA OPR ID
    (35) EA -> . P PLUS EA
    (36) EA -> . P MINUS EA
    (37) EA -> . P
    (38) P -> . N MULTIPLY P
    (39) P -> . N DIVIDE P
    (40) P -> . N
    (41) N -> . cte
    (42) N -> . ID
    (43) N -> . OPENPAR EA CLOSINGPAR
    (44) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (45) N -> . ID OPENBRACKET Idv CLOSINGBRACKET
    (46) cte -> . INTVAL
    (47) cte -> . FLOATVAL

    WORD            shift and go to state 57
    ID              shift and go to state 59
    OPENPAR         shift and go to state 55
    INTVAL          shift and go to state 46
    FLOATVAL        shift and go to state 47

    O                              shift and go to state 138
    EA                             shift and go to state 58
    P                              shift and go to state 42
    N                              shift and go to state 44
    cte                            shift and go to state 45

state 132

    (21) E -> FOR ID EQUALS EA TO Ex . F NEXT ID
    (16) F -> . E F
    (17) F -> . empty
    (18) E -> . LET Idv EQUALS Ex
    (19) E -> . DIM Idv AS T Arr
    (20) E -> . IF EL THEN F Esf EIF
    (21) E -> . FOR ID EQUALS EA TO Ex F NEXT ID
    (22) E -> . WHILE OPENPAR EL CLOSINGPAR F WEND
    (23) E -> . GOSUB ID
    (24) E -> . INPUT ES COMA IDEx
    (25) E -> . PRINT Ex
    (67) empty -> .

    LET             shift and go to state 10
    DIM             shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    GOSUB           shift and go to state 15
    INPUT           shift and go to state 16
    PRINT           shift and go to state 17
    NEXT            reduce using rule 67 (empty -> .)

    F                              shift and go to state 139
    E                              shift and go to state 9
    empty                          shift and go to state 25

state 133

    (22) E -> WHILE OPENPAR EL CLOSINGPAR F WEND .

    LET             reduce using rule 22 (E -> WHILE OPENPAR EL CLOSINGPAR F WEND .)
    DIM             reduce using rule 22 (E -> WHILE OPENPAR EL CLOSINGPAR F WEND .)
    IF              reduce using rule 22 (E -> WHILE OPENPAR EL CLOSINGPAR F WEND .)
    FOR             reduce using rule 22 (E -> WHILE OPENPAR EL CLOSINGPAR F WEND .)
    WHILE           reduce using rule 22 (E -> WHILE OPENPAR EL CLOSINGPAR F WEND .)
    GOSUB           reduce using rule 22 (E -> WHILE OPENPAR EL CLOSINGPAR F WEND .)
    INPUT           reduce using rule 22 (E -> WHILE OPENPAR EL CLOSINGPAR F WEND .)
    PRINT           reduce using rule 22 (E -> WHILE OPENPAR EL CLOSINGPAR F WEND .)
    SUBPROCEDURE    reduce using rule 22 (E -> WHILE OPENPAR EL CLOSINGPAR F WEND .)
    END             reduce using rule 22 (E -> WHILE OPENPAR EL CLOSINGPAR F WEND .)
    RETURN          reduce using rule 22 (E -> WHILE OPENPAR EL CLOSINGPAR F WEND .)
    ELSE            reduce using rule 22 (E -> WHILE OPENPAR EL CLOSINGPAR F WEND .)
    EIF             reduce using rule 22 (E -> WHILE OPENPAR EL CLOSINGPAR F WEND .)
    WEND            reduce using rule 22 (E -> WHILE OPENPAR EL CLOSINGPAR F WEND .)
    NEXT            reduce using rule 22 (E -> WHILE OPENPAR EL CLOSINGPAR F WEND .)


state 134

    (29) IDEx -> ID OPENBRACKET Idv . CLOSINGBRACKET

    CLOSINGBRACKET  shift and go to state 140


state 135

    (6) Arr -> OPENBRACKET EA CLOSINGBRACKET . Arr
    (6) Arr -> . OPENBRACKET EA CLOSINGBRACKET Arr
    (7) Arr -> . OPENBRACKET ID CLOSINGBRACKET Arr
    (8) Arr -> . empty
    (67) empty -> .

    OPENBRACKET     shift and go to state 102
    DIM             reduce using rule 67 (empty -> .)
    LET             reduce using rule 67 (empty -> .)
    IF              reduce using rule 67 (empty -> .)
    FOR             reduce using rule 67 (empty -> .)
    WHILE           reduce using rule 67 (empty -> .)
    GOSUB           reduce using rule 67 (empty -> .)
    INPUT           reduce using rule 67 (empty -> .)
    PRINT           reduce using rule 67 (empty -> .)
    SUBPROCEDURE    reduce using rule 67 (empty -> .)
    END             reduce using rule 67 (empty -> .)
    RETURN          reduce using rule 67 (empty -> .)
    ELSE            reduce using rule 67 (empty -> .)
    EIF             reduce using rule 67 (empty -> .)
    WEND            reduce using rule 67 (empty -> .)
    NEXT            reduce using rule 67 (empty -> .)

    Arr                            shift and go to state 141
    empty                          shift and go to state 103

state 136

    (7) Arr -> OPENBRACKET ID CLOSINGBRACKET . Arr
    (6) Arr -> . OPENBRACKET EA CLOSINGBRACKET Arr
    (7) Arr -> . OPENBRACKET ID CLOSINGBRACKET Arr
    (8) Arr -> . empty
    (67) empty -> .

    OPENBRACKET     shift and go to state 102
    DIM             reduce using rule 67 (empty -> .)
    LET             reduce using rule 67 (empty -> .)
    IF              reduce using rule 67 (empty -> .)
    FOR             reduce using rule 67 (empty -> .)
    WHILE           reduce using rule 67 (empty -> .)
    GOSUB           reduce using rule 67 (empty -> .)
    INPUT           reduce using rule 67 (empty -> .)
    PRINT           reduce using rule 67 (empty -> .)
    SUBPROCEDURE    reduce using rule 67 (empty -> .)
    END             reduce using rule 67 (empty -> .)
    RETURN          reduce using rule 67 (empty -> .)
    ELSE            reduce using rule 67 (empty -> .)
    EIF             reduce using rule 67 (empty -> .)
    WEND            reduce using rule 67 (empty -> .)
    NEXT            reduce using rule 67 (empty -> .)

    Arr                            shift and go to state 142
    empty                          shift and go to state 103

state 137

    (12) S -> SUBPROCEDURE ID TWOPOINTS M RETURN S .

    END             reduce using rule 12 (S -> SUBPROCEDURE ID TWOPOINTS M RETURN S .)


state 138

    (51) Olt -> OL OPENPAR O . CLOSINGPAR Olt

    CLOSINGPAR      shift and go to state 143


state 139

    (21) E -> FOR ID EQUALS EA TO Ex F . NEXT ID

    NEXT            shift and go to state 144


state 140

    (29) IDEx -> ID OPENBRACKET Idv CLOSINGBRACKET .

    LET             reduce using rule 29 (IDEx -> ID OPENBRACKET Idv CLOSINGBRACKET .)
    DIM             reduce using rule 29 (IDEx -> ID OPENBRACKET Idv CLOSINGBRACKET .)
    IF              reduce using rule 29 (IDEx -> ID OPENBRACKET Idv CLOSINGBRACKET .)
    FOR             reduce using rule 29 (IDEx -> ID OPENBRACKET Idv CLOSINGBRACKET .)
    WHILE           reduce using rule 29 (IDEx -> ID OPENBRACKET Idv CLOSINGBRACKET .)
    GOSUB           reduce using rule 29 (IDEx -> ID OPENBRACKET Idv CLOSINGBRACKET .)
    INPUT           reduce using rule 29 (IDEx -> ID OPENBRACKET Idv CLOSINGBRACKET .)
    PRINT           reduce using rule 29 (IDEx -> ID OPENBRACKET Idv CLOSINGBRACKET .)
    SUBPROCEDURE    reduce using rule 29 (IDEx -> ID OPENBRACKET Idv CLOSINGBRACKET .)
    END             reduce using rule 29 (IDEx -> ID OPENBRACKET Idv CLOSINGBRACKET .)
    RETURN          reduce using rule 29 (IDEx -> ID OPENBRACKET Idv CLOSINGBRACKET .)
    ELSE            reduce using rule 29 (IDEx -> ID OPENBRACKET Idv CLOSINGBRACKET .)
    EIF             reduce using rule 29 (IDEx -> ID OPENBRACKET Idv CLOSINGBRACKET .)
    WEND            reduce using rule 29 (IDEx -> ID OPENBRACKET Idv CLOSINGBRACKET .)
    NEXT            reduce using rule 29 (IDEx -> ID OPENBRACKET Idv CLOSINGBRACKET .)


state 141

    (6) Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .

    DIM             reduce using rule 6 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    LET             reduce using rule 6 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    IF              reduce using rule 6 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    FOR             reduce using rule 6 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    WHILE           reduce using rule 6 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    GOSUB           reduce using rule 6 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    INPUT           reduce using rule 6 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    PRINT           reduce using rule 6 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    SUBPROCEDURE    reduce using rule 6 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    END             reduce using rule 6 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    RETURN          reduce using rule 6 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    ELSE            reduce using rule 6 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    EIF             reduce using rule 6 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    WEND            reduce using rule 6 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    NEXT            reduce using rule 6 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)


state 142

    (7) Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .

    DIM             reduce using rule 7 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    LET             reduce using rule 7 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    IF              reduce using rule 7 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    FOR             reduce using rule 7 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    WHILE           reduce using rule 7 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    GOSUB           reduce using rule 7 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    INPUT           reduce using rule 7 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    PRINT           reduce using rule 7 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    SUBPROCEDURE    reduce using rule 7 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    END             reduce using rule 7 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    RETURN          reduce using rule 7 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    ELSE            reduce using rule 7 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    EIF             reduce using rule 7 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    WEND            reduce using rule 7 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    NEXT            reduce using rule 7 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)


state 143

    (51) Olt -> OL OPENPAR O CLOSINGPAR . Olt
    (51) Olt -> . OL OPENPAR O CLOSINGPAR Olt
    (52) Olt -> . empty
    (53) OL -> . AND
    (54) OL -> . OR
    (55) OL -> . NOT
    (67) empty -> .

    AND             shift and go to state 112
    OR              shift and go to state 113
    NOT             shift and go to state 114
    THEN            reduce using rule 67 (empty -> .)
    LET             reduce using rule 67 (empty -> .)
    DIM             reduce using rule 67 (empty -> .)
    IF              reduce using rule 67 (empty -> .)
    FOR             reduce using rule 67 (empty -> .)
    WHILE           reduce using rule 67 (empty -> .)
    GOSUB           reduce using rule 67 (empty -> .)
    INPUT           reduce using rule 67 (empty -> .)
    PRINT           reduce using rule 67 (empty -> .)
    SUBPROCEDURE    reduce using rule 67 (empty -> .)
    END             reduce using rule 67 (empty -> .)
    RETURN          reduce using rule 67 (empty -> .)
    ELSE            reduce using rule 67 (empty -> .)
    EIF             reduce using rule 67 (empty -> .)
    WEND            reduce using rule 67 (empty -> .)
    NEXT            reduce using rule 67 (empty -> .)
    CLOSINGPAR      reduce using rule 67 (empty -> .)

    OL                             shift and go to state 110
    Olt                            shift and go to state 145
    empty                          shift and go to state 111

state 144

    (21) E -> FOR ID EQUALS EA TO Ex F NEXT . ID

    ID              shift and go to state 146


state 145

    (51) Olt -> OL OPENPAR O CLOSINGPAR Olt .

    THEN            reduce using rule 51 (Olt -> OL OPENPAR O CLOSINGPAR Olt .)
    LET             reduce using rule 51 (Olt -> OL OPENPAR O CLOSINGPAR Olt .)
    DIM             reduce using rule 51 (Olt -> OL OPENPAR O CLOSINGPAR Olt .)
    IF              reduce using rule 51 (Olt -> OL OPENPAR O CLOSINGPAR Olt .)
    FOR             reduce using rule 51 (Olt -> OL OPENPAR O CLOSINGPAR Olt .)
    WHILE           reduce using rule 51 (Olt -> OL OPENPAR O CLOSINGPAR Olt .)
    GOSUB           reduce using rule 51 (Olt -> OL OPENPAR O CLOSINGPAR Olt .)
    INPUT           reduce using rule 51 (Olt -> OL OPENPAR O CLOSINGPAR Olt .)
    PRINT           reduce using rule 51 (Olt -> OL OPENPAR O CLOSINGPAR Olt .)
    SUBPROCEDURE    reduce using rule 51 (Olt -> OL OPENPAR O CLOSINGPAR Olt .)
    END             reduce using rule 51 (Olt -> OL OPENPAR O CLOSINGPAR Olt .)
    RETURN          reduce using rule 51 (Olt -> OL OPENPAR O CLOSINGPAR Olt .)
    ELSE            reduce using rule 51 (Olt -> OL OPENPAR O CLOSINGPAR Olt .)
    EIF             reduce using rule 51 (Olt -> OL OPENPAR O CLOSINGPAR Olt .)
    WEND            reduce using rule 51 (Olt -> OL OPENPAR O CLOSINGPAR Olt .)
    NEXT            reduce using rule 51 (Olt -> OL OPENPAR O CLOSINGPAR Olt .)
    CLOSINGPAR      reduce using rule 51 (Olt -> OL OPENPAR O CLOSINGPAR Olt .)


state 146

    (21) E -> FOR ID EQUALS EA TO Ex F NEXT ID .

    LET             reduce using rule 21 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    DIM             reduce using rule 21 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    IF              reduce using rule 21 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    FOR             reduce using rule 21 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    WHILE           reduce using rule 21 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    GOSUB           reduce using rule 21 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    INPUT           reduce using rule 21 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    PRINT           reduce using rule 21 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    SUBPROCEDURE    reduce using rule 21 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    END             reduce using rule 21 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    RETURN          reduce using rule 21 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    ELSE            reduce using rule 21 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    EIF             reduce using rule 21 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    WEND            reduce using rule 21 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    NEXT            reduce using rule 21 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for DIM in state 2 resolved as shift
WARNING: shift/reduce conflict for LET in state 3 resolved as shift
WARNING: shift/reduce conflict for DIM in state 3 resolved as shift
WARNING: shift/reduce conflict for IF in state 3 resolved as shift
WARNING: shift/reduce conflict for FOR in state 3 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 3 resolved as shift
WARNING: shift/reduce conflict for GOSUB in state 3 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 3 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 3 resolved as shift
WARNING: shift/reduce conflict for LET in state 7 resolved as shift
WARNING: shift/reduce conflict for DIM in state 7 resolved as shift
WARNING: shift/reduce conflict for IF in state 7 resolved as shift
WARNING: shift/reduce conflict for FOR in state 7 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 7 resolved as shift
WARNING: shift/reduce conflict for GOSUB in state 7 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 7 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 7 resolved as shift
WARNING: shift/reduce conflict for LET in state 9 resolved as shift
WARNING: shift/reduce conflict for DIM in state 9 resolved as shift
WARNING: shift/reduce conflict for IF in state 9 resolved as shift
WARNING: shift/reduce conflict for FOR in state 9 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 9 resolved as shift
WARNING: shift/reduce conflict for GOSUB in state 9 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 9 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 9 resolved as shift
WARNING: shift/reduce conflict for EQUALTO in state 59 resolved as shift
WARNING: shift/reduce conflict for GREATHER in state 59 resolved as shift
WARNING: shift/reduce conflict for GREATHEREQUAL in state 59 resolved as shift
WARNING: shift/reduce conflict for SMALLER in state 59 resolved as shift
WARNING: shift/reduce conflict for SMALLEREQUAL in state 59 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 59 resolved as shift
WARNING: shift/reduce conflict for LET in state 74 resolved as shift
WARNING: shift/reduce conflict for DIM in state 74 resolved as shift
WARNING: shift/reduce conflict for IF in state 74 resolved as shift
WARNING: shift/reduce conflict for FOR in state 74 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 74 resolved as shift
WARNING: shift/reduce conflict for GOSUB in state 74 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 74 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 74 resolved as shift
WARNING: shift/reduce conflict for DIM in state 101 resolved as shift
WARNING: shift/reduce conflict for CLOSINGBRACKET in state 127 resolved as shift
WARNING: reduce/reduce conflict in state 8 resolved using rule (M -> empty)
WARNING: rejected rule (F -> empty) in state 8
WARNING: reduce/reduce conflict in state 41 resolved using rule (Ex -> ID)
WARNING: rejected rule (N -> ID) in state 41
WARNING: reduce/reduce conflict in state 117 resolved using rule (N -> ID)
WARNING: rejected rule (O -> EA OPR ID) in state 117
WARNING: reduce/reduce conflict in state 118 resolved using rule (N -> ID)
WARNING: rejected rule (O -> ID OPR ID) in state 118
WARNING: Rule (O -> EA OPR ID) is never reduced
WARNING: Rule (O -> ID OPR ID) is never reduced
