Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT

Grammar

Rule 0     S' -> PROGRAMA
Rule 1     PROGRAMA -> PROGRAM V M S END
Rule 2     V -> DIM setType Idv AS T Arr
Rule 3     V -> empty
Rule 4     Arr -> OPENBRACKET EA CLOSINGBRACKET Arr
Rule 5     Arr -> OPENBRACKET ID CLOSINGBRACKET Arr
Rule 6     Arr -> empty
Rule 7     T -> INT
Rule 8     T -> FLOAT
Rule 9     T -> WORD
Rule 10    S -> SUBPROCEDURE ID TWOPOINTS M RETURN S
Rule 11    S -> empty
Rule 12    M -> F M
Rule 13    M -> empty
Rule 14    F -> E F
Rule 15    F -> empty
Rule 16    E -> LET setType Idv EQUALS Ex
Rule 17    E -> DIM setType Idv AS T Arr
Rule 18    E -> IF EL THEN F Esf EIF
Rule 19    E -> FOR ID EQUALS EA TO Ex F NEXT ID
Rule 20    E -> WHILE OPENPAR EL CLOSINGPAR F WEND
Rule 21    E -> GOSUB ID
Rule 22    E -> INPUT ES COMA IDEx
Rule 23    E -> PRINT Ex
Rule 24    Idv -> ID COMA Idv
Rule 25    Idv -> ID
Rule 26    setType -> <empty>
Rule 27    Esf -> ELSE F
Rule 28    Esf -> empty
Rule 29    IDEx -> ID
Rule 30    IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET
Rule 31    Ex -> EA
Rule 32    Ex -> ES
Rule 33    Ex -> EL
Rule 34    Ex -> ID
Rule 35    ES -> WORDVAL
Rule 36    EA -> P PLUS EA
Rule 37    EA -> P MINUS EA
Rule 38    EA -> P
Rule 39    P -> N MULTIPLY P
Rule 40    P -> N DIVIDE P
Rule 41    P -> N
Rule 42    N -> cte saveID
Rule 43    N -> ID saveID
Rule 44    N -> OPENPAR EA CLOSINGPAR
Rule 45    N -> ID OPENBRACKET INTVAL CLOSINGBRACKET
Rule 46    N -> ID OPENBRACKET setType Idv CLOSINGBRACKET
Rule 47    saveID -> <empty>
Rule 48    cte -> INTVAL
Rule 49    cte -> FLOATVAL
Rule 50    EL -> TRUE
Rule 51    EL -> FALSE
Rule 52    EL -> OPENPAR O CLOSINGPAR
Rule 53    EL -> OPENPAR O CLOSINGPAR OL EL
Rule 54    OL -> AND
Rule 55    OL -> OR
Rule 56    OL -> NOT
Rule 57    O -> Ex OPR Ex
Rule 58    OPR -> GREATHER
Rule 59    OPR -> GREATHEREQUAL
Rule 60    OPR -> SMALLER
Rule 61    OPR -> SMALLEREQUAL
Rule 62    OPR -> NOTEQUAL
Rule 63    OPR -> EQUALTO
Rule 64    empty -> <empty>

Terminals, with rules where they appear

AND                  : 54
AS                   : 2 17
CLOSINGBRACKET       : 4 5 30 45 46
CLOSINGPAR           : 20 44 52 53
COMA                 : 22 24
COMMENT              : 
DIM                  : 2 17
DIVIDE               : 40
EIF                  : 18
ELSE                 : 27
END                  : 1
EQUALS               : 16 19
EQUALTO              : 63
FALSE                : 51
FLOAT                : 8
FLOATVAL             : 49
FOR                  : 19
GOSUB                : 21
GREATHER             : 58
GREATHEREQUAL        : 59
ID                   : 5 10 19 19 21 24 25 29 30 34 43 45 46
IF                   : 18
INPUT                : 22
INT                  : 7
INTVAL               : 45 48
LET                  : 16
MINUS                : 37
MULTIPLY             : 39
NEXT                 : 19
NOT                  : 56
NOTEQUAL             : 62
OPENBRACKET          : 4 5 30 45 46
OPENPAR              : 20 44 52 53
OR                   : 55
PLUS                 : 36
PRINT                : 23
PROGRAM              : 1
RETURN               : 10
SMALLER              : 60
SMALLEREQUAL         : 61
SUBPROCEDURE         : 10
THEN                 : 18
TO                   : 19
TRUE                 : 50
TWOPOINTS            : 10
WEND                 : 20
WHILE                : 20
WORD                 : 9
WORDVAL              : 35
error                : 

Nonterminals, with rules where they appear

Arr                  : 2 4 5 17
E                    : 14
EA                   : 4 19 31 36 37 44
EL                   : 18 20 33 53
ES                   : 22 32
Esf                  : 18
Ex                   : 16 19 23 57 57
F                    : 12 14 18 19 20 27
IDEx                 : 22
Idv                  : 2 16 17 24 30 46
M                    : 1 10 12
N                    : 39 40 41
O                    : 52 53
OL                   : 53
OPR                  : 57
P                    : 36 37 38 39 40
PROGRAMA             : 0
S                    : 1 10
T                    : 2 17
V                    : 1
cte                  : 42
empty                : 3 6 11 13 15 28
saveID               : 42 43
setType              : 2 16 17 30 46

Parsing method: LALR

state 0

    (0) S' -> . PROGRAMA
    (1) PROGRAMA -> . PROGRAM V M S END

    PROGRAM         shift and go to state 2

    PROGRAMA                       shift and go to state 1

state 1

    (0) S' -> PROGRAMA .



state 2

    (1) PROGRAMA -> PROGRAM . V M S END
    (2) V -> . DIM setType Idv AS T Arr
    (3) V -> . empty
    (64) empty -> .

  ! shift/reduce conflict for DIM resolved as shift
    DIM             shift and go to state 4
    LET             reduce using rule 64 (empty -> .)
    IF              reduce using rule 64 (empty -> .)
    FOR             reduce using rule 64 (empty -> .)
    WHILE           reduce using rule 64 (empty -> .)
    GOSUB           reduce using rule 64 (empty -> .)
    INPUT           reduce using rule 64 (empty -> .)
    PRINT           reduce using rule 64 (empty -> .)
    SUBPROCEDURE    reduce using rule 64 (empty -> .)
    END             reduce using rule 64 (empty -> .)

  ! DIM             [ reduce using rule 64 (empty -> .) ]

    V                              shift and go to state 3
    empty                          shift and go to state 5

state 3

    (1) PROGRAMA -> PROGRAM V . M S END
    (12) M -> . F M
    (13) M -> . empty
    (14) F -> . E F
    (15) F -> . empty
    (64) empty -> .
    (16) E -> . LET setType Idv EQUALS Ex
    (17) E -> . DIM setType Idv AS T Arr
    (18) E -> . IF EL THEN F Esf EIF
    (19) E -> . FOR ID EQUALS EA TO Ex F NEXT ID
    (20) E -> . WHILE OPENPAR EL CLOSINGPAR F WEND
    (21) E -> . GOSUB ID
    (22) E -> . INPUT ES COMA IDEx
    (23) E -> . PRINT Ex

  ! shift/reduce conflict for LET resolved as shift
  ! shift/reduce conflict for DIM resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for GOSUB resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
    SUBPROCEDURE    reduce using rule 64 (empty -> .)
    END             reduce using rule 64 (empty -> .)
    LET             shift and go to state 10
    DIM             shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    GOSUB           shift and go to state 15
    INPUT           shift and go to state 16
    PRINT           shift and go to state 17

  ! LET             [ reduce using rule 64 (empty -> .) ]
  ! DIM             [ reduce using rule 64 (empty -> .) ]
  ! IF              [ reduce using rule 64 (empty -> .) ]
  ! FOR             [ reduce using rule 64 (empty -> .) ]
  ! WHILE           [ reduce using rule 64 (empty -> .) ]
  ! GOSUB           [ reduce using rule 64 (empty -> .) ]
  ! INPUT           [ reduce using rule 64 (empty -> .) ]
  ! PRINT           [ reduce using rule 64 (empty -> .) ]

    M                              shift and go to state 6
    F                              shift and go to state 7
    empty                          shift and go to state 8
    E                              shift and go to state 9

state 4

    (2) V -> DIM . setType Idv AS T Arr
    (26) setType -> .

    ID              reduce using rule 26 (setType -> .)

    setType                        shift and go to state 18

state 5

    (3) V -> empty .

    LET             reduce using rule 3 (V -> empty .)
    DIM             reduce using rule 3 (V -> empty .)
    IF              reduce using rule 3 (V -> empty .)
    FOR             reduce using rule 3 (V -> empty .)
    WHILE           reduce using rule 3 (V -> empty .)
    GOSUB           reduce using rule 3 (V -> empty .)
    INPUT           reduce using rule 3 (V -> empty .)
    PRINT           reduce using rule 3 (V -> empty .)
    SUBPROCEDURE    reduce using rule 3 (V -> empty .)
    END             reduce using rule 3 (V -> empty .)


state 6

    (1) PROGRAMA -> PROGRAM V M . S END
    (10) S -> . SUBPROCEDURE ID TWOPOINTS M RETURN S
    (11) S -> . empty
    (64) empty -> .

    SUBPROCEDURE    shift and go to state 20
    END             reduce using rule 64 (empty -> .)

    S                              shift and go to state 19
    empty                          shift and go to state 21

state 7

    (12) M -> F . M
    (12) M -> . F M
    (13) M -> . empty
    (14) F -> . E F
    (15) F -> . empty
    (64) empty -> .
    (16) E -> . LET setType Idv EQUALS Ex
    (17) E -> . DIM setType Idv AS T Arr
    (18) E -> . IF EL THEN F Esf EIF
    (19) E -> . FOR ID EQUALS EA TO Ex F NEXT ID
    (20) E -> . WHILE OPENPAR EL CLOSINGPAR F WEND
    (21) E -> . GOSUB ID
    (22) E -> . INPUT ES COMA IDEx
    (23) E -> . PRINT Ex

  ! shift/reduce conflict for LET resolved as shift
  ! shift/reduce conflict for DIM resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for GOSUB resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
    SUBPROCEDURE    reduce using rule 64 (empty -> .)
    END             reduce using rule 64 (empty -> .)
    RETURN          reduce using rule 64 (empty -> .)
    LET             shift and go to state 10
    DIM             shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    GOSUB           shift and go to state 15
    INPUT           shift and go to state 16
    PRINT           shift and go to state 17

  ! LET             [ reduce using rule 64 (empty -> .) ]
  ! DIM             [ reduce using rule 64 (empty -> .) ]
  ! IF              [ reduce using rule 64 (empty -> .) ]
  ! FOR             [ reduce using rule 64 (empty -> .) ]
  ! WHILE           [ reduce using rule 64 (empty -> .) ]
  ! GOSUB           [ reduce using rule 64 (empty -> .) ]
  ! INPUT           [ reduce using rule 64 (empty -> .) ]
  ! PRINT           [ reduce using rule 64 (empty -> .) ]

    F                              shift and go to state 7
    M                              shift and go to state 22
    empty                          shift and go to state 8
    E                              shift and go to state 9

state 8

    (13) M -> empty .
    (15) F -> empty .

  ! reduce/reduce conflict for SUBPROCEDURE resolved using rule 13 (M -> empty .)
  ! reduce/reduce conflict for END resolved using rule 13 (M -> empty .)
  ! reduce/reduce conflict for RETURN resolved using rule 13 (M -> empty .)
    SUBPROCEDURE    reduce using rule 13 (M -> empty .)
    END             reduce using rule 13 (M -> empty .)
    RETURN          reduce using rule 13 (M -> empty .)
    LET             reduce using rule 15 (F -> empty .)
    DIM             reduce using rule 15 (F -> empty .)
    IF              reduce using rule 15 (F -> empty .)
    FOR             reduce using rule 15 (F -> empty .)
    WHILE           reduce using rule 15 (F -> empty .)
    GOSUB           reduce using rule 15 (F -> empty .)
    INPUT           reduce using rule 15 (F -> empty .)
    PRINT           reduce using rule 15 (F -> empty .)

  ! SUBPROCEDURE    [ reduce using rule 15 (F -> empty .) ]
  ! END             [ reduce using rule 15 (F -> empty .) ]
  ! RETURN          [ reduce using rule 15 (F -> empty .) ]


state 9

    (14) F -> E . F
    (14) F -> . E F
    (15) F -> . empty
    (16) E -> . LET setType Idv EQUALS Ex
    (17) E -> . DIM setType Idv AS T Arr
    (18) E -> . IF EL THEN F Esf EIF
    (19) E -> . FOR ID EQUALS EA TO Ex F NEXT ID
    (20) E -> . WHILE OPENPAR EL CLOSINGPAR F WEND
    (21) E -> . GOSUB ID
    (22) E -> . INPUT ES COMA IDEx
    (23) E -> . PRINT Ex
    (64) empty -> .

  ! shift/reduce conflict for LET resolved as shift
  ! shift/reduce conflict for DIM resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for GOSUB resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
    LET             shift and go to state 10
    DIM             shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    GOSUB           shift and go to state 15
    INPUT           shift and go to state 16
    PRINT           shift and go to state 17
    SUBPROCEDURE    reduce using rule 64 (empty -> .)
    END             reduce using rule 64 (empty -> .)
    RETURN          reduce using rule 64 (empty -> .)
    ELSE            reduce using rule 64 (empty -> .)
    EIF             reduce using rule 64 (empty -> .)
    WEND            reduce using rule 64 (empty -> .)
    NEXT            reduce using rule 64 (empty -> .)

  ! LET             [ reduce using rule 64 (empty -> .) ]
  ! DIM             [ reduce using rule 64 (empty -> .) ]
  ! IF              [ reduce using rule 64 (empty -> .) ]
  ! FOR             [ reduce using rule 64 (empty -> .) ]
  ! WHILE           [ reduce using rule 64 (empty -> .) ]
  ! GOSUB           [ reduce using rule 64 (empty -> .) ]
  ! INPUT           [ reduce using rule 64 (empty -> .) ]
  ! PRINT           [ reduce using rule 64 (empty -> .) ]

    E                              shift and go to state 9
    F                              shift and go to state 23
    empty                          shift and go to state 24

state 10

    (16) E -> LET . setType Idv EQUALS Ex
    (26) setType -> .

    ID              reduce using rule 26 (setType -> .)

    setType                        shift and go to state 25

state 11

    (17) E -> DIM . setType Idv AS T Arr
    (26) setType -> .

    ID              reduce using rule 26 (setType -> .)

    setType                        shift and go to state 26

state 12

    (18) E -> IF . EL THEN F Esf EIF
    (50) EL -> . TRUE
    (51) EL -> . FALSE
    (52) EL -> . OPENPAR O CLOSINGPAR
    (53) EL -> . OPENPAR O CLOSINGPAR OL EL

    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    OPENPAR         shift and go to state 30

    EL                             shift and go to state 27

state 13

    (19) E -> FOR . ID EQUALS EA TO Ex F NEXT ID

    ID              shift and go to state 31


state 14

    (20) E -> WHILE . OPENPAR EL CLOSINGPAR F WEND

    OPENPAR         shift and go to state 32


state 15

    (21) E -> GOSUB . ID

    ID              shift and go to state 33


state 16

    (22) E -> INPUT . ES COMA IDEx
    (35) ES -> . WORDVAL

    WORDVAL         shift and go to state 35

    ES                             shift and go to state 34

state 17

    (23) E -> PRINT . Ex
    (31) Ex -> . EA
    (32) Ex -> . ES
    (33) Ex -> . EL
    (34) Ex -> . ID
    (36) EA -> . P PLUS EA
    (37) EA -> . P MINUS EA
    (38) EA -> . P
    (35) ES -> . WORDVAL
    (50) EL -> . TRUE
    (51) EL -> . FALSE
    (52) EL -> . OPENPAR O CLOSINGPAR
    (53) EL -> . OPENPAR O CLOSINGPAR OL EL
    (39) P -> . N MULTIPLY P
    (40) P -> . N DIVIDE P
    (41) P -> . N
    (42) N -> . cte saveID
    (43) N -> . ID saveID
    (44) N -> . OPENPAR EA CLOSINGPAR
    (45) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (46) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (48) cte -> . INTVAL
    (49) cte -> . FLOATVAL

    ID              shift and go to state 40
    WORDVAL         shift and go to state 35
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    OPENPAR         shift and go to state 42
    INTVAL          shift and go to state 45
    FLOATVAL        shift and go to state 46

    Ex                             shift and go to state 36
    EA                             shift and go to state 37
    ES                             shift and go to state 38
    EL                             shift and go to state 39
    P                              shift and go to state 41
    N                              shift and go to state 43
    cte                            shift and go to state 44

state 18

    (2) V -> DIM setType . Idv AS T Arr
    (24) Idv -> . ID COMA Idv
    (25) Idv -> . ID

    ID              shift and go to state 48

    Idv                            shift and go to state 47

state 19

    (1) PROGRAMA -> PROGRAM V M S . END

    END             shift and go to state 49


state 20

    (10) S -> SUBPROCEDURE . ID TWOPOINTS M RETURN S

    ID              shift and go to state 50


state 21

    (11) S -> empty .

    END             reduce using rule 11 (S -> empty .)


state 22

    (12) M -> F M .

    SUBPROCEDURE    reduce using rule 12 (M -> F M .)
    END             reduce using rule 12 (M -> F M .)
    RETURN          reduce using rule 12 (M -> F M .)


state 23

    (14) F -> E F .

    LET             reduce using rule 14 (F -> E F .)
    DIM             reduce using rule 14 (F -> E F .)
    IF              reduce using rule 14 (F -> E F .)
    FOR             reduce using rule 14 (F -> E F .)
    WHILE           reduce using rule 14 (F -> E F .)
    GOSUB           reduce using rule 14 (F -> E F .)
    INPUT           reduce using rule 14 (F -> E F .)
    PRINT           reduce using rule 14 (F -> E F .)
    SUBPROCEDURE    reduce using rule 14 (F -> E F .)
    END             reduce using rule 14 (F -> E F .)
    RETURN          reduce using rule 14 (F -> E F .)
    ELSE            reduce using rule 14 (F -> E F .)
    EIF             reduce using rule 14 (F -> E F .)
    WEND            reduce using rule 14 (F -> E F .)
    NEXT            reduce using rule 14 (F -> E F .)


state 24

    (15) F -> empty .

    LET             reduce using rule 15 (F -> empty .)
    DIM             reduce using rule 15 (F -> empty .)
    IF              reduce using rule 15 (F -> empty .)
    FOR             reduce using rule 15 (F -> empty .)
    WHILE           reduce using rule 15 (F -> empty .)
    GOSUB           reduce using rule 15 (F -> empty .)
    INPUT           reduce using rule 15 (F -> empty .)
    PRINT           reduce using rule 15 (F -> empty .)
    SUBPROCEDURE    reduce using rule 15 (F -> empty .)
    END             reduce using rule 15 (F -> empty .)
    RETURN          reduce using rule 15 (F -> empty .)
    ELSE            reduce using rule 15 (F -> empty .)
    EIF             reduce using rule 15 (F -> empty .)
    WEND            reduce using rule 15 (F -> empty .)
    NEXT            reduce using rule 15 (F -> empty .)


state 25

    (16) E -> LET setType . Idv EQUALS Ex
    (24) Idv -> . ID COMA Idv
    (25) Idv -> . ID

    ID              shift and go to state 48

    Idv                            shift and go to state 51

state 26

    (17) E -> DIM setType . Idv AS T Arr
    (24) Idv -> . ID COMA Idv
    (25) Idv -> . ID

    ID              shift and go to state 48

    Idv                            shift and go to state 52

state 27

    (18) E -> IF EL . THEN F Esf EIF

    THEN            shift and go to state 53


state 28

    (50) EL -> TRUE .

    THEN            reduce using rule 50 (EL -> TRUE .)
    LET             reduce using rule 50 (EL -> TRUE .)
    DIM             reduce using rule 50 (EL -> TRUE .)
    IF              reduce using rule 50 (EL -> TRUE .)
    FOR             reduce using rule 50 (EL -> TRUE .)
    WHILE           reduce using rule 50 (EL -> TRUE .)
    GOSUB           reduce using rule 50 (EL -> TRUE .)
    INPUT           reduce using rule 50 (EL -> TRUE .)
    PRINT           reduce using rule 50 (EL -> TRUE .)
    SUBPROCEDURE    reduce using rule 50 (EL -> TRUE .)
    END             reduce using rule 50 (EL -> TRUE .)
    RETURN          reduce using rule 50 (EL -> TRUE .)
    ELSE            reduce using rule 50 (EL -> TRUE .)
    EIF             reduce using rule 50 (EL -> TRUE .)
    WEND            reduce using rule 50 (EL -> TRUE .)
    NEXT            reduce using rule 50 (EL -> TRUE .)
    GREATHER        reduce using rule 50 (EL -> TRUE .)
    GREATHEREQUAL   reduce using rule 50 (EL -> TRUE .)
    SMALLER         reduce using rule 50 (EL -> TRUE .)
    SMALLEREQUAL    reduce using rule 50 (EL -> TRUE .)
    NOTEQUAL        reduce using rule 50 (EL -> TRUE .)
    EQUALTO         reduce using rule 50 (EL -> TRUE .)
    CLOSINGPAR      reduce using rule 50 (EL -> TRUE .)


state 29

    (51) EL -> FALSE .

    THEN            reduce using rule 51 (EL -> FALSE .)
    LET             reduce using rule 51 (EL -> FALSE .)
    DIM             reduce using rule 51 (EL -> FALSE .)
    IF              reduce using rule 51 (EL -> FALSE .)
    FOR             reduce using rule 51 (EL -> FALSE .)
    WHILE           reduce using rule 51 (EL -> FALSE .)
    GOSUB           reduce using rule 51 (EL -> FALSE .)
    INPUT           reduce using rule 51 (EL -> FALSE .)
    PRINT           reduce using rule 51 (EL -> FALSE .)
    SUBPROCEDURE    reduce using rule 51 (EL -> FALSE .)
    END             reduce using rule 51 (EL -> FALSE .)
    RETURN          reduce using rule 51 (EL -> FALSE .)
    ELSE            reduce using rule 51 (EL -> FALSE .)
    EIF             reduce using rule 51 (EL -> FALSE .)
    WEND            reduce using rule 51 (EL -> FALSE .)
    NEXT            reduce using rule 51 (EL -> FALSE .)
    GREATHER        reduce using rule 51 (EL -> FALSE .)
    GREATHEREQUAL   reduce using rule 51 (EL -> FALSE .)
    SMALLER         reduce using rule 51 (EL -> FALSE .)
    SMALLEREQUAL    reduce using rule 51 (EL -> FALSE .)
    NOTEQUAL        reduce using rule 51 (EL -> FALSE .)
    EQUALTO         reduce using rule 51 (EL -> FALSE .)
    CLOSINGPAR      reduce using rule 51 (EL -> FALSE .)


state 30

    (52) EL -> OPENPAR . O CLOSINGPAR
    (53) EL -> OPENPAR . O CLOSINGPAR OL EL
    (57) O -> . Ex OPR Ex
    (31) Ex -> . EA
    (32) Ex -> . ES
    (33) Ex -> . EL
    (34) Ex -> . ID
    (36) EA -> . P PLUS EA
    (37) EA -> . P MINUS EA
    (38) EA -> . P
    (35) ES -> . WORDVAL
    (50) EL -> . TRUE
    (51) EL -> . FALSE
    (52) EL -> . OPENPAR O CLOSINGPAR
    (53) EL -> . OPENPAR O CLOSINGPAR OL EL
    (39) P -> . N MULTIPLY P
    (40) P -> . N DIVIDE P
    (41) P -> . N
    (42) N -> . cte saveID
    (43) N -> . ID saveID
    (44) N -> . OPENPAR EA CLOSINGPAR
    (45) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (46) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (48) cte -> . INTVAL
    (49) cte -> . FLOATVAL

    ID              shift and go to state 40
    WORDVAL         shift and go to state 35
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    OPENPAR         shift and go to state 42
    INTVAL          shift and go to state 45
    FLOATVAL        shift and go to state 46

    O                              shift and go to state 54
    EL                             shift and go to state 39
    Ex                             shift and go to state 55
    EA                             shift and go to state 37
    ES                             shift and go to state 38
    P                              shift and go to state 41
    N                              shift and go to state 43
    cte                            shift and go to state 44

state 31

    (19) E -> FOR ID . EQUALS EA TO Ex F NEXT ID

    EQUALS          shift and go to state 56


state 32

    (20) E -> WHILE OPENPAR . EL CLOSINGPAR F WEND
    (50) EL -> . TRUE
    (51) EL -> . FALSE
    (52) EL -> . OPENPAR O CLOSINGPAR
    (53) EL -> . OPENPAR O CLOSINGPAR OL EL

    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    OPENPAR         shift and go to state 30

    EL                             shift and go to state 57

state 33

    (21) E -> GOSUB ID .

    LET             reduce using rule 21 (E -> GOSUB ID .)
    DIM             reduce using rule 21 (E -> GOSUB ID .)
    IF              reduce using rule 21 (E -> GOSUB ID .)
    FOR             reduce using rule 21 (E -> GOSUB ID .)
    WHILE           reduce using rule 21 (E -> GOSUB ID .)
    GOSUB           reduce using rule 21 (E -> GOSUB ID .)
    INPUT           reduce using rule 21 (E -> GOSUB ID .)
    PRINT           reduce using rule 21 (E -> GOSUB ID .)
    SUBPROCEDURE    reduce using rule 21 (E -> GOSUB ID .)
    END             reduce using rule 21 (E -> GOSUB ID .)
    RETURN          reduce using rule 21 (E -> GOSUB ID .)
    ELSE            reduce using rule 21 (E -> GOSUB ID .)
    EIF             reduce using rule 21 (E -> GOSUB ID .)
    WEND            reduce using rule 21 (E -> GOSUB ID .)
    NEXT            reduce using rule 21 (E -> GOSUB ID .)


state 34

    (22) E -> INPUT ES . COMA IDEx

    COMA            shift and go to state 58


state 35

    (35) ES -> WORDVAL .

    COMA            reduce using rule 35 (ES -> WORDVAL .)
    LET             reduce using rule 35 (ES -> WORDVAL .)
    DIM             reduce using rule 35 (ES -> WORDVAL .)
    IF              reduce using rule 35 (ES -> WORDVAL .)
    FOR             reduce using rule 35 (ES -> WORDVAL .)
    WHILE           reduce using rule 35 (ES -> WORDVAL .)
    GOSUB           reduce using rule 35 (ES -> WORDVAL .)
    INPUT           reduce using rule 35 (ES -> WORDVAL .)
    PRINT           reduce using rule 35 (ES -> WORDVAL .)
    SUBPROCEDURE    reduce using rule 35 (ES -> WORDVAL .)
    END             reduce using rule 35 (ES -> WORDVAL .)
    RETURN          reduce using rule 35 (ES -> WORDVAL .)
    ELSE            reduce using rule 35 (ES -> WORDVAL .)
    EIF             reduce using rule 35 (ES -> WORDVAL .)
    WEND            reduce using rule 35 (ES -> WORDVAL .)
    NEXT            reduce using rule 35 (ES -> WORDVAL .)
    GREATHER        reduce using rule 35 (ES -> WORDVAL .)
    GREATHEREQUAL   reduce using rule 35 (ES -> WORDVAL .)
    SMALLER         reduce using rule 35 (ES -> WORDVAL .)
    SMALLEREQUAL    reduce using rule 35 (ES -> WORDVAL .)
    NOTEQUAL        reduce using rule 35 (ES -> WORDVAL .)
    EQUALTO         reduce using rule 35 (ES -> WORDVAL .)
    CLOSINGPAR      reduce using rule 35 (ES -> WORDVAL .)


state 36

    (23) E -> PRINT Ex .

    LET             reduce using rule 23 (E -> PRINT Ex .)
    DIM             reduce using rule 23 (E -> PRINT Ex .)
    IF              reduce using rule 23 (E -> PRINT Ex .)
    FOR             reduce using rule 23 (E -> PRINT Ex .)
    WHILE           reduce using rule 23 (E -> PRINT Ex .)
    GOSUB           reduce using rule 23 (E -> PRINT Ex .)
    INPUT           reduce using rule 23 (E -> PRINT Ex .)
    PRINT           reduce using rule 23 (E -> PRINT Ex .)
    SUBPROCEDURE    reduce using rule 23 (E -> PRINT Ex .)
    END             reduce using rule 23 (E -> PRINT Ex .)
    RETURN          reduce using rule 23 (E -> PRINT Ex .)
    ELSE            reduce using rule 23 (E -> PRINT Ex .)
    EIF             reduce using rule 23 (E -> PRINT Ex .)
    WEND            reduce using rule 23 (E -> PRINT Ex .)
    NEXT            reduce using rule 23 (E -> PRINT Ex .)


state 37

    (31) Ex -> EA .

    LET             reduce using rule 31 (Ex -> EA .)
    DIM             reduce using rule 31 (Ex -> EA .)
    IF              reduce using rule 31 (Ex -> EA .)
    FOR             reduce using rule 31 (Ex -> EA .)
    WHILE           reduce using rule 31 (Ex -> EA .)
    GOSUB           reduce using rule 31 (Ex -> EA .)
    INPUT           reduce using rule 31 (Ex -> EA .)
    PRINT           reduce using rule 31 (Ex -> EA .)
    SUBPROCEDURE    reduce using rule 31 (Ex -> EA .)
    END             reduce using rule 31 (Ex -> EA .)
    RETURN          reduce using rule 31 (Ex -> EA .)
    ELSE            reduce using rule 31 (Ex -> EA .)
    EIF             reduce using rule 31 (Ex -> EA .)
    WEND            reduce using rule 31 (Ex -> EA .)
    NEXT            reduce using rule 31 (Ex -> EA .)
    GREATHER        reduce using rule 31 (Ex -> EA .)
    GREATHEREQUAL   reduce using rule 31 (Ex -> EA .)
    SMALLER         reduce using rule 31 (Ex -> EA .)
    SMALLEREQUAL    reduce using rule 31 (Ex -> EA .)
    NOTEQUAL        reduce using rule 31 (Ex -> EA .)
    EQUALTO         reduce using rule 31 (Ex -> EA .)
    CLOSINGPAR      reduce using rule 31 (Ex -> EA .)


state 38

    (32) Ex -> ES .

    LET             reduce using rule 32 (Ex -> ES .)
    DIM             reduce using rule 32 (Ex -> ES .)
    IF              reduce using rule 32 (Ex -> ES .)
    FOR             reduce using rule 32 (Ex -> ES .)
    WHILE           reduce using rule 32 (Ex -> ES .)
    GOSUB           reduce using rule 32 (Ex -> ES .)
    INPUT           reduce using rule 32 (Ex -> ES .)
    PRINT           reduce using rule 32 (Ex -> ES .)
    SUBPROCEDURE    reduce using rule 32 (Ex -> ES .)
    END             reduce using rule 32 (Ex -> ES .)
    RETURN          reduce using rule 32 (Ex -> ES .)
    ELSE            reduce using rule 32 (Ex -> ES .)
    EIF             reduce using rule 32 (Ex -> ES .)
    WEND            reduce using rule 32 (Ex -> ES .)
    NEXT            reduce using rule 32 (Ex -> ES .)
    GREATHER        reduce using rule 32 (Ex -> ES .)
    GREATHEREQUAL   reduce using rule 32 (Ex -> ES .)
    SMALLER         reduce using rule 32 (Ex -> ES .)
    SMALLEREQUAL    reduce using rule 32 (Ex -> ES .)
    NOTEQUAL        reduce using rule 32 (Ex -> ES .)
    EQUALTO         reduce using rule 32 (Ex -> ES .)
    CLOSINGPAR      reduce using rule 32 (Ex -> ES .)


state 39

    (33) Ex -> EL .

    LET             reduce using rule 33 (Ex -> EL .)
    DIM             reduce using rule 33 (Ex -> EL .)
    IF              reduce using rule 33 (Ex -> EL .)
    FOR             reduce using rule 33 (Ex -> EL .)
    WHILE           reduce using rule 33 (Ex -> EL .)
    GOSUB           reduce using rule 33 (Ex -> EL .)
    INPUT           reduce using rule 33 (Ex -> EL .)
    PRINT           reduce using rule 33 (Ex -> EL .)
    SUBPROCEDURE    reduce using rule 33 (Ex -> EL .)
    END             reduce using rule 33 (Ex -> EL .)
    RETURN          reduce using rule 33 (Ex -> EL .)
    ELSE            reduce using rule 33 (Ex -> EL .)
    EIF             reduce using rule 33 (Ex -> EL .)
    WEND            reduce using rule 33 (Ex -> EL .)
    NEXT            reduce using rule 33 (Ex -> EL .)
    GREATHER        reduce using rule 33 (Ex -> EL .)
    GREATHEREQUAL   reduce using rule 33 (Ex -> EL .)
    SMALLER         reduce using rule 33 (Ex -> EL .)
    SMALLEREQUAL    reduce using rule 33 (Ex -> EL .)
    NOTEQUAL        reduce using rule 33 (Ex -> EL .)
    EQUALTO         reduce using rule 33 (Ex -> EL .)
    CLOSINGPAR      reduce using rule 33 (Ex -> EL .)


state 40

    (34) Ex -> ID .
    (43) N -> ID . saveID
    (45) N -> ID . OPENBRACKET INTVAL CLOSINGBRACKET
    (46) N -> ID . OPENBRACKET setType Idv CLOSINGBRACKET
    (47) saveID -> .

  ! reduce/reduce conflict for LET resolved using rule 34 (Ex -> ID .)
  ! reduce/reduce conflict for DIM resolved using rule 34 (Ex -> ID .)
  ! reduce/reduce conflict for IF resolved using rule 34 (Ex -> ID .)
  ! reduce/reduce conflict for FOR resolved using rule 34 (Ex -> ID .)
  ! reduce/reduce conflict for WHILE resolved using rule 34 (Ex -> ID .)
  ! reduce/reduce conflict for GOSUB resolved using rule 34 (Ex -> ID .)
  ! reduce/reduce conflict for INPUT resolved using rule 34 (Ex -> ID .)
  ! reduce/reduce conflict for PRINT resolved using rule 34 (Ex -> ID .)
  ! reduce/reduce conflict for SUBPROCEDURE resolved using rule 34 (Ex -> ID .)
  ! reduce/reduce conflict for END resolved using rule 34 (Ex -> ID .)
  ! reduce/reduce conflict for RETURN resolved using rule 34 (Ex -> ID .)
  ! reduce/reduce conflict for ELSE resolved using rule 34 (Ex -> ID .)
  ! reduce/reduce conflict for EIF resolved using rule 34 (Ex -> ID .)
  ! reduce/reduce conflict for WEND resolved using rule 34 (Ex -> ID .)
  ! reduce/reduce conflict for NEXT resolved using rule 34 (Ex -> ID .)
  ! reduce/reduce conflict for GREATHER resolved using rule 34 (Ex -> ID .)
  ! reduce/reduce conflict for GREATHEREQUAL resolved using rule 34 (Ex -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 34 (Ex -> ID .)
  ! reduce/reduce conflict for SMALLEREQUAL resolved using rule 34 (Ex -> ID .)
  ! reduce/reduce conflict for NOTEQUAL resolved using rule 34 (Ex -> ID .)
  ! reduce/reduce conflict for EQUALTO resolved using rule 34 (Ex -> ID .)
  ! reduce/reduce conflict for CLOSINGPAR resolved using rule 34 (Ex -> ID .)
    LET             reduce using rule 34 (Ex -> ID .)
    DIM             reduce using rule 34 (Ex -> ID .)
    IF              reduce using rule 34 (Ex -> ID .)
    FOR             reduce using rule 34 (Ex -> ID .)
    WHILE           reduce using rule 34 (Ex -> ID .)
    GOSUB           reduce using rule 34 (Ex -> ID .)
    INPUT           reduce using rule 34 (Ex -> ID .)
    PRINT           reduce using rule 34 (Ex -> ID .)
    SUBPROCEDURE    reduce using rule 34 (Ex -> ID .)
    END             reduce using rule 34 (Ex -> ID .)
    RETURN          reduce using rule 34 (Ex -> ID .)
    ELSE            reduce using rule 34 (Ex -> ID .)
    EIF             reduce using rule 34 (Ex -> ID .)
    WEND            reduce using rule 34 (Ex -> ID .)
    NEXT            reduce using rule 34 (Ex -> ID .)
    GREATHER        reduce using rule 34 (Ex -> ID .)
    GREATHEREQUAL   reduce using rule 34 (Ex -> ID .)
    SMALLER         reduce using rule 34 (Ex -> ID .)
    SMALLEREQUAL    reduce using rule 34 (Ex -> ID .)
    NOTEQUAL        reduce using rule 34 (Ex -> ID .)
    EQUALTO         reduce using rule 34 (Ex -> ID .)
    CLOSINGPAR      reduce using rule 34 (Ex -> ID .)
    OPENBRACKET     shift and go to state 60
    MULTIPLY        reduce using rule 47 (saveID -> .)
    DIVIDE          reduce using rule 47 (saveID -> .)
    PLUS            reduce using rule 47 (saveID -> .)
    MINUS           reduce using rule 47 (saveID -> .)

  ! LET             [ reduce using rule 47 (saveID -> .) ]
  ! DIM             [ reduce using rule 47 (saveID -> .) ]
  ! IF              [ reduce using rule 47 (saveID -> .) ]
  ! FOR             [ reduce using rule 47 (saveID -> .) ]
  ! WHILE           [ reduce using rule 47 (saveID -> .) ]
  ! GOSUB           [ reduce using rule 47 (saveID -> .) ]
  ! INPUT           [ reduce using rule 47 (saveID -> .) ]
  ! PRINT           [ reduce using rule 47 (saveID -> .) ]
  ! SUBPROCEDURE    [ reduce using rule 47 (saveID -> .) ]
  ! END             [ reduce using rule 47 (saveID -> .) ]
  ! RETURN          [ reduce using rule 47 (saveID -> .) ]
  ! ELSE            [ reduce using rule 47 (saveID -> .) ]
  ! EIF             [ reduce using rule 47 (saveID -> .) ]
  ! WEND            [ reduce using rule 47 (saveID -> .) ]
  ! NEXT            [ reduce using rule 47 (saveID -> .) ]
  ! GREATHER        [ reduce using rule 47 (saveID -> .) ]
  ! GREATHEREQUAL   [ reduce using rule 47 (saveID -> .) ]
  ! SMALLER         [ reduce using rule 47 (saveID -> .) ]
  ! SMALLEREQUAL    [ reduce using rule 47 (saveID -> .) ]
  ! NOTEQUAL        [ reduce using rule 47 (saveID -> .) ]
  ! EQUALTO         [ reduce using rule 47 (saveID -> .) ]
  ! CLOSINGPAR      [ reduce using rule 47 (saveID -> .) ]

    saveID                         shift and go to state 59

state 41

    (36) EA -> P . PLUS EA
    (37) EA -> P . MINUS EA
    (38) EA -> P .

    PLUS            shift and go to state 61
    MINUS           shift and go to state 62
    LET             reduce using rule 38 (EA -> P .)
    DIM             reduce using rule 38 (EA -> P .)
    IF              reduce using rule 38 (EA -> P .)
    FOR             reduce using rule 38 (EA -> P .)
    WHILE           reduce using rule 38 (EA -> P .)
    GOSUB           reduce using rule 38 (EA -> P .)
    INPUT           reduce using rule 38 (EA -> P .)
    PRINT           reduce using rule 38 (EA -> P .)
    SUBPROCEDURE    reduce using rule 38 (EA -> P .)
    END             reduce using rule 38 (EA -> P .)
    RETURN          reduce using rule 38 (EA -> P .)
    ELSE            reduce using rule 38 (EA -> P .)
    EIF             reduce using rule 38 (EA -> P .)
    WEND            reduce using rule 38 (EA -> P .)
    NEXT            reduce using rule 38 (EA -> P .)
    GREATHER        reduce using rule 38 (EA -> P .)
    GREATHEREQUAL   reduce using rule 38 (EA -> P .)
    SMALLER         reduce using rule 38 (EA -> P .)
    SMALLEREQUAL    reduce using rule 38 (EA -> P .)
    NOTEQUAL        reduce using rule 38 (EA -> P .)
    EQUALTO         reduce using rule 38 (EA -> P .)
    CLOSINGPAR      reduce using rule 38 (EA -> P .)
    TO              reduce using rule 38 (EA -> P .)
    CLOSINGBRACKET  reduce using rule 38 (EA -> P .)


state 42

    (52) EL -> OPENPAR . O CLOSINGPAR
    (53) EL -> OPENPAR . O CLOSINGPAR OL EL
    (44) N -> OPENPAR . EA CLOSINGPAR
    (57) O -> . Ex OPR Ex
    (36) EA -> . P PLUS EA
    (37) EA -> . P MINUS EA
    (38) EA -> . P
    (31) Ex -> . EA
    (32) Ex -> . ES
    (33) Ex -> . EL
    (34) Ex -> . ID
    (39) P -> . N MULTIPLY P
    (40) P -> . N DIVIDE P
    (41) P -> . N
    (35) ES -> . WORDVAL
    (50) EL -> . TRUE
    (51) EL -> . FALSE
    (52) EL -> . OPENPAR O CLOSINGPAR
    (53) EL -> . OPENPAR O CLOSINGPAR OL EL
    (42) N -> . cte saveID
    (43) N -> . ID saveID
    (44) N -> . OPENPAR EA CLOSINGPAR
    (45) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (46) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (48) cte -> . INTVAL
    (49) cte -> . FLOATVAL

    ID              shift and go to state 40
    WORDVAL         shift and go to state 35
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    OPENPAR         shift and go to state 42
    INTVAL          shift and go to state 45
    FLOATVAL        shift and go to state 46

    O                              shift and go to state 54
    EL                             shift and go to state 39
    EA                             shift and go to state 63
    Ex                             shift and go to state 55
    P                              shift and go to state 41
    ES                             shift and go to state 38
    N                              shift and go to state 43
    cte                            shift and go to state 44

state 43

    (39) P -> N . MULTIPLY P
    (40) P -> N . DIVIDE P
    (41) P -> N .

    MULTIPLY        shift and go to state 64
    DIVIDE          shift and go to state 65
    PLUS            reduce using rule 41 (P -> N .)
    MINUS           reduce using rule 41 (P -> N .)
    LET             reduce using rule 41 (P -> N .)
    DIM             reduce using rule 41 (P -> N .)
    IF              reduce using rule 41 (P -> N .)
    FOR             reduce using rule 41 (P -> N .)
    WHILE           reduce using rule 41 (P -> N .)
    GOSUB           reduce using rule 41 (P -> N .)
    INPUT           reduce using rule 41 (P -> N .)
    PRINT           reduce using rule 41 (P -> N .)
    SUBPROCEDURE    reduce using rule 41 (P -> N .)
    END             reduce using rule 41 (P -> N .)
    RETURN          reduce using rule 41 (P -> N .)
    ELSE            reduce using rule 41 (P -> N .)
    EIF             reduce using rule 41 (P -> N .)
    WEND            reduce using rule 41 (P -> N .)
    NEXT            reduce using rule 41 (P -> N .)
    GREATHER        reduce using rule 41 (P -> N .)
    GREATHEREQUAL   reduce using rule 41 (P -> N .)
    SMALLER         reduce using rule 41 (P -> N .)
    SMALLEREQUAL    reduce using rule 41 (P -> N .)
    NOTEQUAL        reduce using rule 41 (P -> N .)
    EQUALTO         reduce using rule 41 (P -> N .)
    CLOSINGPAR      reduce using rule 41 (P -> N .)
    TO              reduce using rule 41 (P -> N .)
    CLOSINGBRACKET  reduce using rule 41 (P -> N .)


state 44

    (42) N -> cte . saveID
    (47) saveID -> .

    MULTIPLY        reduce using rule 47 (saveID -> .)
    DIVIDE          reduce using rule 47 (saveID -> .)
    PLUS            reduce using rule 47 (saveID -> .)
    MINUS           reduce using rule 47 (saveID -> .)
    LET             reduce using rule 47 (saveID -> .)
    DIM             reduce using rule 47 (saveID -> .)
    IF              reduce using rule 47 (saveID -> .)
    FOR             reduce using rule 47 (saveID -> .)
    WHILE           reduce using rule 47 (saveID -> .)
    GOSUB           reduce using rule 47 (saveID -> .)
    INPUT           reduce using rule 47 (saveID -> .)
    PRINT           reduce using rule 47 (saveID -> .)
    SUBPROCEDURE    reduce using rule 47 (saveID -> .)
    END             reduce using rule 47 (saveID -> .)
    RETURN          reduce using rule 47 (saveID -> .)
    ELSE            reduce using rule 47 (saveID -> .)
    EIF             reduce using rule 47 (saveID -> .)
    WEND            reduce using rule 47 (saveID -> .)
    NEXT            reduce using rule 47 (saveID -> .)
    GREATHER        reduce using rule 47 (saveID -> .)
    GREATHEREQUAL   reduce using rule 47 (saveID -> .)
    SMALLER         reduce using rule 47 (saveID -> .)
    SMALLEREQUAL    reduce using rule 47 (saveID -> .)
    NOTEQUAL        reduce using rule 47 (saveID -> .)
    EQUALTO         reduce using rule 47 (saveID -> .)
    CLOSINGPAR      reduce using rule 47 (saveID -> .)
    TO              reduce using rule 47 (saveID -> .)
    CLOSINGBRACKET  reduce using rule 47 (saveID -> .)

    saveID                         shift and go to state 66

state 45

    (48) cte -> INTVAL .

    MULTIPLY        reduce using rule 48 (cte -> INTVAL .)
    DIVIDE          reduce using rule 48 (cte -> INTVAL .)
    PLUS            reduce using rule 48 (cte -> INTVAL .)
    MINUS           reduce using rule 48 (cte -> INTVAL .)
    LET             reduce using rule 48 (cte -> INTVAL .)
    DIM             reduce using rule 48 (cte -> INTVAL .)
    IF              reduce using rule 48 (cte -> INTVAL .)
    FOR             reduce using rule 48 (cte -> INTVAL .)
    WHILE           reduce using rule 48 (cte -> INTVAL .)
    GOSUB           reduce using rule 48 (cte -> INTVAL .)
    INPUT           reduce using rule 48 (cte -> INTVAL .)
    PRINT           reduce using rule 48 (cte -> INTVAL .)
    SUBPROCEDURE    reduce using rule 48 (cte -> INTVAL .)
    END             reduce using rule 48 (cte -> INTVAL .)
    RETURN          reduce using rule 48 (cte -> INTVAL .)
    ELSE            reduce using rule 48 (cte -> INTVAL .)
    EIF             reduce using rule 48 (cte -> INTVAL .)
    WEND            reduce using rule 48 (cte -> INTVAL .)
    NEXT            reduce using rule 48 (cte -> INTVAL .)
    GREATHER        reduce using rule 48 (cte -> INTVAL .)
    GREATHEREQUAL   reduce using rule 48 (cte -> INTVAL .)
    SMALLER         reduce using rule 48 (cte -> INTVAL .)
    SMALLEREQUAL    reduce using rule 48 (cte -> INTVAL .)
    NOTEQUAL        reduce using rule 48 (cte -> INTVAL .)
    EQUALTO         reduce using rule 48 (cte -> INTVAL .)
    CLOSINGPAR      reduce using rule 48 (cte -> INTVAL .)
    TO              reduce using rule 48 (cte -> INTVAL .)
    CLOSINGBRACKET  reduce using rule 48 (cte -> INTVAL .)


state 46

    (49) cte -> FLOATVAL .

    MULTIPLY        reduce using rule 49 (cte -> FLOATVAL .)
    DIVIDE          reduce using rule 49 (cte -> FLOATVAL .)
    PLUS            reduce using rule 49 (cte -> FLOATVAL .)
    MINUS           reduce using rule 49 (cte -> FLOATVAL .)
    LET             reduce using rule 49 (cte -> FLOATVAL .)
    DIM             reduce using rule 49 (cte -> FLOATVAL .)
    IF              reduce using rule 49 (cte -> FLOATVAL .)
    FOR             reduce using rule 49 (cte -> FLOATVAL .)
    WHILE           reduce using rule 49 (cte -> FLOATVAL .)
    GOSUB           reduce using rule 49 (cte -> FLOATVAL .)
    INPUT           reduce using rule 49 (cte -> FLOATVAL .)
    PRINT           reduce using rule 49 (cte -> FLOATVAL .)
    SUBPROCEDURE    reduce using rule 49 (cte -> FLOATVAL .)
    END             reduce using rule 49 (cte -> FLOATVAL .)
    RETURN          reduce using rule 49 (cte -> FLOATVAL .)
    ELSE            reduce using rule 49 (cte -> FLOATVAL .)
    EIF             reduce using rule 49 (cte -> FLOATVAL .)
    WEND            reduce using rule 49 (cte -> FLOATVAL .)
    NEXT            reduce using rule 49 (cte -> FLOATVAL .)
    GREATHER        reduce using rule 49 (cte -> FLOATVAL .)
    GREATHEREQUAL   reduce using rule 49 (cte -> FLOATVAL .)
    SMALLER         reduce using rule 49 (cte -> FLOATVAL .)
    SMALLEREQUAL    reduce using rule 49 (cte -> FLOATVAL .)
    NOTEQUAL        reduce using rule 49 (cte -> FLOATVAL .)
    EQUALTO         reduce using rule 49 (cte -> FLOATVAL .)
    CLOSINGPAR      reduce using rule 49 (cte -> FLOATVAL .)
    TO              reduce using rule 49 (cte -> FLOATVAL .)
    CLOSINGBRACKET  reduce using rule 49 (cte -> FLOATVAL .)


state 47

    (2) V -> DIM setType Idv . AS T Arr

    AS              shift and go to state 67


state 48

    (24) Idv -> ID . COMA Idv
    (25) Idv -> ID .

    COMA            shift and go to state 68
    AS              reduce using rule 25 (Idv -> ID .)
    EQUALS          reduce using rule 25 (Idv -> ID .)
    CLOSINGBRACKET  reduce using rule 25 (Idv -> ID .)


state 49

    (1) PROGRAMA -> PROGRAM V M S END .

    $end            reduce using rule 1 (PROGRAMA -> PROGRAM V M S END .)


state 50

    (10) S -> SUBPROCEDURE ID . TWOPOINTS M RETURN S

    TWOPOINTS       shift and go to state 69


state 51

    (16) E -> LET setType Idv . EQUALS Ex

    EQUALS          shift and go to state 70


state 52

    (17) E -> DIM setType Idv . AS T Arr

    AS              shift and go to state 71


state 53

    (18) E -> IF EL THEN . F Esf EIF
    (14) F -> . E F
    (15) F -> . empty
    (16) E -> . LET setType Idv EQUALS Ex
    (17) E -> . DIM setType Idv AS T Arr
    (18) E -> . IF EL THEN F Esf EIF
    (19) E -> . FOR ID EQUALS EA TO Ex F NEXT ID
    (20) E -> . WHILE OPENPAR EL CLOSINGPAR F WEND
    (21) E -> . GOSUB ID
    (22) E -> . INPUT ES COMA IDEx
    (23) E -> . PRINT Ex
    (64) empty -> .

    LET             shift and go to state 10
    DIM             shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    GOSUB           shift and go to state 15
    INPUT           shift and go to state 16
    PRINT           shift and go to state 17
    ELSE            reduce using rule 64 (empty -> .)
    EIF             reduce using rule 64 (empty -> .)

    F                              shift and go to state 72
    E                              shift and go to state 9
    empty                          shift and go to state 24

state 54

    (52) EL -> OPENPAR O . CLOSINGPAR
    (53) EL -> OPENPAR O . CLOSINGPAR OL EL

    CLOSINGPAR      shift and go to state 73


state 55

    (57) O -> Ex . OPR Ex
    (58) OPR -> . GREATHER
    (59) OPR -> . GREATHEREQUAL
    (60) OPR -> . SMALLER
    (61) OPR -> . SMALLEREQUAL
    (62) OPR -> . NOTEQUAL
    (63) OPR -> . EQUALTO

    GREATHER        shift and go to state 75
    GREATHEREQUAL   shift and go to state 76
    SMALLER         shift and go to state 77
    SMALLEREQUAL    shift and go to state 78
    NOTEQUAL        shift and go to state 79
    EQUALTO         shift and go to state 80

    OPR                            shift and go to state 74

state 56

    (19) E -> FOR ID EQUALS . EA TO Ex F NEXT ID
    (36) EA -> . P PLUS EA
    (37) EA -> . P MINUS EA
    (38) EA -> . P
    (39) P -> . N MULTIPLY P
    (40) P -> . N DIVIDE P
    (41) P -> . N
    (42) N -> . cte saveID
    (43) N -> . ID saveID
    (44) N -> . OPENPAR EA CLOSINGPAR
    (45) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (46) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (48) cte -> . INTVAL
    (49) cte -> . FLOATVAL

    ID              shift and go to state 81
    OPENPAR         shift and go to state 83
    INTVAL          shift and go to state 45
    FLOATVAL        shift and go to state 46

    EA                             shift and go to state 82
    P                              shift and go to state 41
    N                              shift and go to state 43
    cte                            shift and go to state 44

state 57

    (20) E -> WHILE OPENPAR EL . CLOSINGPAR F WEND

    CLOSINGPAR      shift and go to state 84


state 58

    (22) E -> INPUT ES COMA . IDEx
    (29) IDEx -> . ID
    (30) IDEx -> . ID OPENBRACKET setType Idv CLOSINGBRACKET

    ID              shift and go to state 86

    IDEx                           shift and go to state 85

state 59

    (43) N -> ID saveID .

    MULTIPLY        reduce using rule 43 (N -> ID saveID .)
    DIVIDE          reduce using rule 43 (N -> ID saveID .)
    PLUS            reduce using rule 43 (N -> ID saveID .)
    MINUS           reduce using rule 43 (N -> ID saveID .)
    LET             reduce using rule 43 (N -> ID saveID .)
    DIM             reduce using rule 43 (N -> ID saveID .)
    IF              reduce using rule 43 (N -> ID saveID .)
    FOR             reduce using rule 43 (N -> ID saveID .)
    WHILE           reduce using rule 43 (N -> ID saveID .)
    GOSUB           reduce using rule 43 (N -> ID saveID .)
    INPUT           reduce using rule 43 (N -> ID saveID .)
    PRINT           reduce using rule 43 (N -> ID saveID .)
    SUBPROCEDURE    reduce using rule 43 (N -> ID saveID .)
    END             reduce using rule 43 (N -> ID saveID .)
    RETURN          reduce using rule 43 (N -> ID saveID .)
    ELSE            reduce using rule 43 (N -> ID saveID .)
    EIF             reduce using rule 43 (N -> ID saveID .)
    WEND            reduce using rule 43 (N -> ID saveID .)
    NEXT            reduce using rule 43 (N -> ID saveID .)
    GREATHER        reduce using rule 43 (N -> ID saveID .)
    GREATHEREQUAL   reduce using rule 43 (N -> ID saveID .)
    SMALLER         reduce using rule 43 (N -> ID saveID .)
    SMALLEREQUAL    reduce using rule 43 (N -> ID saveID .)
    NOTEQUAL        reduce using rule 43 (N -> ID saveID .)
    EQUALTO         reduce using rule 43 (N -> ID saveID .)
    CLOSINGPAR      reduce using rule 43 (N -> ID saveID .)
    TO              reduce using rule 43 (N -> ID saveID .)
    CLOSINGBRACKET  reduce using rule 43 (N -> ID saveID .)


state 60

    (45) N -> ID OPENBRACKET . INTVAL CLOSINGBRACKET
    (46) N -> ID OPENBRACKET . setType Idv CLOSINGBRACKET
    (26) setType -> .

    INTVAL          shift and go to state 87
    ID              reduce using rule 26 (setType -> .)

    setType                        shift and go to state 88

state 61

    (36) EA -> P PLUS . EA
    (36) EA -> . P PLUS EA
    (37) EA -> . P MINUS EA
    (38) EA -> . P
    (39) P -> . N MULTIPLY P
    (40) P -> . N DIVIDE P
    (41) P -> . N
    (42) N -> . cte saveID
    (43) N -> . ID saveID
    (44) N -> . OPENPAR EA CLOSINGPAR
    (45) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (46) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (48) cte -> . INTVAL
    (49) cte -> . FLOATVAL

    ID              shift and go to state 81
    OPENPAR         shift and go to state 83
    INTVAL          shift and go to state 45
    FLOATVAL        shift and go to state 46

    P                              shift and go to state 41
    EA                             shift and go to state 89
    N                              shift and go to state 43
    cte                            shift and go to state 44

state 62

    (37) EA -> P MINUS . EA
    (36) EA -> . P PLUS EA
    (37) EA -> . P MINUS EA
    (38) EA -> . P
    (39) P -> . N MULTIPLY P
    (40) P -> . N DIVIDE P
    (41) P -> . N
    (42) N -> . cte saveID
    (43) N -> . ID saveID
    (44) N -> . OPENPAR EA CLOSINGPAR
    (45) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (46) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (48) cte -> . INTVAL
    (49) cte -> . FLOATVAL

    ID              shift and go to state 81
    OPENPAR         shift and go to state 83
    INTVAL          shift and go to state 45
    FLOATVAL        shift and go to state 46

    P                              shift and go to state 41
    EA                             shift and go to state 90
    N                              shift and go to state 43
    cte                            shift and go to state 44

state 63

    (44) N -> OPENPAR EA . CLOSINGPAR
    (31) Ex -> EA .

    CLOSINGPAR      shift and go to state 91
    GREATHER        reduce using rule 31 (Ex -> EA .)
    GREATHEREQUAL   reduce using rule 31 (Ex -> EA .)
    SMALLER         reduce using rule 31 (Ex -> EA .)
    SMALLEREQUAL    reduce using rule 31 (Ex -> EA .)
    NOTEQUAL        reduce using rule 31 (Ex -> EA .)
    EQUALTO         reduce using rule 31 (Ex -> EA .)


state 64

    (39) P -> N MULTIPLY . P
    (39) P -> . N MULTIPLY P
    (40) P -> . N DIVIDE P
    (41) P -> . N
    (42) N -> . cte saveID
    (43) N -> . ID saveID
    (44) N -> . OPENPAR EA CLOSINGPAR
    (45) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (46) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (48) cte -> . INTVAL
    (49) cte -> . FLOATVAL

    ID              shift and go to state 81
    OPENPAR         shift and go to state 83
    INTVAL          shift and go to state 45
    FLOATVAL        shift and go to state 46

    N                              shift and go to state 43
    P                              shift and go to state 92
    cte                            shift and go to state 44

state 65

    (40) P -> N DIVIDE . P
    (39) P -> . N MULTIPLY P
    (40) P -> . N DIVIDE P
    (41) P -> . N
    (42) N -> . cte saveID
    (43) N -> . ID saveID
    (44) N -> . OPENPAR EA CLOSINGPAR
    (45) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (46) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (48) cte -> . INTVAL
    (49) cte -> . FLOATVAL

    ID              shift and go to state 81
    OPENPAR         shift and go to state 83
    INTVAL          shift and go to state 45
    FLOATVAL        shift and go to state 46

    N                              shift and go to state 43
    P                              shift and go to state 93
    cte                            shift and go to state 44

state 66

    (42) N -> cte saveID .

    MULTIPLY        reduce using rule 42 (N -> cte saveID .)
    DIVIDE          reduce using rule 42 (N -> cte saveID .)
    PLUS            reduce using rule 42 (N -> cte saveID .)
    MINUS           reduce using rule 42 (N -> cte saveID .)
    LET             reduce using rule 42 (N -> cte saveID .)
    DIM             reduce using rule 42 (N -> cte saveID .)
    IF              reduce using rule 42 (N -> cte saveID .)
    FOR             reduce using rule 42 (N -> cte saveID .)
    WHILE           reduce using rule 42 (N -> cte saveID .)
    GOSUB           reduce using rule 42 (N -> cte saveID .)
    INPUT           reduce using rule 42 (N -> cte saveID .)
    PRINT           reduce using rule 42 (N -> cte saveID .)
    SUBPROCEDURE    reduce using rule 42 (N -> cte saveID .)
    END             reduce using rule 42 (N -> cte saveID .)
    RETURN          reduce using rule 42 (N -> cte saveID .)
    ELSE            reduce using rule 42 (N -> cte saveID .)
    EIF             reduce using rule 42 (N -> cte saveID .)
    WEND            reduce using rule 42 (N -> cte saveID .)
    NEXT            reduce using rule 42 (N -> cte saveID .)
    GREATHER        reduce using rule 42 (N -> cte saveID .)
    GREATHEREQUAL   reduce using rule 42 (N -> cte saveID .)
    SMALLER         reduce using rule 42 (N -> cte saveID .)
    SMALLEREQUAL    reduce using rule 42 (N -> cte saveID .)
    NOTEQUAL        reduce using rule 42 (N -> cte saveID .)
    EQUALTO         reduce using rule 42 (N -> cte saveID .)
    CLOSINGPAR      reduce using rule 42 (N -> cte saveID .)
    TO              reduce using rule 42 (N -> cte saveID .)
    CLOSINGBRACKET  reduce using rule 42 (N -> cte saveID .)


state 67

    (2) V -> DIM setType Idv AS . T Arr
    (7) T -> . INT
    (8) T -> . FLOAT
    (9) T -> . WORD

    INT             shift and go to state 95
    FLOAT           shift and go to state 96
    WORD            shift and go to state 97

    T                              shift and go to state 94

state 68

    (24) Idv -> ID COMA . Idv
    (24) Idv -> . ID COMA Idv
    (25) Idv -> . ID

    ID              shift and go to state 48

    Idv                            shift and go to state 98

state 69

    (10) S -> SUBPROCEDURE ID TWOPOINTS . M RETURN S
    (12) M -> . F M
    (13) M -> . empty
    (14) F -> . E F
    (15) F -> . empty
    (64) empty -> .
    (16) E -> . LET setType Idv EQUALS Ex
    (17) E -> . DIM setType Idv AS T Arr
    (18) E -> . IF EL THEN F Esf EIF
    (19) E -> . FOR ID EQUALS EA TO Ex F NEXT ID
    (20) E -> . WHILE OPENPAR EL CLOSINGPAR F WEND
    (21) E -> . GOSUB ID
    (22) E -> . INPUT ES COMA IDEx
    (23) E -> . PRINT Ex

  ! shift/reduce conflict for LET resolved as shift
  ! shift/reduce conflict for DIM resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for GOSUB resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
    RETURN          reduce using rule 64 (empty -> .)
    LET             shift and go to state 10
    DIM             shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    GOSUB           shift and go to state 15
    INPUT           shift and go to state 16
    PRINT           shift and go to state 17

  ! LET             [ reduce using rule 64 (empty -> .) ]
  ! DIM             [ reduce using rule 64 (empty -> .) ]
  ! IF              [ reduce using rule 64 (empty -> .) ]
  ! FOR             [ reduce using rule 64 (empty -> .) ]
  ! WHILE           [ reduce using rule 64 (empty -> .) ]
  ! GOSUB           [ reduce using rule 64 (empty -> .) ]
  ! INPUT           [ reduce using rule 64 (empty -> .) ]
  ! PRINT           [ reduce using rule 64 (empty -> .) ]

    M                              shift and go to state 99
    F                              shift and go to state 7
    empty                          shift and go to state 8
    E                              shift and go to state 9

state 70

    (16) E -> LET setType Idv EQUALS . Ex
    (31) Ex -> . EA
    (32) Ex -> . ES
    (33) Ex -> . EL
    (34) Ex -> . ID
    (36) EA -> . P PLUS EA
    (37) EA -> . P MINUS EA
    (38) EA -> . P
    (35) ES -> . WORDVAL
    (50) EL -> . TRUE
    (51) EL -> . FALSE
    (52) EL -> . OPENPAR O CLOSINGPAR
    (53) EL -> . OPENPAR O CLOSINGPAR OL EL
    (39) P -> . N MULTIPLY P
    (40) P -> . N DIVIDE P
    (41) P -> . N
    (42) N -> . cte saveID
    (43) N -> . ID saveID
    (44) N -> . OPENPAR EA CLOSINGPAR
    (45) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (46) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (48) cte -> . INTVAL
    (49) cte -> . FLOATVAL

    ID              shift and go to state 40
    WORDVAL         shift and go to state 35
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    OPENPAR         shift and go to state 42
    INTVAL          shift and go to state 45
    FLOATVAL        shift and go to state 46

    Ex                             shift and go to state 100
    EA                             shift and go to state 37
    ES                             shift and go to state 38
    EL                             shift and go to state 39
    P                              shift and go to state 41
    N                              shift and go to state 43
    cte                            shift and go to state 44

state 71

    (17) E -> DIM setType Idv AS . T Arr
    (7) T -> . INT
    (8) T -> . FLOAT
    (9) T -> . WORD

    INT             shift and go to state 95
    FLOAT           shift and go to state 96
    WORD            shift and go to state 97

    T                              shift and go to state 101

state 72

    (18) E -> IF EL THEN F . Esf EIF
    (27) Esf -> . ELSE F
    (28) Esf -> . empty
    (64) empty -> .

    ELSE            shift and go to state 103
    EIF             reduce using rule 64 (empty -> .)

    Esf                            shift and go to state 102
    empty                          shift and go to state 104

state 73

    (52) EL -> OPENPAR O CLOSINGPAR .
    (53) EL -> OPENPAR O CLOSINGPAR . OL EL
    (54) OL -> . AND
    (55) OL -> . OR
    (56) OL -> . NOT

    THEN            reduce using rule 52 (EL -> OPENPAR O CLOSINGPAR .)
    LET             reduce using rule 52 (EL -> OPENPAR O CLOSINGPAR .)
    DIM             reduce using rule 52 (EL -> OPENPAR O CLOSINGPAR .)
    IF              reduce using rule 52 (EL -> OPENPAR O CLOSINGPAR .)
    FOR             reduce using rule 52 (EL -> OPENPAR O CLOSINGPAR .)
    WHILE           reduce using rule 52 (EL -> OPENPAR O CLOSINGPAR .)
    GOSUB           reduce using rule 52 (EL -> OPENPAR O CLOSINGPAR .)
    INPUT           reduce using rule 52 (EL -> OPENPAR O CLOSINGPAR .)
    PRINT           reduce using rule 52 (EL -> OPENPAR O CLOSINGPAR .)
    SUBPROCEDURE    reduce using rule 52 (EL -> OPENPAR O CLOSINGPAR .)
    END             reduce using rule 52 (EL -> OPENPAR O CLOSINGPAR .)
    RETURN          reduce using rule 52 (EL -> OPENPAR O CLOSINGPAR .)
    ELSE            reduce using rule 52 (EL -> OPENPAR O CLOSINGPAR .)
    EIF             reduce using rule 52 (EL -> OPENPAR O CLOSINGPAR .)
    WEND            reduce using rule 52 (EL -> OPENPAR O CLOSINGPAR .)
    NEXT            reduce using rule 52 (EL -> OPENPAR O CLOSINGPAR .)
    GREATHER        reduce using rule 52 (EL -> OPENPAR O CLOSINGPAR .)
    GREATHEREQUAL   reduce using rule 52 (EL -> OPENPAR O CLOSINGPAR .)
    SMALLER         reduce using rule 52 (EL -> OPENPAR O CLOSINGPAR .)
    SMALLEREQUAL    reduce using rule 52 (EL -> OPENPAR O CLOSINGPAR .)
    NOTEQUAL        reduce using rule 52 (EL -> OPENPAR O CLOSINGPAR .)
    EQUALTO         reduce using rule 52 (EL -> OPENPAR O CLOSINGPAR .)
    CLOSINGPAR      reduce using rule 52 (EL -> OPENPAR O CLOSINGPAR .)
    AND             shift and go to state 106
    OR              shift and go to state 107
    NOT             shift and go to state 108

    OL                             shift and go to state 105

state 74

    (57) O -> Ex OPR . Ex
    (31) Ex -> . EA
    (32) Ex -> . ES
    (33) Ex -> . EL
    (34) Ex -> . ID
    (36) EA -> . P PLUS EA
    (37) EA -> . P MINUS EA
    (38) EA -> . P
    (35) ES -> . WORDVAL
    (50) EL -> . TRUE
    (51) EL -> . FALSE
    (52) EL -> . OPENPAR O CLOSINGPAR
    (53) EL -> . OPENPAR O CLOSINGPAR OL EL
    (39) P -> . N MULTIPLY P
    (40) P -> . N DIVIDE P
    (41) P -> . N
    (42) N -> . cte saveID
    (43) N -> . ID saveID
    (44) N -> . OPENPAR EA CLOSINGPAR
    (45) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (46) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (48) cte -> . INTVAL
    (49) cte -> . FLOATVAL

    ID              shift and go to state 40
    WORDVAL         shift and go to state 35
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    OPENPAR         shift and go to state 42
    INTVAL          shift and go to state 45
    FLOATVAL        shift and go to state 46

    Ex                             shift and go to state 109
    EA                             shift and go to state 37
    ES                             shift and go to state 38
    EL                             shift and go to state 39
    P                              shift and go to state 41
    N                              shift and go to state 43
    cte                            shift and go to state 44

state 75

    (58) OPR -> GREATHER .

    ID              reduce using rule 58 (OPR -> GREATHER .)
    WORDVAL         reduce using rule 58 (OPR -> GREATHER .)
    TRUE            reduce using rule 58 (OPR -> GREATHER .)
    FALSE           reduce using rule 58 (OPR -> GREATHER .)
    OPENPAR         reduce using rule 58 (OPR -> GREATHER .)
    INTVAL          reduce using rule 58 (OPR -> GREATHER .)
    FLOATVAL        reduce using rule 58 (OPR -> GREATHER .)


state 76

    (59) OPR -> GREATHEREQUAL .

    ID              reduce using rule 59 (OPR -> GREATHEREQUAL .)
    WORDVAL         reduce using rule 59 (OPR -> GREATHEREQUAL .)
    TRUE            reduce using rule 59 (OPR -> GREATHEREQUAL .)
    FALSE           reduce using rule 59 (OPR -> GREATHEREQUAL .)
    OPENPAR         reduce using rule 59 (OPR -> GREATHEREQUAL .)
    INTVAL          reduce using rule 59 (OPR -> GREATHEREQUAL .)
    FLOATVAL        reduce using rule 59 (OPR -> GREATHEREQUAL .)


state 77

    (60) OPR -> SMALLER .

    ID              reduce using rule 60 (OPR -> SMALLER .)
    WORDVAL         reduce using rule 60 (OPR -> SMALLER .)
    TRUE            reduce using rule 60 (OPR -> SMALLER .)
    FALSE           reduce using rule 60 (OPR -> SMALLER .)
    OPENPAR         reduce using rule 60 (OPR -> SMALLER .)
    INTVAL          reduce using rule 60 (OPR -> SMALLER .)
    FLOATVAL        reduce using rule 60 (OPR -> SMALLER .)


state 78

    (61) OPR -> SMALLEREQUAL .

    ID              reduce using rule 61 (OPR -> SMALLEREQUAL .)
    WORDVAL         reduce using rule 61 (OPR -> SMALLEREQUAL .)
    TRUE            reduce using rule 61 (OPR -> SMALLEREQUAL .)
    FALSE           reduce using rule 61 (OPR -> SMALLEREQUAL .)
    OPENPAR         reduce using rule 61 (OPR -> SMALLEREQUAL .)
    INTVAL          reduce using rule 61 (OPR -> SMALLEREQUAL .)
    FLOATVAL        reduce using rule 61 (OPR -> SMALLEREQUAL .)


state 79

    (62) OPR -> NOTEQUAL .

    ID              reduce using rule 62 (OPR -> NOTEQUAL .)
    WORDVAL         reduce using rule 62 (OPR -> NOTEQUAL .)
    TRUE            reduce using rule 62 (OPR -> NOTEQUAL .)
    FALSE           reduce using rule 62 (OPR -> NOTEQUAL .)
    OPENPAR         reduce using rule 62 (OPR -> NOTEQUAL .)
    INTVAL          reduce using rule 62 (OPR -> NOTEQUAL .)
    FLOATVAL        reduce using rule 62 (OPR -> NOTEQUAL .)


state 80

    (63) OPR -> EQUALTO .

    ID              reduce using rule 63 (OPR -> EQUALTO .)
    WORDVAL         reduce using rule 63 (OPR -> EQUALTO .)
    TRUE            reduce using rule 63 (OPR -> EQUALTO .)
    FALSE           reduce using rule 63 (OPR -> EQUALTO .)
    OPENPAR         reduce using rule 63 (OPR -> EQUALTO .)
    INTVAL          reduce using rule 63 (OPR -> EQUALTO .)
    FLOATVAL        reduce using rule 63 (OPR -> EQUALTO .)


state 81

    (43) N -> ID . saveID
    (45) N -> ID . OPENBRACKET INTVAL CLOSINGBRACKET
    (46) N -> ID . OPENBRACKET setType Idv CLOSINGBRACKET
    (47) saveID -> .

    OPENBRACKET     shift and go to state 60
    MULTIPLY        reduce using rule 47 (saveID -> .)
    DIVIDE          reduce using rule 47 (saveID -> .)
    PLUS            reduce using rule 47 (saveID -> .)
    MINUS           reduce using rule 47 (saveID -> .)
    TO              reduce using rule 47 (saveID -> .)
    LET             reduce using rule 47 (saveID -> .)
    DIM             reduce using rule 47 (saveID -> .)
    IF              reduce using rule 47 (saveID -> .)
    FOR             reduce using rule 47 (saveID -> .)
    WHILE           reduce using rule 47 (saveID -> .)
    GOSUB           reduce using rule 47 (saveID -> .)
    INPUT           reduce using rule 47 (saveID -> .)
    PRINT           reduce using rule 47 (saveID -> .)
    SUBPROCEDURE    reduce using rule 47 (saveID -> .)
    END             reduce using rule 47 (saveID -> .)
    RETURN          reduce using rule 47 (saveID -> .)
    ELSE            reduce using rule 47 (saveID -> .)
    EIF             reduce using rule 47 (saveID -> .)
    WEND            reduce using rule 47 (saveID -> .)
    NEXT            reduce using rule 47 (saveID -> .)
    GREATHER        reduce using rule 47 (saveID -> .)
    GREATHEREQUAL   reduce using rule 47 (saveID -> .)
    SMALLER         reduce using rule 47 (saveID -> .)
    SMALLEREQUAL    reduce using rule 47 (saveID -> .)
    NOTEQUAL        reduce using rule 47 (saveID -> .)
    EQUALTO         reduce using rule 47 (saveID -> .)
    CLOSINGPAR      reduce using rule 47 (saveID -> .)
    CLOSINGBRACKET  reduce using rule 47 (saveID -> .)

    saveID                         shift and go to state 59

state 82

    (19) E -> FOR ID EQUALS EA . TO Ex F NEXT ID

    TO              shift and go to state 110


state 83

    (44) N -> OPENPAR . EA CLOSINGPAR
    (36) EA -> . P PLUS EA
    (37) EA -> . P MINUS EA
    (38) EA -> . P
    (39) P -> . N MULTIPLY P
    (40) P -> . N DIVIDE P
    (41) P -> . N
    (42) N -> . cte saveID
    (43) N -> . ID saveID
    (44) N -> . OPENPAR EA CLOSINGPAR
    (45) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (46) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (48) cte -> . INTVAL
    (49) cte -> . FLOATVAL

    ID              shift and go to state 81
    OPENPAR         shift and go to state 83
    INTVAL          shift and go to state 45
    FLOATVAL        shift and go to state 46

    EA                             shift and go to state 111
    P                              shift and go to state 41
    N                              shift and go to state 43
    cte                            shift and go to state 44

state 84

    (20) E -> WHILE OPENPAR EL CLOSINGPAR . F WEND
    (14) F -> . E F
    (15) F -> . empty
    (16) E -> . LET setType Idv EQUALS Ex
    (17) E -> . DIM setType Idv AS T Arr
    (18) E -> . IF EL THEN F Esf EIF
    (19) E -> . FOR ID EQUALS EA TO Ex F NEXT ID
    (20) E -> . WHILE OPENPAR EL CLOSINGPAR F WEND
    (21) E -> . GOSUB ID
    (22) E -> . INPUT ES COMA IDEx
    (23) E -> . PRINT Ex
    (64) empty -> .

    LET             shift and go to state 10
    DIM             shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    GOSUB           shift and go to state 15
    INPUT           shift and go to state 16
    PRINT           shift and go to state 17
    WEND            reduce using rule 64 (empty -> .)

    F                              shift and go to state 112
    E                              shift and go to state 9
    empty                          shift and go to state 24

state 85

    (22) E -> INPUT ES COMA IDEx .

    LET             reduce using rule 22 (E -> INPUT ES COMA IDEx .)
    DIM             reduce using rule 22 (E -> INPUT ES COMA IDEx .)
    IF              reduce using rule 22 (E -> INPUT ES COMA IDEx .)
    FOR             reduce using rule 22 (E -> INPUT ES COMA IDEx .)
    WHILE           reduce using rule 22 (E -> INPUT ES COMA IDEx .)
    GOSUB           reduce using rule 22 (E -> INPUT ES COMA IDEx .)
    INPUT           reduce using rule 22 (E -> INPUT ES COMA IDEx .)
    PRINT           reduce using rule 22 (E -> INPUT ES COMA IDEx .)
    SUBPROCEDURE    reduce using rule 22 (E -> INPUT ES COMA IDEx .)
    END             reduce using rule 22 (E -> INPUT ES COMA IDEx .)
    RETURN          reduce using rule 22 (E -> INPUT ES COMA IDEx .)
    ELSE            reduce using rule 22 (E -> INPUT ES COMA IDEx .)
    EIF             reduce using rule 22 (E -> INPUT ES COMA IDEx .)
    WEND            reduce using rule 22 (E -> INPUT ES COMA IDEx .)
    NEXT            reduce using rule 22 (E -> INPUT ES COMA IDEx .)


state 86

    (29) IDEx -> ID .
    (30) IDEx -> ID . OPENBRACKET setType Idv CLOSINGBRACKET

    LET             reduce using rule 29 (IDEx -> ID .)
    DIM             reduce using rule 29 (IDEx -> ID .)
    IF              reduce using rule 29 (IDEx -> ID .)
    FOR             reduce using rule 29 (IDEx -> ID .)
    WHILE           reduce using rule 29 (IDEx -> ID .)
    GOSUB           reduce using rule 29 (IDEx -> ID .)
    INPUT           reduce using rule 29 (IDEx -> ID .)
    PRINT           reduce using rule 29 (IDEx -> ID .)
    SUBPROCEDURE    reduce using rule 29 (IDEx -> ID .)
    END             reduce using rule 29 (IDEx -> ID .)
    RETURN          reduce using rule 29 (IDEx -> ID .)
    ELSE            reduce using rule 29 (IDEx -> ID .)
    EIF             reduce using rule 29 (IDEx -> ID .)
    WEND            reduce using rule 29 (IDEx -> ID .)
    NEXT            reduce using rule 29 (IDEx -> ID .)
    OPENBRACKET     shift and go to state 113


state 87

    (45) N -> ID OPENBRACKET INTVAL . CLOSINGBRACKET

    CLOSINGBRACKET  shift and go to state 114


state 88

    (46) N -> ID OPENBRACKET setType . Idv CLOSINGBRACKET
    (24) Idv -> . ID COMA Idv
    (25) Idv -> . ID

    ID              shift and go to state 48

    Idv                            shift and go to state 115

state 89

    (36) EA -> P PLUS EA .

    LET             reduce using rule 36 (EA -> P PLUS EA .)
    DIM             reduce using rule 36 (EA -> P PLUS EA .)
    IF              reduce using rule 36 (EA -> P PLUS EA .)
    FOR             reduce using rule 36 (EA -> P PLUS EA .)
    WHILE           reduce using rule 36 (EA -> P PLUS EA .)
    GOSUB           reduce using rule 36 (EA -> P PLUS EA .)
    INPUT           reduce using rule 36 (EA -> P PLUS EA .)
    PRINT           reduce using rule 36 (EA -> P PLUS EA .)
    SUBPROCEDURE    reduce using rule 36 (EA -> P PLUS EA .)
    END             reduce using rule 36 (EA -> P PLUS EA .)
    RETURN          reduce using rule 36 (EA -> P PLUS EA .)
    ELSE            reduce using rule 36 (EA -> P PLUS EA .)
    EIF             reduce using rule 36 (EA -> P PLUS EA .)
    WEND            reduce using rule 36 (EA -> P PLUS EA .)
    NEXT            reduce using rule 36 (EA -> P PLUS EA .)
    GREATHER        reduce using rule 36 (EA -> P PLUS EA .)
    GREATHEREQUAL   reduce using rule 36 (EA -> P PLUS EA .)
    SMALLER         reduce using rule 36 (EA -> P PLUS EA .)
    SMALLEREQUAL    reduce using rule 36 (EA -> P PLUS EA .)
    NOTEQUAL        reduce using rule 36 (EA -> P PLUS EA .)
    EQUALTO         reduce using rule 36 (EA -> P PLUS EA .)
    CLOSINGPAR      reduce using rule 36 (EA -> P PLUS EA .)
    TO              reduce using rule 36 (EA -> P PLUS EA .)
    CLOSINGBRACKET  reduce using rule 36 (EA -> P PLUS EA .)


state 90

    (37) EA -> P MINUS EA .

    LET             reduce using rule 37 (EA -> P MINUS EA .)
    DIM             reduce using rule 37 (EA -> P MINUS EA .)
    IF              reduce using rule 37 (EA -> P MINUS EA .)
    FOR             reduce using rule 37 (EA -> P MINUS EA .)
    WHILE           reduce using rule 37 (EA -> P MINUS EA .)
    GOSUB           reduce using rule 37 (EA -> P MINUS EA .)
    INPUT           reduce using rule 37 (EA -> P MINUS EA .)
    PRINT           reduce using rule 37 (EA -> P MINUS EA .)
    SUBPROCEDURE    reduce using rule 37 (EA -> P MINUS EA .)
    END             reduce using rule 37 (EA -> P MINUS EA .)
    RETURN          reduce using rule 37 (EA -> P MINUS EA .)
    ELSE            reduce using rule 37 (EA -> P MINUS EA .)
    EIF             reduce using rule 37 (EA -> P MINUS EA .)
    WEND            reduce using rule 37 (EA -> P MINUS EA .)
    NEXT            reduce using rule 37 (EA -> P MINUS EA .)
    GREATHER        reduce using rule 37 (EA -> P MINUS EA .)
    GREATHEREQUAL   reduce using rule 37 (EA -> P MINUS EA .)
    SMALLER         reduce using rule 37 (EA -> P MINUS EA .)
    SMALLEREQUAL    reduce using rule 37 (EA -> P MINUS EA .)
    NOTEQUAL        reduce using rule 37 (EA -> P MINUS EA .)
    EQUALTO         reduce using rule 37 (EA -> P MINUS EA .)
    CLOSINGPAR      reduce using rule 37 (EA -> P MINUS EA .)
    TO              reduce using rule 37 (EA -> P MINUS EA .)
    CLOSINGBRACKET  reduce using rule 37 (EA -> P MINUS EA .)


state 91

    (44) N -> OPENPAR EA CLOSINGPAR .

    MULTIPLY        reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    DIVIDE          reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    PLUS            reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    MINUS           reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    LET             reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    DIM             reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    IF              reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    FOR             reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    WHILE           reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    GOSUB           reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    INPUT           reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    PRINT           reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    SUBPROCEDURE    reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    END             reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    RETURN          reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    ELSE            reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    EIF             reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    WEND            reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    NEXT            reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    GREATHER        reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    GREATHEREQUAL   reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    SMALLER         reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    SMALLEREQUAL    reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    NOTEQUAL        reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    EQUALTO         reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    CLOSINGPAR      reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    TO              reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)
    CLOSINGBRACKET  reduce using rule 44 (N -> OPENPAR EA CLOSINGPAR .)


state 92

    (39) P -> N MULTIPLY P .

    PLUS            reduce using rule 39 (P -> N MULTIPLY P .)
    MINUS           reduce using rule 39 (P -> N MULTIPLY P .)
    LET             reduce using rule 39 (P -> N MULTIPLY P .)
    DIM             reduce using rule 39 (P -> N MULTIPLY P .)
    IF              reduce using rule 39 (P -> N MULTIPLY P .)
    FOR             reduce using rule 39 (P -> N MULTIPLY P .)
    WHILE           reduce using rule 39 (P -> N MULTIPLY P .)
    GOSUB           reduce using rule 39 (P -> N MULTIPLY P .)
    INPUT           reduce using rule 39 (P -> N MULTIPLY P .)
    PRINT           reduce using rule 39 (P -> N MULTIPLY P .)
    SUBPROCEDURE    reduce using rule 39 (P -> N MULTIPLY P .)
    END             reduce using rule 39 (P -> N MULTIPLY P .)
    RETURN          reduce using rule 39 (P -> N MULTIPLY P .)
    ELSE            reduce using rule 39 (P -> N MULTIPLY P .)
    EIF             reduce using rule 39 (P -> N MULTIPLY P .)
    WEND            reduce using rule 39 (P -> N MULTIPLY P .)
    NEXT            reduce using rule 39 (P -> N MULTIPLY P .)
    GREATHER        reduce using rule 39 (P -> N MULTIPLY P .)
    GREATHEREQUAL   reduce using rule 39 (P -> N MULTIPLY P .)
    SMALLER         reduce using rule 39 (P -> N MULTIPLY P .)
    SMALLEREQUAL    reduce using rule 39 (P -> N MULTIPLY P .)
    NOTEQUAL        reduce using rule 39 (P -> N MULTIPLY P .)
    EQUALTO         reduce using rule 39 (P -> N MULTIPLY P .)
    CLOSINGPAR      reduce using rule 39 (P -> N MULTIPLY P .)
    TO              reduce using rule 39 (P -> N MULTIPLY P .)
    CLOSINGBRACKET  reduce using rule 39 (P -> N MULTIPLY P .)


state 93

    (40) P -> N DIVIDE P .

    PLUS            reduce using rule 40 (P -> N DIVIDE P .)
    MINUS           reduce using rule 40 (P -> N DIVIDE P .)
    LET             reduce using rule 40 (P -> N DIVIDE P .)
    DIM             reduce using rule 40 (P -> N DIVIDE P .)
    IF              reduce using rule 40 (P -> N DIVIDE P .)
    FOR             reduce using rule 40 (P -> N DIVIDE P .)
    WHILE           reduce using rule 40 (P -> N DIVIDE P .)
    GOSUB           reduce using rule 40 (P -> N DIVIDE P .)
    INPUT           reduce using rule 40 (P -> N DIVIDE P .)
    PRINT           reduce using rule 40 (P -> N DIVIDE P .)
    SUBPROCEDURE    reduce using rule 40 (P -> N DIVIDE P .)
    END             reduce using rule 40 (P -> N DIVIDE P .)
    RETURN          reduce using rule 40 (P -> N DIVIDE P .)
    ELSE            reduce using rule 40 (P -> N DIVIDE P .)
    EIF             reduce using rule 40 (P -> N DIVIDE P .)
    WEND            reduce using rule 40 (P -> N DIVIDE P .)
    NEXT            reduce using rule 40 (P -> N DIVIDE P .)
    GREATHER        reduce using rule 40 (P -> N DIVIDE P .)
    GREATHEREQUAL   reduce using rule 40 (P -> N DIVIDE P .)
    SMALLER         reduce using rule 40 (P -> N DIVIDE P .)
    SMALLEREQUAL    reduce using rule 40 (P -> N DIVIDE P .)
    NOTEQUAL        reduce using rule 40 (P -> N DIVIDE P .)
    EQUALTO         reduce using rule 40 (P -> N DIVIDE P .)
    CLOSINGPAR      reduce using rule 40 (P -> N DIVIDE P .)
    TO              reduce using rule 40 (P -> N DIVIDE P .)
    CLOSINGBRACKET  reduce using rule 40 (P -> N DIVIDE P .)


state 94

    (2) V -> DIM setType Idv AS T . Arr
    (4) Arr -> . OPENBRACKET EA CLOSINGBRACKET Arr
    (5) Arr -> . OPENBRACKET ID CLOSINGBRACKET Arr
    (6) Arr -> . empty
    (64) empty -> .

    OPENBRACKET     shift and go to state 117
    LET             reduce using rule 64 (empty -> .)
    DIM             reduce using rule 64 (empty -> .)
    IF              reduce using rule 64 (empty -> .)
    FOR             reduce using rule 64 (empty -> .)
    WHILE           reduce using rule 64 (empty -> .)
    GOSUB           reduce using rule 64 (empty -> .)
    INPUT           reduce using rule 64 (empty -> .)
    PRINT           reduce using rule 64 (empty -> .)
    SUBPROCEDURE    reduce using rule 64 (empty -> .)
    END             reduce using rule 64 (empty -> .)

    Arr                            shift and go to state 116
    empty                          shift and go to state 118

state 95

    (7) T -> INT .

    OPENBRACKET     reduce using rule 7 (T -> INT .)
    LET             reduce using rule 7 (T -> INT .)
    DIM             reduce using rule 7 (T -> INT .)
    IF              reduce using rule 7 (T -> INT .)
    FOR             reduce using rule 7 (T -> INT .)
    WHILE           reduce using rule 7 (T -> INT .)
    GOSUB           reduce using rule 7 (T -> INT .)
    INPUT           reduce using rule 7 (T -> INT .)
    PRINT           reduce using rule 7 (T -> INT .)
    SUBPROCEDURE    reduce using rule 7 (T -> INT .)
    END             reduce using rule 7 (T -> INT .)
    RETURN          reduce using rule 7 (T -> INT .)
    ELSE            reduce using rule 7 (T -> INT .)
    EIF             reduce using rule 7 (T -> INT .)
    WEND            reduce using rule 7 (T -> INT .)
    NEXT            reduce using rule 7 (T -> INT .)


state 96

    (8) T -> FLOAT .

    OPENBRACKET     reduce using rule 8 (T -> FLOAT .)
    LET             reduce using rule 8 (T -> FLOAT .)
    DIM             reduce using rule 8 (T -> FLOAT .)
    IF              reduce using rule 8 (T -> FLOAT .)
    FOR             reduce using rule 8 (T -> FLOAT .)
    WHILE           reduce using rule 8 (T -> FLOAT .)
    GOSUB           reduce using rule 8 (T -> FLOAT .)
    INPUT           reduce using rule 8 (T -> FLOAT .)
    PRINT           reduce using rule 8 (T -> FLOAT .)
    SUBPROCEDURE    reduce using rule 8 (T -> FLOAT .)
    END             reduce using rule 8 (T -> FLOAT .)
    RETURN          reduce using rule 8 (T -> FLOAT .)
    ELSE            reduce using rule 8 (T -> FLOAT .)
    EIF             reduce using rule 8 (T -> FLOAT .)
    WEND            reduce using rule 8 (T -> FLOAT .)
    NEXT            reduce using rule 8 (T -> FLOAT .)


state 97

    (9) T -> WORD .

    OPENBRACKET     reduce using rule 9 (T -> WORD .)
    LET             reduce using rule 9 (T -> WORD .)
    DIM             reduce using rule 9 (T -> WORD .)
    IF              reduce using rule 9 (T -> WORD .)
    FOR             reduce using rule 9 (T -> WORD .)
    WHILE           reduce using rule 9 (T -> WORD .)
    GOSUB           reduce using rule 9 (T -> WORD .)
    INPUT           reduce using rule 9 (T -> WORD .)
    PRINT           reduce using rule 9 (T -> WORD .)
    SUBPROCEDURE    reduce using rule 9 (T -> WORD .)
    END             reduce using rule 9 (T -> WORD .)
    RETURN          reduce using rule 9 (T -> WORD .)
    ELSE            reduce using rule 9 (T -> WORD .)
    EIF             reduce using rule 9 (T -> WORD .)
    WEND            reduce using rule 9 (T -> WORD .)
    NEXT            reduce using rule 9 (T -> WORD .)


state 98

    (24) Idv -> ID COMA Idv .

    AS              reduce using rule 24 (Idv -> ID COMA Idv .)
    EQUALS          reduce using rule 24 (Idv -> ID COMA Idv .)
    CLOSINGBRACKET  reduce using rule 24 (Idv -> ID COMA Idv .)


state 99

    (10) S -> SUBPROCEDURE ID TWOPOINTS M . RETURN S

    RETURN          shift and go to state 119


state 100

    (16) E -> LET setType Idv EQUALS Ex .

    LET             reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    DIM             reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    IF              reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    FOR             reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    WHILE           reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    GOSUB           reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    INPUT           reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    PRINT           reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    SUBPROCEDURE    reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    END             reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    RETURN          reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    ELSE            reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    EIF             reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    WEND            reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    NEXT            reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)


state 101

    (17) E -> DIM setType Idv AS T . Arr
    (4) Arr -> . OPENBRACKET EA CLOSINGBRACKET Arr
    (5) Arr -> . OPENBRACKET ID CLOSINGBRACKET Arr
    (6) Arr -> . empty
    (64) empty -> .

    OPENBRACKET     shift and go to state 117
    LET             reduce using rule 64 (empty -> .)
    DIM             reduce using rule 64 (empty -> .)
    IF              reduce using rule 64 (empty -> .)
    FOR             reduce using rule 64 (empty -> .)
    WHILE           reduce using rule 64 (empty -> .)
    GOSUB           reduce using rule 64 (empty -> .)
    INPUT           reduce using rule 64 (empty -> .)
    PRINT           reduce using rule 64 (empty -> .)
    SUBPROCEDURE    reduce using rule 64 (empty -> .)
    END             reduce using rule 64 (empty -> .)
    RETURN          reduce using rule 64 (empty -> .)
    ELSE            reduce using rule 64 (empty -> .)
    EIF             reduce using rule 64 (empty -> .)
    WEND            reduce using rule 64 (empty -> .)
    NEXT            reduce using rule 64 (empty -> .)

    Arr                            shift and go to state 120
    empty                          shift and go to state 118

state 102

    (18) E -> IF EL THEN F Esf . EIF

    EIF             shift and go to state 121


state 103

    (27) Esf -> ELSE . F
    (14) F -> . E F
    (15) F -> . empty
    (16) E -> . LET setType Idv EQUALS Ex
    (17) E -> . DIM setType Idv AS T Arr
    (18) E -> . IF EL THEN F Esf EIF
    (19) E -> . FOR ID EQUALS EA TO Ex F NEXT ID
    (20) E -> . WHILE OPENPAR EL CLOSINGPAR F WEND
    (21) E -> . GOSUB ID
    (22) E -> . INPUT ES COMA IDEx
    (23) E -> . PRINT Ex
    (64) empty -> .

    LET             shift and go to state 10
    DIM             shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    GOSUB           shift and go to state 15
    INPUT           shift and go to state 16
    PRINT           shift and go to state 17
    EIF             reduce using rule 64 (empty -> .)

    F                              shift and go to state 122
    E                              shift and go to state 9
    empty                          shift and go to state 24

state 104

    (28) Esf -> empty .

    EIF             reduce using rule 28 (Esf -> empty .)


state 105

    (53) EL -> OPENPAR O CLOSINGPAR OL . EL
    (50) EL -> . TRUE
    (51) EL -> . FALSE
    (52) EL -> . OPENPAR O CLOSINGPAR
    (53) EL -> . OPENPAR O CLOSINGPAR OL EL

    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    OPENPAR         shift and go to state 30

    EL                             shift and go to state 123

state 106

    (54) OL -> AND .

    TRUE            reduce using rule 54 (OL -> AND .)
    FALSE           reduce using rule 54 (OL -> AND .)
    OPENPAR         reduce using rule 54 (OL -> AND .)


state 107

    (55) OL -> OR .

    TRUE            reduce using rule 55 (OL -> OR .)
    FALSE           reduce using rule 55 (OL -> OR .)
    OPENPAR         reduce using rule 55 (OL -> OR .)


state 108

    (56) OL -> NOT .

    TRUE            reduce using rule 56 (OL -> NOT .)
    FALSE           reduce using rule 56 (OL -> NOT .)
    OPENPAR         reduce using rule 56 (OL -> NOT .)


state 109

    (57) O -> Ex OPR Ex .

    CLOSINGPAR      reduce using rule 57 (O -> Ex OPR Ex .)


state 110

    (19) E -> FOR ID EQUALS EA TO . Ex F NEXT ID
    (31) Ex -> . EA
    (32) Ex -> . ES
    (33) Ex -> . EL
    (34) Ex -> . ID
    (36) EA -> . P PLUS EA
    (37) EA -> . P MINUS EA
    (38) EA -> . P
    (35) ES -> . WORDVAL
    (50) EL -> . TRUE
    (51) EL -> . FALSE
    (52) EL -> . OPENPAR O CLOSINGPAR
    (53) EL -> . OPENPAR O CLOSINGPAR OL EL
    (39) P -> . N MULTIPLY P
    (40) P -> . N DIVIDE P
    (41) P -> . N
    (42) N -> . cte saveID
    (43) N -> . ID saveID
    (44) N -> . OPENPAR EA CLOSINGPAR
    (45) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (46) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (48) cte -> . INTVAL
    (49) cte -> . FLOATVAL

    ID              shift and go to state 40
    WORDVAL         shift and go to state 35
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    OPENPAR         shift and go to state 42
    INTVAL          shift and go to state 45
    FLOATVAL        shift and go to state 46

    EA                             shift and go to state 37
    Ex                             shift and go to state 124
    ES                             shift and go to state 38
    EL                             shift and go to state 39
    P                              shift and go to state 41
    N                              shift and go to state 43
    cte                            shift and go to state 44

state 111

    (44) N -> OPENPAR EA . CLOSINGPAR

    CLOSINGPAR      shift and go to state 91


state 112

    (20) E -> WHILE OPENPAR EL CLOSINGPAR F . WEND

    WEND            shift and go to state 125


state 113

    (30) IDEx -> ID OPENBRACKET . setType Idv CLOSINGBRACKET
    (26) setType -> .

    ID              reduce using rule 26 (setType -> .)

    setType                        shift and go to state 126

state 114

    (45) N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .

    MULTIPLY        reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    DIVIDE          reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    PLUS            reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    MINUS           reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    LET             reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    DIM             reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    IF              reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    FOR             reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    WHILE           reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    GOSUB           reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    INPUT           reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    PRINT           reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    SUBPROCEDURE    reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    END             reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    RETURN          reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    ELSE            reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    EIF             reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    WEND            reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    NEXT            reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    GREATHER        reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    GREATHEREQUAL   reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    SMALLER         reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    SMALLEREQUAL    reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    NOTEQUAL        reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    EQUALTO         reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    CLOSINGPAR      reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    TO              reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    CLOSINGBRACKET  reduce using rule 45 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)


state 115

    (46) N -> ID OPENBRACKET setType Idv . CLOSINGBRACKET

    CLOSINGBRACKET  shift and go to state 127


state 116

    (2) V -> DIM setType Idv AS T Arr .

    LET             reduce using rule 2 (V -> DIM setType Idv AS T Arr .)
    DIM             reduce using rule 2 (V -> DIM setType Idv AS T Arr .)
    IF              reduce using rule 2 (V -> DIM setType Idv AS T Arr .)
    FOR             reduce using rule 2 (V -> DIM setType Idv AS T Arr .)
    WHILE           reduce using rule 2 (V -> DIM setType Idv AS T Arr .)
    GOSUB           reduce using rule 2 (V -> DIM setType Idv AS T Arr .)
    INPUT           reduce using rule 2 (V -> DIM setType Idv AS T Arr .)
    PRINT           reduce using rule 2 (V -> DIM setType Idv AS T Arr .)
    SUBPROCEDURE    reduce using rule 2 (V -> DIM setType Idv AS T Arr .)
    END             reduce using rule 2 (V -> DIM setType Idv AS T Arr .)


state 117

    (4) Arr -> OPENBRACKET . EA CLOSINGBRACKET Arr
    (5) Arr -> OPENBRACKET . ID CLOSINGBRACKET Arr
    (36) EA -> . P PLUS EA
    (37) EA -> . P MINUS EA
    (38) EA -> . P
    (39) P -> . N MULTIPLY P
    (40) P -> . N DIVIDE P
    (41) P -> . N
    (42) N -> . cte saveID
    (43) N -> . ID saveID
    (44) N -> . OPENPAR EA CLOSINGPAR
    (45) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (46) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (48) cte -> . INTVAL
    (49) cte -> . FLOATVAL

    ID              shift and go to state 129
    OPENPAR         shift and go to state 83
    INTVAL          shift and go to state 45
    FLOATVAL        shift and go to state 46

    EA                             shift and go to state 128
    P                              shift and go to state 41
    N                              shift and go to state 43
    cte                            shift and go to state 44

state 118

    (6) Arr -> empty .

    LET             reduce using rule 6 (Arr -> empty .)
    DIM             reduce using rule 6 (Arr -> empty .)
    IF              reduce using rule 6 (Arr -> empty .)
    FOR             reduce using rule 6 (Arr -> empty .)
    WHILE           reduce using rule 6 (Arr -> empty .)
    GOSUB           reduce using rule 6 (Arr -> empty .)
    INPUT           reduce using rule 6 (Arr -> empty .)
    PRINT           reduce using rule 6 (Arr -> empty .)
    SUBPROCEDURE    reduce using rule 6 (Arr -> empty .)
    END             reduce using rule 6 (Arr -> empty .)
    RETURN          reduce using rule 6 (Arr -> empty .)
    ELSE            reduce using rule 6 (Arr -> empty .)
    EIF             reduce using rule 6 (Arr -> empty .)
    WEND            reduce using rule 6 (Arr -> empty .)
    NEXT            reduce using rule 6 (Arr -> empty .)


state 119

    (10) S -> SUBPROCEDURE ID TWOPOINTS M RETURN . S
    (10) S -> . SUBPROCEDURE ID TWOPOINTS M RETURN S
    (11) S -> . empty
    (64) empty -> .

    SUBPROCEDURE    shift and go to state 20
    END             reduce using rule 64 (empty -> .)

    S                              shift and go to state 130
    empty                          shift and go to state 21

state 120

    (17) E -> DIM setType Idv AS T Arr .

    LET             reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    DIM             reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    IF              reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    FOR             reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    WHILE           reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    GOSUB           reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    INPUT           reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    PRINT           reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    SUBPROCEDURE    reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    END             reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    RETURN          reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    ELSE            reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    EIF             reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    WEND            reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    NEXT            reduce using rule 17 (E -> DIM setType Idv AS T Arr .)


state 121

    (18) E -> IF EL THEN F Esf EIF .

    LET             reduce using rule 18 (E -> IF EL THEN F Esf EIF .)
    DIM             reduce using rule 18 (E -> IF EL THEN F Esf EIF .)
    IF              reduce using rule 18 (E -> IF EL THEN F Esf EIF .)
    FOR             reduce using rule 18 (E -> IF EL THEN F Esf EIF .)
    WHILE           reduce using rule 18 (E -> IF EL THEN F Esf EIF .)
    GOSUB           reduce using rule 18 (E -> IF EL THEN F Esf EIF .)
    INPUT           reduce using rule 18 (E -> IF EL THEN F Esf EIF .)
    PRINT           reduce using rule 18 (E -> IF EL THEN F Esf EIF .)
    SUBPROCEDURE    reduce using rule 18 (E -> IF EL THEN F Esf EIF .)
    END             reduce using rule 18 (E -> IF EL THEN F Esf EIF .)
    RETURN          reduce using rule 18 (E -> IF EL THEN F Esf EIF .)
    ELSE            reduce using rule 18 (E -> IF EL THEN F Esf EIF .)
    EIF             reduce using rule 18 (E -> IF EL THEN F Esf EIF .)
    WEND            reduce using rule 18 (E -> IF EL THEN F Esf EIF .)
    NEXT            reduce using rule 18 (E -> IF EL THEN F Esf EIF .)


state 122

    (27) Esf -> ELSE F .

    EIF             reduce using rule 27 (Esf -> ELSE F .)


state 123

    (53) EL -> OPENPAR O CLOSINGPAR OL EL .

    THEN            reduce using rule 53 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    LET             reduce using rule 53 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    DIM             reduce using rule 53 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    IF              reduce using rule 53 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    FOR             reduce using rule 53 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    WHILE           reduce using rule 53 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    GOSUB           reduce using rule 53 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    INPUT           reduce using rule 53 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    PRINT           reduce using rule 53 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    SUBPROCEDURE    reduce using rule 53 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    END             reduce using rule 53 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    RETURN          reduce using rule 53 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    ELSE            reduce using rule 53 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    EIF             reduce using rule 53 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    WEND            reduce using rule 53 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    NEXT            reduce using rule 53 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    GREATHER        reduce using rule 53 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    GREATHEREQUAL   reduce using rule 53 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    SMALLER         reduce using rule 53 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    SMALLEREQUAL    reduce using rule 53 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    NOTEQUAL        reduce using rule 53 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    EQUALTO         reduce using rule 53 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    CLOSINGPAR      reduce using rule 53 (EL -> OPENPAR O CLOSINGPAR OL EL .)


state 124

    (19) E -> FOR ID EQUALS EA TO Ex . F NEXT ID
    (14) F -> . E F
    (15) F -> . empty
    (16) E -> . LET setType Idv EQUALS Ex
    (17) E -> . DIM setType Idv AS T Arr
    (18) E -> . IF EL THEN F Esf EIF
    (19) E -> . FOR ID EQUALS EA TO Ex F NEXT ID
    (20) E -> . WHILE OPENPAR EL CLOSINGPAR F WEND
    (21) E -> . GOSUB ID
    (22) E -> . INPUT ES COMA IDEx
    (23) E -> . PRINT Ex
    (64) empty -> .

    LET             shift and go to state 10
    DIM             shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    GOSUB           shift and go to state 15
    INPUT           shift and go to state 16
    PRINT           shift and go to state 17
    NEXT            reduce using rule 64 (empty -> .)

    F                              shift and go to state 131
    E                              shift and go to state 9
    empty                          shift and go to state 24

state 125

    (20) E -> WHILE OPENPAR EL CLOSINGPAR F WEND .

    LET             reduce using rule 20 (E -> WHILE OPENPAR EL CLOSINGPAR F WEND .)
    DIM             reduce using rule 20 (E -> WHILE OPENPAR EL CLOSINGPAR F WEND .)
    IF              reduce using rule 20 (E -> WHILE OPENPAR EL CLOSINGPAR F WEND .)
    FOR             reduce using rule 20 (E -> WHILE OPENPAR EL CLOSINGPAR F WEND .)
    WHILE           reduce using rule 20 (E -> WHILE OPENPAR EL CLOSINGPAR F WEND .)
    GOSUB           reduce using rule 20 (E -> WHILE OPENPAR EL CLOSINGPAR F WEND .)
    INPUT           reduce using rule 20 (E -> WHILE OPENPAR EL CLOSINGPAR F WEND .)
    PRINT           reduce using rule 20 (E -> WHILE OPENPAR EL CLOSINGPAR F WEND .)
    SUBPROCEDURE    reduce using rule 20 (E -> WHILE OPENPAR EL CLOSINGPAR F WEND .)
    END             reduce using rule 20 (E -> WHILE OPENPAR EL CLOSINGPAR F WEND .)
    RETURN          reduce using rule 20 (E -> WHILE OPENPAR EL CLOSINGPAR F WEND .)
    ELSE            reduce using rule 20 (E -> WHILE OPENPAR EL CLOSINGPAR F WEND .)
    EIF             reduce using rule 20 (E -> WHILE OPENPAR EL CLOSINGPAR F WEND .)
    WEND            reduce using rule 20 (E -> WHILE OPENPAR EL CLOSINGPAR F WEND .)
    NEXT            reduce using rule 20 (E -> WHILE OPENPAR EL CLOSINGPAR F WEND .)


state 126

    (30) IDEx -> ID OPENBRACKET setType . Idv CLOSINGBRACKET
    (24) Idv -> . ID COMA Idv
    (25) Idv -> . ID

    ID              shift and go to state 48

    Idv                            shift and go to state 132

state 127

    (46) N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .

    MULTIPLY        reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    DIVIDE          reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    PLUS            reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    MINUS           reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    LET             reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    DIM             reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    IF              reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    FOR             reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    WHILE           reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    GOSUB           reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    INPUT           reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    PRINT           reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    SUBPROCEDURE    reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    END             reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    RETURN          reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    ELSE            reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    EIF             reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    WEND            reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    NEXT            reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    GREATHER        reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    GREATHEREQUAL   reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    SMALLER         reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    SMALLEREQUAL    reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    NOTEQUAL        reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    EQUALTO         reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    CLOSINGPAR      reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    TO              reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    CLOSINGBRACKET  reduce using rule 46 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)


state 128

    (4) Arr -> OPENBRACKET EA . CLOSINGBRACKET Arr

    CLOSINGBRACKET  shift and go to state 133


state 129

    (5) Arr -> OPENBRACKET ID . CLOSINGBRACKET Arr
    (43) N -> ID . saveID
    (45) N -> ID . OPENBRACKET INTVAL CLOSINGBRACKET
    (46) N -> ID . OPENBRACKET setType Idv CLOSINGBRACKET
    (47) saveID -> .

  ! shift/reduce conflict for CLOSINGBRACKET resolved as shift
    CLOSINGBRACKET  shift and go to state 134
    OPENBRACKET     shift and go to state 60
    MULTIPLY        reduce using rule 47 (saveID -> .)
    DIVIDE          reduce using rule 47 (saveID -> .)
    PLUS            reduce using rule 47 (saveID -> .)
    MINUS           reduce using rule 47 (saveID -> .)

  ! CLOSINGBRACKET  [ reduce using rule 47 (saveID -> .) ]

    saveID                         shift and go to state 59

state 130

    (10) S -> SUBPROCEDURE ID TWOPOINTS M RETURN S .

    END             reduce using rule 10 (S -> SUBPROCEDURE ID TWOPOINTS M RETURN S .)


state 131

    (19) E -> FOR ID EQUALS EA TO Ex F . NEXT ID

    NEXT            shift and go to state 135


state 132

    (30) IDEx -> ID OPENBRACKET setType Idv . CLOSINGBRACKET

    CLOSINGBRACKET  shift and go to state 136


state 133

    (4) Arr -> OPENBRACKET EA CLOSINGBRACKET . Arr
    (4) Arr -> . OPENBRACKET EA CLOSINGBRACKET Arr
    (5) Arr -> . OPENBRACKET ID CLOSINGBRACKET Arr
    (6) Arr -> . empty
    (64) empty -> .

    OPENBRACKET     shift and go to state 117
    LET             reduce using rule 64 (empty -> .)
    DIM             reduce using rule 64 (empty -> .)
    IF              reduce using rule 64 (empty -> .)
    FOR             reduce using rule 64 (empty -> .)
    WHILE           reduce using rule 64 (empty -> .)
    GOSUB           reduce using rule 64 (empty -> .)
    INPUT           reduce using rule 64 (empty -> .)
    PRINT           reduce using rule 64 (empty -> .)
    SUBPROCEDURE    reduce using rule 64 (empty -> .)
    END             reduce using rule 64 (empty -> .)
    RETURN          reduce using rule 64 (empty -> .)
    ELSE            reduce using rule 64 (empty -> .)
    EIF             reduce using rule 64 (empty -> .)
    WEND            reduce using rule 64 (empty -> .)
    NEXT            reduce using rule 64 (empty -> .)

    Arr                            shift and go to state 137
    empty                          shift and go to state 118

state 134

    (5) Arr -> OPENBRACKET ID CLOSINGBRACKET . Arr
    (4) Arr -> . OPENBRACKET EA CLOSINGBRACKET Arr
    (5) Arr -> . OPENBRACKET ID CLOSINGBRACKET Arr
    (6) Arr -> . empty
    (64) empty -> .

    OPENBRACKET     shift and go to state 117
    LET             reduce using rule 64 (empty -> .)
    DIM             reduce using rule 64 (empty -> .)
    IF              reduce using rule 64 (empty -> .)
    FOR             reduce using rule 64 (empty -> .)
    WHILE           reduce using rule 64 (empty -> .)
    GOSUB           reduce using rule 64 (empty -> .)
    INPUT           reduce using rule 64 (empty -> .)
    PRINT           reduce using rule 64 (empty -> .)
    SUBPROCEDURE    reduce using rule 64 (empty -> .)
    END             reduce using rule 64 (empty -> .)
    RETURN          reduce using rule 64 (empty -> .)
    ELSE            reduce using rule 64 (empty -> .)
    EIF             reduce using rule 64 (empty -> .)
    WEND            reduce using rule 64 (empty -> .)
    NEXT            reduce using rule 64 (empty -> .)

    Arr                            shift and go to state 138
    empty                          shift and go to state 118

state 135

    (19) E -> FOR ID EQUALS EA TO Ex F NEXT . ID

    ID              shift and go to state 139


state 136

    (30) IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .

    LET             reduce using rule 30 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    DIM             reduce using rule 30 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    IF              reduce using rule 30 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    FOR             reduce using rule 30 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    WHILE           reduce using rule 30 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    GOSUB           reduce using rule 30 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    INPUT           reduce using rule 30 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    PRINT           reduce using rule 30 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    SUBPROCEDURE    reduce using rule 30 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    END             reduce using rule 30 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    RETURN          reduce using rule 30 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    ELSE            reduce using rule 30 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    EIF             reduce using rule 30 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    WEND            reduce using rule 30 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    NEXT            reduce using rule 30 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)


state 137

    (4) Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .

    LET             reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    DIM             reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    IF              reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    FOR             reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    WHILE           reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    GOSUB           reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    INPUT           reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    PRINT           reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    SUBPROCEDURE    reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    END             reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    RETURN          reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    ELSE            reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    EIF             reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    WEND            reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    NEXT            reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)


state 138

    (5) Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .

    LET             reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    DIM             reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    IF              reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    FOR             reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    WHILE           reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    GOSUB           reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    INPUT           reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    PRINT           reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    SUBPROCEDURE    reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    END             reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    RETURN          reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    ELSE            reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    EIF             reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    WEND            reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    NEXT            reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)


state 139

    (19) E -> FOR ID EQUALS EA TO Ex F NEXT ID .

    LET             reduce using rule 19 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    DIM             reduce using rule 19 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    IF              reduce using rule 19 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    FOR             reduce using rule 19 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    WHILE           reduce using rule 19 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    GOSUB           reduce using rule 19 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    INPUT           reduce using rule 19 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    PRINT           reduce using rule 19 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    SUBPROCEDURE    reduce using rule 19 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    END             reduce using rule 19 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    RETURN          reduce using rule 19 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    ELSE            reduce using rule 19 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    EIF             reduce using rule 19 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    WEND            reduce using rule 19 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    NEXT            reduce using rule 19 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for DIM in state 2 resolved as shift
WARNING: shift/reduce conflict for LET in state 3 resolved as shift
WARNING: shift/reduce conflict for DIM in state 3 resolved as shift
WARNING: shift/reduce conflict for IF in state 3 resolved as shift
WARNING: shift/reduce conflict for FOR in state 3 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 3 resolved as shift
WARNING: shift/reduce conflict for GOSUB in state 3 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 3 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 3 resolved as shift
WARNING: shift/reduce conflict for LET in state 7 resolved as shift
WARNING: shift/reduce conflict for DIM in state 7 resolved as shift
WARNING: shift/reduce conflict for IF in state 7 resolved as shift
WARNING: shift/reduce conflict for FOR in state 7 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 7 resolved as shift
WARNING: shift/reduce conflict for GOSUB in state 7 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 7 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 7 resolved as shift
WARNING: shift/reduce conflict for LET in state 9 resolved as shift
WARNING: shift/reduce conflict for DIM in state 9 resolved as shift
WARNING: shift/reduce conflict for IF in state 9 resolved as shift
WARNING: shift/reduce conflict for FOR in state 9 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 9 resolved as shift
WARNING: shift/reduce conflict for GOSUB in state 9 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 9 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 9 resolved as shift
WARNING: shift/reduce conflict for LET in state 69 resolved as shift
WARNING: shift/reduce conflict for DIM in state 69 resolved as shift
WARNING: shift/reduce conflict for IF in state 69 resolved as shift
WARNING: shift/reduce conflict for FOR in state 69 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 69 resolved as shift
WARNING: shift/reduce conflict for GOSUB in state 69 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 69 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 69 resolved as shift
WARNING: shift/reduce conflict for CLOSINGBRACKET in state 129 resolved as shift
WARNING: reduce/reduce conflict in state 8 resolved using rule (M -> empty)
WARNING: rejected rule (F -> empty) in state 8
WARNING: reduce/reduce conflict in state 40 resolved using rule (Ex -> ID)
WARNING: rejected rule (saveID -> <empty>) in state 40
