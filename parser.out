Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT

Grammar

Rule 0     S' -> PROGRAMA
Rule 1     PROGRAMA -> PROGRAM V M S END
Rule 2     V -> DIM setType Idv AS T Arr
Rule 3     V -> empty
Rule 4     Arr -> OPENBRACKET EA CLOSINGBRACKET Arr
Rule 5     Arr -> OPENBRACKET ID CLOSINGBRACKET Arr
Rule 6     Arr -> empty
Rule 7     T -> INT
Rule 8     T -> FLOAT
Rule 9     T -> WORD
Rule 10    S -> SUBPROCEDURE ID TWOPOINTS M RETURN S
Rule 11    S -> empty
Rule 12    M -> F M
Rule 13    M -> empty
Rule 14    F -> E F
Rule 15    F -> empty
Rule 16    E -> LET setType Idv EQUALS Ex
Rule 17    E -> DIM setType Idv AS T Arr
Rule 18    E -> IF EL THEN first_conditional F Esf EIF final_conditional
Rule 19    E -> FOR ID EQUALS EA TO Ex F NEXT ID
Rule 20    E -> WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional
Rule 21    E -> GOSUB ID
Rule 22    E -> INPUT ES COMA IDEx
Rule 23    E -> PRINT Ex
Rule 24    while_first_conditional -> <empty>
Rule 25    while_second_conditional -> <empty>
Rule 26    while_final_conditional -> <empty>
Rule 27    first_conditional -> <empty>
Rule 28    second_conditional -> <empty>
Rule 29    final_conditional -> <empty>
Rule 30    Esf -> ELSE second_conditional F
Rule 31    Esf -> empty
Rule 32    Idv -> ID COMA Idv
Rule 33    Idv -> ID
Rule 34    setType -> <empty>
Rule 35    IDEx -> ID
Rule 36    IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET
Rule 37    Ex -> EA
Rule 38    Ex -> ES
Rule 39    Ex -> EL
Rule 40    Ex -> ID
Rule 41    ES -> WORDVAL
Rule 42    EA -> EA PLUS P
Rule 43    EA -> EA MINUS P
Rule 44    EA -> P
Rule 45    P -> P MULTIPLY N
Rule 46    P -> P DIVIDE N
Rule 47    P -> N
Rule 48    N -> cte saveID
Rule 49    N -> ID saveID
Rule 50    N -> OPENPAR EA CLOSINGPAR
Rule 51    N -> ID OPENBRACKET INTVAL CLOSINGBRACKET
Rule 52    N -> ID OPENBRACKET setType Idv CLOSINGBRACKET
Rule 53    saveID -> <empty>
Rule 54    cte -> INTVAL
Rule 55    cte -> FLOATVAL
Rule 56    EL -> TRUE
Rule 57    EL -> FALSE
Rule 58    EL -> OPENPAR O CLOSINGPAR
Rule 59    EL -> OPENPAR O CLOSINGPAR OL EL
Rule 60    OL -> AND
Rule 61    OL -> OR
Rule 62    OL -> NOT
Rule 63    O -> Ex GREATHER Ex
Rule 64    O -> Ex GREATHEREQUAL Ex
Rule 65    O -> Ex SMALLER Ex
Rule 66    O -> Ex SMALLEREQUAL Ex
Rule 67    O -> Ex NOTEQUAL Ex
Rule 68    O -> Ex EQUALTO Ex
Rule 69    O -> Ex error Ex
Rule 70    empty -> <empty>

Terminals, with rules where they appear

AND                  : 60
AS                   : 2 17
CLOSINGBRACKET       : 4 5 36 51 52
CLOSINGPAR           : 50 58 59
COMA                 : 22 32
COMMENT              : 
DIM                  : 2 17
DIVIDE               : 46
DO                   : 20
EIF                  : 18
ELSE                 : 30
END                  : 1
EQUALS               : 16 19
EQUALTO              : 68
FALSE                : 57
FLOAT                : 8
FLOATVAL             : 55
FOR                  : 19
GOSUB                : 21
GREATHER             : 63
GREATHEREQUAL        : 64
ID                   : 5 10 19 19 21 32 33 35 36 40 49 51 52
IF                   : 18
INPUT                : 22
INT                  : 7
INTVAL               : 51 54
LET                  : 16
MINUS                : 43
MULTIPLY             : 45
NEXT                 : 19
NOT                  : 62
NOTEQUAL             : 67
OPENBRACKET          : 4 5 36 51 52
OPENPAR              : 50 58 59
OR                   : 61
PLUS                 : 42
PRINT                : 23
PROGRAM              : 1
RETURN               : 10
SMALLER              : 65
SMALLEREQUAL         : 66
SUBPROCEDURE         : 10
THEN                 : 18
TO                   : 19
TRUE                 : 56
TWOPOINTS            : 10
WEND                 : 20
WHILE                : 20
WORD                 : 9
WORDVAL              : 41
error                : 69

Nonterminals, with rules where they appear

Arr                  : 2 4 5 17
E                    : 14
EA                   : 4 19 37 42 43 50
EL                   : 18 20 39 59
ES                   : 22 38
Esf                  : 18
Ex                   : 16 19 23 63 63 64 64 65 65 66 66 67 67 68 68 69 69
F                    : 12 14 18 19 20 30
IDEx                 : 22
Idv                  : 2 16 17 32 36 52
M                    : 1 10 12
N                    : 45 46 47
O                    : 58 59
OL                   : 59
P                    : 42 43 44 45 46
PROGRAMA             : 0
S                    : 1 10
T                    : 2 17
V                    : 1
cte                  : 48
empty                : 3 6 11 13 15 31
final_conditional    : 18
first_conditional    : 18
saveID               : 48 49
second_conditional   : 30
setType              : 2 16 17 36 52
while_final_conditional : 20
while_first_conditional : 20
while_second_conditional : 20

Parsing method: LALR

state 0

    (0) S' -> . PROGRAMA
    (1) PROGRAMA -> . PROGRAM V M S END

    PROGRAM         shift and go to state 2

    PROGRAMA                       shift and go to state 1

state 1

    (0) S' -> PROGRAMA .



state 2

    (1) PROGRAMA -> PROGRAM . V M S END
    (2) V -> . DIM setType Idv AS T Arr
    (3) V -> . empty
    (70) empty -> .

  ! shift/reduce conflict for DIM resolved as shift
    DIM             shift and go to state 4
    LET             reduce using rule 70 (empty -> .)
    IF              reduce using rule 70 (empty -> .)
    FOR             reduce using rule 70 (empty -> .)
    WHILE           reduce using rule 70 (empty -> .)
    GOSUB           reduce using rule 70 (empty -> .)
    INPUT           reduce using rule 70 (empty -> .)
    PRINT           reduce using rule 70 (empty -> .)
    SUBPROCEDURE    reduce using rule 70 (empty -> .)
    END             reduce using rule 70 (empty -> .)

  ! DIM             [ reduce using rule 70 (empty -> .) ]

    V                              shift and go to state 3
    empty                          shift and go to state 5

state 3

    (1) PROGRAMA -> PROGRAM V . M S END
    (12) M -> . F M
    (13) M -> . empty
    (14) F -> . E F
    (15) F -> . empty
    (70) empty -> .
    (16) E -> . LET setType Idv EQUALS Ex
    (17) E -> . DIM setType Idv AS T Arr
    (18) E -> . IF EL THEN first_conditional F Esf EIF final_conditional
    (19) E -> . FOR ID EQUALS EA TO Ex F NEXT ID
    (20) E -> . WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional
    (21) E -> . GOSUB ID
    (22) E -> . INPUT ES COMA IDEx
    (23) E -> . PRINT Ex

  ! shift/reduce conflict for LET resolved as shift
  ! shift/reduce conflict for DIM resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for GOSUB resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
    SUBPROCEDURE    reduce using rule 70 (empty -> .)
    END             reduce using rule 70 (empty -> .)
    LET             shift and go to state 10
    DIM             shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    GOSUB           shift and go to state 15
    INPUT           shift and go to state 16
    PRINT           shift and go to state 17

  ! LET             [ reduce using rule 70 (empty -> .) ]
  ! DIM             [ reduce using rule 70 (empty -> .) ]
  ! IF              [ reduce using rule 70 (empty -> .) ]
  ! FOR             [ reduce using rule 70 (empty -> .) ]
  ! WHILE           [ reduce using rule 70 (empty -> .) ]
  ! GOSUB           [ reduce using rule 70 (empty -> .) ]
  ! INPUT           [ reduce using rule 70 (empty -> .) ]
  ! PRINT           [ reduce using rule 70 (empty -> .) ]

    M                              shift and go to state 6
    F                              shift and go to state 7
    empty                          shift and go to state 8
    E                              shift and go to state 9

state 4

    (2) V -> DIM . setType Idv AS T Arr
    (34) setType -> .

    ID              reduce using rule 34 (setType -> .)

    setType                        shift and go to state 18

state 5

    (3) V -> empty .

    LET             reduce using rule 3 (V -> empty .)
    DIM             reduce using rule 3 (V -> empty .)
    IF              reduce using rule 3 (V -> empty .)
    FOR             reduce using rule 3 (V -> empty .)
    WHILE           reduce using rule 3 (V -> empty .)
    GOSUB           reduce using rule 3 (V -> empty .)
    INPUT           reduce using rule 3 (V -> empty .)
    PRINT           reduce using rule 3 (V -> empty .)
    SUBPROCEDURE    reduce using rule 3 (V -> empty .)
    END             reduce using rule 3 (V -> empty .)


state 6

    (1) PROGRAMA -> PROGRAM V M . S END
    (10) S -> . SUBPROCEDURE ID TWOPOINTS M RETURN S
    (11) S -> . empty
    (70) empty -> .

    SUBPROCEDURE    shift and go to state 20
    END             reduce using rule 70 (empty -> .)

    S                              shift and go to state 19
    empty                          shift and go to state 21

state 7

    (12) M -> F . M
    (12) M -> . F M
    (13) M -> . empty
    (14) F -> . E F
    (15) F -> . empty
    (70) empty -> .
    (16) E -> . LET setType Idv EQUALS Ex
    (17) E -> . DIM setType Idv AS T Arr
    (18) E -> . IF EL THEN first_conditional F Esf EIF final_conditional
    (19) E -> . FOR ID EQUALS EA TO Ex F NEXT ID
    (20) E -> . WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional
    (21) E -> . GOSUB ID
    (22) E -> . INPUT ES COMA IDEx
    (23) E -> . PRINT Ex

  ! shift/reduce conflict for LET resolved as shift
  ! shift/reduce conflict for DIM resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for GOSUB resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
    SUBPROCEDURE    reduce using rule 70 (empty -> .)
    END             reduce using rule 70 (empty -> .)
    RETURN          reduce using rule 70 (empty -> .)
    LET             shift and go to state 10
    DIM             shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    GOSUB           shift and go to state 15
    INPUT           shift and go to state 16
    PRINT           shift and go to state 17

  ! LET             [ reduce using rule 70 (empty -> .) ]
  ! DIM             [ reduce using rule 70 (empty -> .) ]
  ! IF              [ reduce using rule 70 (empty -> .) ]
  ! FOR             [ reduce using rule 70 (empty -> .) ]
  ! WHILE           [ reduce using rule 70 (empty -> .) ]
  ! GOSUB           [ reduce using rule 70 (empty -> .) ]
  ! INPUT           [ reduce using rule 70 (empty -> .) ]
  ! PRINT           [ reduce using rule 70 (empty -> .) ]

    F                              shift and go to state 7
    M                              shift and go to state 22
    empty                          shift and go to state 8
    E                              shift and go to state 9

state 8

    (13) M -> empty .
    (15) F -> empty .

  ! reduce/reduce conflict for SUBPROCEDURE resolved using rule 13 (M -> empty .)
  ! reduce/reduce conflict for END resolved using rule 13 (M -> empty .)
  ! reduce/reduce conflict for RETURN resolved using rule 13 (M -> empty .)
    SUBPROCEDURE    reduce using rule 13 (M -> empty .)
    END             reduce using rule 13 (M -> empty .)
    RETURN          reduce using rule 13 (M -> empty .)
    LET             reduce using rule 15 (F -> empty .)
    DIM             reduce using rule 15 (F -> empty .)
    IF              reduce using rule 15 (F -> empty .)
    FOR             reduce using rule 15 (F -> empty .)
    WHILE           reduce using rule 15 (F -> empty .)
    GOSUB           reduce using rule 15 (F -> empty .)
    INPUT           reduce using rule 15 (F -> empty .)
    PRINT           reduce using rule 15 (F -> empty .)

  ! SUBPROCEDURE    [ reduce using rule 15 (F -> empty .) ]
  ! END             [ reduce using rule 15 (F -> empty .) ]
  ! RETURN          [ reduce using rule 15 (F -> empty .) ]


state 9

    (14) F -> E . F
    (14) F -> . E F
    (15) F -> . empty
    (16) E -> . LET setType Idv EQUALS Ex
    (17) E -> . DIM setType Idv AS T Arr
    (18) E -> . IF EL THEN first_conditional F Esf EIF final_conditional
    (19) E -> . FOR ID EQUALS EA TO Ex F NEXT ID
    (20) E -> . WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional
    (21) E -> . GOSUB ID
    (22) E -> . INPUT ES COMA IDEx
    (23) E -> . PRINT Ex
    (70) empty -> .

  ! shift/reduce conflict for LET resolved as shift
  ! shift/reduce conflict for DIM resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for GOSUB resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
    LET             shift and go to state 10
    DIM             shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    GOSUB           shift and go to state 15
    INPUT           shift and go to state 16
    PRINT           shift and go to state 17
    SUBPROCEDURE    reduce using rule 70 (empty -> .)
    END             reduce using rule 70 (empty -> .)
    RETURN          reduce using rule 70 (empty -> .)
    ELSE            reduce using rule 70 (empty -> .)
    EIF             reduce using rule 70 (empty -> .)
    WEND            reduce using rule 70 (empty -> .)
    NEXT            reduce using rule 70 (empty -> .)

  ! LET             [ reduce using rule 70 (empty -> .) ]
  ! DIM             [ reduce using rule 70 (empty -> .) ]
  ! IF              [ reduce using rule 70 (empty -> .) ]
  ! FOR             [ reduce using rule 70 (empty -> .) ]
  ! WHILE           [ reduce using rule 70 (empty -> .) ]
  ! GOSUB           [ reduce using rule 70 (empty -> .) ]
  ! INPUT           [ reduce using rule 70 (empty -> .) ]
  ! PRINT           [ reduce using rule 70 (empty -> .) ]

    E                              shift and go to state 9
    F                              shift and go to state 23
    empty                          shift and go to state 24

state 10

    (16) E -> LET . setType Idv EQUALS Ex
    (34) setType -> .

    ID              reduce using rule 34 (setType -> .)

    setType                        shift and go to state 25

state 11

    (17) E -> DIM . setType Idv AS T Arr
    (34) setType -> .

    ID              reduce using rule 34 (setType -> .)

    setType                        shift and go to state 26

state 12

    (18) E -> IF . EL THEN first_conditional F Esf EIF final_conditional
    (56) EL -> . TRUE
    (57) EL -> . FALSE
    (58) EL -> . OPENPAR O CLOSINGPAR
    (59) EL -> . OPENPAR O CLOSINGPAR OL EL

    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    OPENPAR         shift and go to state 30

    EL                             shift and go to state 27

state 13

    (19) E -> FOR . ID EQUALS EA TO Ex F NEXT ID

    ID              shift and go to state 31


state 14

    (20) E -> WHILE . while_first_conditional EL DO while_second_conditional F WEND while_final_conditional
    (24) while_first_conditional -> .

    TRUE            reduce using rule 24 (while_first_conditional -> .)
    FALSE           reduce using rule 24 (while_first_conditional -> .)
    OPENPAR         reduce using rule 24 (while_first_conditional -> .)

    while_first_conditional        shift and go to state 32

state 15

    (21) E -> GOSUB . ID

    ID              shift and go to state 33


state 16

    (22) E -> INPUT . ES COMA IDEx
    (41) ES -> . WORDVAL

    WORDVAL         shift and go to state 35

    ES                             shift and go to state 34

state 17

    (23) E -> PRINT . Ex
    (37) Ex -> . EA
    (38) Ex -> . ES
    (39) Ex -> . EL
    (40) Ex -> . ID
    (42) EA -> . EA PLUS P
    (43) EA -> . EA MINUS P
    (44) EA -> . P
    (41) ES -> . WORDVAL
    (56) EL -> . TRUE
    (57) EL -> . FALSE
    (58) EL -> . OPENPAR O CLOSINGPAR
    (59) EL -> . OPENPAR O CLOSINGPAR OL EL
    (45) P -> . P MULTIPLY N
    (46) P -> . P DIVIDE N
    (47) P -> . N
    (48) N -> . cte saveID
    (49) N -> . ID saveID
    (50) N -> . OPENPAR EA CLOSINGPAR
    (51) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (52) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (54) cte -> . INTVAL
    (55) cte -> . FLOATVAL

    ID              shift and go to state 40
    WORDVAL         shift and go to state 35
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    OPENPAR         shift and go to state 42
    INTVAL          shift and go to state 45
    FLOATVAL        shift and go to state 46

    Ex                             shift and go to state 36
    EA                             shift and go to state 37
    ES                             shift and go to state 38
    EL                             shift and go to state 39
    P                              shift and go to state 41
    N                              shift and go to state 43
    cte                            shift and go to state 44

state 18

    (2) V -> DIM setType . Idv AS T Arr
    (32) Idv -> . ID COMA Idv
    (33) Idv -> . ID

    ID              shift and go to state 48

    Idv                            shift and go to state 47

state 19

    (1) PROGRAMA -> PROGRAM V M S . END

    END             shift and go to state 49


state 20

    (10) S -> SUBPROCEDURE . ID TWOPOINTS M RETURN S

    ID              shift and go to state 50


state 21

    (11) S -> empty .

    END             reduce using rule 11 (S -> empty .)


state 22

    (12) M -> F M .

    SUBPROCEDURE    reduce using rule 12 (M -> F M .)
    END             reduce using rule 12 (M -> F M .)
    RETURN          reduce using rule 12 (M -> F M .)


state 23

    (14) F -> E F .

    LET             reduce using rule 14 (F -> E F .)
    DIM             reduce using rule 14 (F -> E F .)
    IF              reduce using rule 14 (F -> E F .)
    FOR             reduce using rule 14 (F -> E F .)
    WHILE           reduce using rule 14 (F -> E F .)
    GOSUB           reduce using rule 14 (F -> E F .)
    INPUT           reduce using rule 14 (F -> E F .)
    PRINT           reduce using rule 14 (F -> E F .)
    SUBPROCEDURE    reduce using rule 14 (F -> E F .)
    END             reduce using rule 14 (F -> E F .)
    RETURN          reduce using rule 14 (F -> E F .)
    ELSE            reduce using rule 14 (F -> E F .)
    EIF             reduce using rule 14 (F -> E F .)
    WEND            reduce using rule 14 (F -> E F .)
    NEXT            reduce using rule 14 (F -> E F .)


state 24

    (15) F -> empty .

    LET             reduce using rule 15 (F -> empty .)
    DIM             reduce using rule 15 (F -> empty .)
    IF              reduce using rule 15 (F -> empty .)
    FOR             reduce using rule 15 (F -> empty .)
    WHILE           reduce using rule 15 (F -> empty .)
    GOSUB           reduce using rule 15 (F -> empty .)
    INPUT           reduce using rule 15 (F -> empty .)
    PRINT           reduce using rule 15 (F -> empty .)
    SUBPROCEDURE    reduce using rule 15 (F -> empty .)
    END             reduce using rule 15 (F -> empty .)
    RETURN          reduce using rule 15 (F -> empty .)
    ELSE            reduce using rule 15 (F -> empty .)
    EIF             reduce using rule 15 (F -> empty .)
    WEND            reduce using rule 15 (F -> empty .)
    NEXT            reduce using rule 15 (F -> empty .)


state 25

    (16) E -> LET setType . Idv EQUALS Ex
    (32) Idv -> . ID COMA Idv
    (33) Idv -> . ID

    ID              shift and go to state 48

    Idv                            shift and go to state 51

state 26

    (17) E -> DIM setType . Idv AS T Arr
    (32) Idv -> . ID COMA Idv
    (33) Idv -> . ID

    ID              shift and go to state 48

    Idv                            shift and go to state 52

state 27

    (18) E -> IF EL . THEN first_conditional F Esf EIF final_conditional

    THEN            shift and go to state 53


state 28

    (56) EL -> TRUE .

    THEN            reduce using rule 56 (EL -> TRUE .)
    LET             reduce using rule 56 (EL -> TRUE .)
    DIM             reduce using rule 56 (EL -> TRUE .)
    IF              reduce using rule 56 (EL -> TRUE .)
    FOR             reduce using rule 56 (EL -> TRUE .)
    WHILE           reduce using rule 56 (EL -> TRUE .)
    GOSUB           reduce using rule 56 (EL -> TRUE .)
    INPUT           reduce using rule 56 (EL -> TRUE .)
    PRINT           reduce using rule 56 (EL -> TRUE .)
    SUBPROCEDURE    reduce using rule 56 (EL -> TRUE .)
    END             reduce using rule 56 (EL -> TRUE .)
    RETURN          reduce using rule 56 (EL -> TRUE .)
    ELSE            reduce using rule 56 (EL -> TRUE .)
    EIF             reduce using rule 56 (EL -> TRUE .)
    WEND            reduce using rule 56 (EL -> TRUE .)
    NEXT            reduce using rule 56 (EL -> TRUE .)
    GREATHER        reduce using rule 56 (EL -> TRUE .)
    GREATHEREQUAL   reduce using rule 56 (EL -> TRUE .)
    SMALLER         reduce using rule 56 (EL -> TRUE .)
    SMALLEREQUAL    reduce using rule 56 (EL -> TRUE .)
    NOTEQUAL        reduce using rule 56 (EL -> TRUE .)
    EQUALTO         reduce using rule 56 (EL -> TRUE .)
    error           reduce using rule 56 (EL -> TRUE .)
    DO              reduce using rule 56 (EL -> TRUE .)
    CLOSINGPAR      reduce using rule 56 (EL -> TRUE .)


state 29

    (57) EL -> FALSE .

    THEN            reduce using rule 57 (EL -> FALSE .)
    LET             reduce using rule 57 (EL -> FALSE .)
    DIM             reduce using rule 57 (EL -> FALSE .)
    IF              reduce using rule 57 (EL -> FALSE .)
    FOR             reduce using rule 57 (EL -> FALSE .)
    WHILE           reduce using rule 57 (EL -> FALSE .)
    GOSUB           reduce using rule 57 (EL -> FALSE .)
    INPUT           reduce using rule 57 (EL -> FALSE .)
    PRINT           reduce using rule 57 (EL -> FALSE .)
    SUBPROCEDURE    reduce using rule 57 (EL -> FALSE .)
    END             reduce using rule 57 (EL -> FALSE .)
    RETURN          reduce using rule 57 (EL -> FALSE .)
    ELSE            reduce using rule 57 (EL -> FALSE .)
    EIF             reduce using rule 57 (EL -> FALSE .)
    WEND            reduce using rule 57 (EL -> FALSE .)
    NEXT            reduce using rule 57 (EL -> FALSE .)
    GREATHER        reduce using rule 57 (EL -> FALSE .)
    GREATHEREQUAL   reduce using rule 57 (EL -> FALSE .)
    SMALLER         reduce using rule 57 (EL -> FALSE .)
    SMALLEREQUAL    reduce using rule 57 (EL -> FALSE .)
    NOTEQUAL        reduce using rule 57 (EL -> FALSE .)
    EQUALTO         reduce using rule 57 (EL -> FALSE .)
    error           reduce using rule 57 (EL -> FALSE .)
    DO              reduce using rule 57 (EL -> FALSE .)
    CLOSINGPAR      reduce using rule 57 (EL -> FALSE .)


state 30

    (58) EL -> OPENPAR . O CLOSINGPAR
    (59) EL -> OPENPAR . O CLOSINGPAR OL EL
    (63) O -> . Ex GREATHER Ex
    (64) O -> . Ex GREATHEREQUAL Ex
    (65) O -> . Ex SMALLER Ex
    (66) O -> . Ex SMALLEREQUAL Ex
    (67) O -> . Ex NOTEQUAL Ex
    (68) O -> . Ex EQUALTO Ex
    (69) O -> . Ex error Ex
    (37) Ex -> . EA
    (38) Ex -> . ES
    (39) Ex -> . EL
    (40) Ex -> . ID
    (42) EA -> . EA PLUS P
    (43) EA -> . EA MINUS P
    (44) EA -> . P
    (41) ES -> . WORDVAL
    (56) EL -> . TRUE
    (57) EL -> . FALSE
    (58) EL -> . OPENPAR O CLOSINGPAR
    (59) EL -> . OPENPAR O CLOSINGPAR OL EL
    (45) P -> . P MULTIPLY N
    (46) P -> . P DIVIDE N
    (47) P -> . N
    (48) N -> . cte saveID
    (49) N -> . ID saveID
    (50) N -> . OPENPAR EA CLOSINGPAR
    (51) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (52) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (54) cte -> . INTVAL
    (55) cte -> . FLOATVAL

    ID              shift and go to state 40
    WORDVAL         shift and go to state 35
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    OPENPAR         shift and go to state 42
    INTVAL          shift and go to state 45
    FLOATVAL        shift and go to state 46

    O                              shift and go to state 54
    EL                             shift and go to state 39
    Ex                             shift and go to state 55
    EA                             shift and go to state 37
    ES                             shift and go to state 38
    P                              shift and go to state 41
    N                              shift and go to state 43
    cte                            shift and go to state 44

state 31

    (19) E -> FOR ID . EQUALS EA TO Ex F NEXT ID

    EQUALS          shift and go to state 56


state 32

    (20) E -> WHILE while_first_conditional . EL DO while_second_conditional F WEND while_final_conditional
    (56) EL -> . TRUE
    (57) EL -> . FALSE
    (58) EL -> . OPENPAR O CLOSINGPAR
    (59) EL -> . OPENPAR O CLOSINGPAR OL EL

    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    OPENPAR         shift and go to state 30

    EL                             shift and go to state 57

state 33

    (21) E -> GOSUB ID .

    LET             reduce using rule 21 (E -> GOSUB ID .)
    DIM             reduce using rule 21 (E -> GOSUB ID .)
    IF              reduce using rule 21 (E -> GOSUB ID .)
    FOR             reduce using rule 21 (E -> GOSUB ID .)
    WHILE           reduce using rule 21 (E -> GOSUB ID .)
    GOSUB           reduce using rule 21 (E -> GOSUB ID .)
    INPUT           reduce using rule 21 (E -> GOSUB ID .)
    PRINT           reduce using rule 21 (E -> GOSUB ID .)
    SUBPROCEDURE    reduce using rule 21 (E -> GOSUB ID .)
    END             reduce using rule 21 (E -> GOSUB ID .)
    RETURN          reduce using rule 21 (E -> GOSUB ID .)
    ELSE            reduce using rule 21 (E -> GOSUB ID .)
    EIF             reduce using rule 21 (E -> GOSUB ID .)
    WEND            reduce using rule 21 (E -> GOSUB ID .)
    NEXT            reduce using rule 21 (E -> GOSUB ID .)


state 34

    (22) E -> INPUT ES . COMA IDEx

    COMA            shift and go to state 58


state 35

    (41) ES -> WORDVAL .

    COMA            reduce using rule 41 (ES -> WORDVAL .)
    LET             reduce using rule 41 (ES -> WORDVAL .)
    DIM             reduce using rule 41 (ES -> WORDVAL .)
    IF              reduce using rule 41 (ES -> WORDVAL .)
    FOR             reduce using rule 41 (ES -> WORDVAL .)
    WHILE           reduce using rule 41 (ES -> WORDVAL .)
    GOSUB           reduce using rule 41 (ES -> WORDVAL .)
    INPUT           reduce using rule 41 (ES -> WORDVAL .)
    PRINT           reduce using rule 41 (ES -> WORDVAL .)
    SUBPROCEDURE    reduce using rule 41 (ES -> WORDVAL .)
    END             reduce using rule 41 (ES -> WORDVAL .)
    RETURN          reduce using rule 41 (ES -> WORDVAL .)
    ELSE            reduce using rule 41 (ES -> WORDVAL .)
    EIF             reduce using rule 41 (ES -> WORDVAL .)
    WEND            reduce using rule 41 (ES -> WORDVAL .)
    NEXT            reduce using rule 41 (ES -> WORDVAL .)
    GREATHER        reduce using rule 41 (ES -> WORDVAL .)
    GREATHEREQUAL   reduce using rule 41 (ES -> WORDVAL .)
    SMALLER         reduce using rule 41 (ES -> WORDVAL .)
    SMALLEREQUAL    reduce using rule 41 (ES -> WORDVAL .)
    NOTEQUAL        reduce using rule 41 (ES -> WORDVAL .)
    EQUALTO         reduce using rule 41 (ES -> WORDVAL .)
    error           reduce using rule 41 (ES -> WORDVAL .)
    CLOSINGPAR      reduce using rule 41 (ES -> WORDVAL .)


state 36

    (23) E -> PRINT Ex .

    LET             reduce using rule 23 (E -> PRINT Ex .)
    DIM             reduce using rule 23 (E -> PRINT Ex .)
    IF              reduce using rule 23 (E -> PRINT Ex .)
    FOR             reduce using rule 23 (E -> PRINT Ex .)
    WHILE           reduce using rule 23 (E -> PRINT Ex .)
    GOSUB           reduce using rule 23 (E -> PRINT Ex .)
    INPUT           reduce using rule 23 (E -> PRINT Ex .)
    PRINT           reduce using rule 23 (E -> PRINT Ex .)
    SUBPROCEDURE    reduce using rule 23 (E -> PRINT Ex .)
    END             reduce using rule 23 (E -> PRINT Ex .)
    RETURN          reduce using rule 23 (E -> PRINT Ex .)
    ELSE            reduce using rule 23 (E -> PRINT Ex .)
    EIF             reduce using rule 23 (E -> PRINT Ex .)
    WEND            reduce using rule 23 (E -> PRINT Ex .)
    NEXT            reduce using rule 23 (E -> PRINT Ex .)


state 37

    (37) Ex -> EA .
    (42) EA -> EA . PLUS P
    (43) EA -> EA . MINUS P

    LET             reduce using rule 37 (Ex -> EA .)
    DIM             reduce using rule 37 (Ex -> EA .)
    IF              reduce using rule 37 (Ex -> EA .)
    FOR             reduce using rule 37 (Ex -> EA .)
    WHILE           reduce using rule 37 (Ex -> EA .)
    GOSUB           reduce using rule 37 (Ex -> EA .)
    INPUT           reduce using rule 37 (Ex -> EA .)
    PRINT           reduce using rule 37 (Ex -> EA .)
    SUBPROCEDURE    reduce using rule 37 (Ex -> EA .)
    END             reduce using rule 37 (Ex -> EA .)
    RETURN          reduce using rule 37 (Ex -> EA .)
    ELSE            reduce using rule 37 (Ex -> EA .)
    EIF             reduce using rule 37 (Ex -> EA .)
    WEND            reduce using rule 37 (Ex -> EA .)
    NEXT            reduce using rule 37 (Ex -> EA .)
    GREATHER        reduce using rule 37 (Ex -> EA .)
    GREATHEREQUAL   reduce using rule 37 (Ex -> EA .)
    SMALLER         reduce using rule 37 (Ex -> EA .)
    SMALLEREQUAL    reduce using rule 37 (Ex -> EA .)
    NOTEQUAL        reduce using rule 37 (Ex -> EA .)
    EQUALTO         reduce using rule 37 (Ex -> EA .)
    error           reduce using rule 37 (Ex -> EA .)
    CLOSINGPAR      reduce using rule 37 (Ex -> EA .)
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60


state 38

    (38) Ex -> ES .

    LET             reduce using rule 38 (Ex -> ES .)
    DIM             reduce using rule 38 (Ex -> ES .)
    IF              reduce using rule 38 (Ex -> ES .)
    FOR             reduce using rule 38 (Ex -> ES .)
    WHILE           reduce using rule 38 (Ex -> ES .)
    GOSUB           reduce using rule 38 (Ex -> ES .)
    INPUT           reduce using rule 38 (Ex -> ES .)
    PRINT           reduce using rule 38 (Ex -> ES .)
    SUBPROCEDURE    reduce using rule 38 (Ex -> ES .)
    END             reduce using rule 38 (Ex -> ES .)
    RETURN          reduce using rule 38 (Ex -> ES .)
    ELSE            reduce using rule 38 (Ex -> ES .)
    EIF             reduce using rule 38 (Ex -> ES .)
    WEND            reduce using rule 38 (Ex -> ES .)
    NEXT            reduce using rule 38 (Ex -> ES .)
    GREATHER        reduce using rule 38 (Ex -> ES .)
    GREATHEREQUAL   reduce using rule 38 (Ex -> ES .)
    SMALLER         reduce using rule 38 (Ex -> ES .)
    SMALLEREQUAL    reduce using rule 38 (Ex -> ES .)
    NOTEQUAL        reduce using rule 38 (Ex -> ES .)
    EQUALTO         reduce using rule 38 (Ex -> ES .)
    error           reduce using rule 38 (Ex -> ES .)
    CLOSINGPAR      reduce using rule 38 (Ex -> ES .)


state 39

    (39) Ex -> EL .

    LET             reduce using rule 39 (Ex -> EL .)
    DIM             reduce using rule 39 (Ex -> EL .)
    IF              reduce using rule 39 (Ex -> EL .)
    FOR             reduce using rule 39 (Ex -> EL .)
    WHILE           reduce using rule 39 (Ex -> EL .)
    GOSUB           reduce using rule 39 (Ex -> EL .)
    INPUT           reduce using rule 39 (Ex -> EL .)
    PRINT           reduce using rule 39 (Ex -> EL .)
    SUBPROCEDURE    reduce using rule 39 (Ex -> EL .)
    END             reduce using rule 39 (Ex -> EL .)
    RETURN          reduce using rule 39 (Ex -> EL .)
    ELSE            reduce using rule 39 (Ex -> EL .)
    EIF             reduce using rule 39 (Ex -> EL .)
    WEND            reduce using rule 39 (Ex -> EL .)
    NEXT            reduce using rule 39 (Ex -> EL .)
    GREATHER        reduce using rule 39 (Ex -> EL .)
    GREATHEREQUAL   reduce using rule 39 (Ex -> EL .)
    SMALLER         reduce using rule 39 (Ex -> EL .)
    SMALLEREQUAL    reduce using rule 39 (Ex -> EL .)
    NOTEQUAL        reduce using rule 39 (Ex -> EL .)
    EQUALTO         reduce using rule 39 (Ex -> EL .)
    error           reduce using rule 39 (Ex -> EL .)
    CLOSINGPAR      reduce using rule 39 (Ex -> EL .)


state 40

    (40) Ex -> ID .
    (49) N -> ID . saveID
    (51) N -> ID . OPENBRACKET INTVAL CLOSINGBRACKET
    (52) N -> ID . OPENBRACKET setType Idv CLOSINGBRACKET
    (53) saveID -> .

  ! reduce/reduce conflict for LET resolved using rule 40 (Ex -> ID .)
  ! reduce/reduce conflict for DIM resolved using rule 40 (Ex -> ID .)
  ! reduce/reduce conflict for IF resolved using rule 40 (Ex -> ID .)
  ! reduce/reduce conflict for FOR resolved using rule 40 (Ex -> ID .)
  ! reduce/reduce conflict for WHILE resolved using rule 40 (Ex -> ID .)
  ! reduce/reduce conflict for GOSUB resolved using rule 40 (Ex -> ID .)
  ! reduce/reduce conflict for INPUT resolved using rule 40 (Ex -> ID .)
  ! reduce/reduce conflict for PRINT resolved using rule 40 (Ex -> ID .)
  ! reduce/reduce conflict for SUBPROCEDURE resolved using rule 40 (Ex -> ID .)
  ! reduce/reduce conflict for END resolved using rule 40 (Ex -> ID .)
  ! reduce/reduce conflict for RETURN resolved using rule 40 (Ex -> ID .)
  ! reduce/reduce conflict for ELSE resolved using rule 40 (Ex -> ID .)
  ! reduce/reduce conflict for EIF resolved using rule 40 (Ex -> ID .)
  ! reduce/reduce conflict for WEND resolved using rule 40 (Ex -> ID .)
  ! reduce/reduce conflict for NEXT resolved using rule 40 (Ex -> ID .)
  ! reduce/reduce conflict for GREATHER resolved using rule 40 (Ex -> ID .)
  ! reduce/reduce conflict for GREATHEREQUAL resolved using rule 40 (Ex -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 40 (Ex -> ID .)
  ! reduce/reduce conflict for SMALLEREQUAL resolved using rule 40 (Ex -> ID .)
  ! reduce/reduce conflict for NOTEQUAL resolved using rule 40 (Ex -> ID .)
  ! reduce/reduce conflict for EQUALTO resolved using rule 40 (Ex -> ID .)
  ! reduce/reduce conflict for error resolved using rule 40 (Ex -> ID .)
  ! reduce/reduce conflict for CLOSINGPAR resolved using rule 40 (Ex -> ID .)
    LET             reduce using rule 40 (Ex -> ID .)
    DIM             reduce using rule 40 (Ex -> ID .)
    IF              reduce using rule 40 (Ex -> ID .)
    FOR             reduce using rule 40 (Ex -> ID .)
    WHILE           reduce using rule 40 (Ex -> ID .)
    GOSUB           reduce using rule 40 (Ex -> ID .)
    INPUT           reduce using rule 40 (Ex -> ID .)
    PRINT           reduce using rule 40 (Ex -> ID .)
    SUBPROCEDURE    reduce using rule 40 (Ex -> ID .)
    END             reduce using rule 40 (Ex -> ID .)
    RETURN          reduce using rule 40 (Ex -> ID .)
    ELSE            reduce using rule 40 (Ex -> ID .)
    EIF             reduce using rule 40 (Ex -> ID .)
    WEND            reduce using rule 40 (Ex -> ID .)
    NEXT            reduce using rule 40 (Ex -> ID .)
    GREATHER        reduce using rule 40 (Ex -> ID .)
    GREATHEREQUAL   reduce using rule 40 (Ex -> ID .)
    SMALLER         reduce using rule 40 (Ex -> ID .)
    SMALLEREQUAL    reduce using rule 40 (Ex -> ID .)
    NOTEQUAL        reduce using rule 40 (Ex -> ID .)
    EQUALTO         reduce using rule 40 (Ex -> ID .)
    error           reduce using rule 40 (Ex -> ID .)
    CLOSINGPAR      reduce using rule 40 (Ex -> ID .)
    OPENBRACKET     shift and go to state 62
    MULTIPLY        reduce using rule 53 (saveID -> .)
    DIVIDE          reduce using rule 53 (saveID -> .)
    PLUS            reduce using rule 53 (saveID -> .)
    MINUS           reduce using rule 53 (saveID -> .)

  ! LET             [ reduce using rule 53 (saveID -> .) ]
  ! DIM             [ reduce using rule 53 (saveID -> .) ]
  ! IF              [ reduce using rule 53 (saveID -> .) ]
  ! FOR             [ reduce using rule 53 (saveID -> .) ]
  ! WHILE           [ reduce using rule 53 (saveID -> .) ]
  ! GOSUB           [ reduce using rule 53 (saveID -> .) ]
  ! INPUT           [ reduce using rule 53 (saveID -> .) ]
  ! PRINT           [ reduce using rule 53 (saveID -> .) ]
  ! SUBPROCEDURE    [ reduce using rule 53 (saveID -> .) ]
  ! END             [ reduce using rule 53 (saveID -> .) ]
  ! RETURN          [ reduce using rule 53 (saveID -> .) ]
  ! ELSE            [ reduce using rule 53 (saveID -> .) ]
  ! EIF             [ reduce using rule 53 (saveID -> .) ]
  ! WEND            [ reduce using rule 53 (saveID -> .) ]
  ! NEXT            [ reduce using rule 53 (saveID -> .) ]
  ! GREATHER        [ reduce using rule 53 (saveID -> .) ]
  ! GREATHEREQUAL   [ reduce using rule 53 (saveID -> .) ]
  ! SMALLER         [ reduce using rule 53 (saveID -> .) ]
  ! SMALLEREQUAL    [ reduce using rule 53 (saveID -> .) ]
  ! NOTEQUAL        [ reduce using rule 53 (saveID -> .) ]
  ! EQUALTO         [ reduce using rule 53 (saveID -> .) ]
  ! error           [ reduce using rule 53 (saveID -> .) ]
  ! CLOSINGPAR      [ reduce using rule 53 (saveID -> .) ]

    saveID                         shift and go to state 61

state 41

    (44) EA -> P .
    (45) P -> P . MULTIPLY N
    (46) P -> P . DIVIDE N

    PLUS            reduce using rule 44 (EA -> P .)
    MINUS           reduce using rule 44 (EA -> P .)
    LET             reduce using rule 44 (EA -> P .)
    DIM             reduce using rule 44 (EA -> P .)
    IF              reduce using rule 44 (EA -> P .)
    FOR             reduce using rule 44 (EA -> P .)
    WHILE           reduce using rule 44 (EA -> P .)
    GOSUB           reduce using rule 44 (EA -> P .)
    INPUT           reduce using rule 44 (EA -> P .)
    PRINT           reduce using rule 44 (EA -> P .)
    SUBPROCEDURE    reduce using rule 44 (EA -> P .)
    END             reduce using rule 44 (EA -> P .)
    RETURN          reduce using rule 44 (EA -> P .)
    ELSE            reduce using rule 44 (EA -> P .)
    EIF             reduce using rule 44 (EA -> P .)
    WEND            reduce using rule 44 (EA -> P .)
    NEXT            reduce using rule 44 (EA -> P .)
    GREATHER        reduce using rule 44 (EA -> P .)
    GREATHEREQUAL   reduce using rule 44 (EA -> P .)
    SMALLER         reduce using rule 44 (EA -> P .)
    SMALLEREQUAL    reduce using rule 44 (EA -> P .)
    NOTEQUAL        reduce using rule 44 (EA -> P .)
    EQUALTO         reduce using rule 44 (EA -> P .)
    error           reduce using rule 44 (EA -> P .)
    CLOSINGPAR      reduce using rule 44 (EA -> P .)
    TO              reduce using rule 44 (EA -> P .)
    CLOSINGBRACKET  reduce using rule 44 (EA -> P .)
    MULTIPLY        shift and go to state 63
    DIVIDE          shift and go to state 64


state 42

    (58) EL -> OPENPAR . O CLOSINGPAR
    (59) EL -> OPENPAR . O CLOSINGPAR OL EL
    (50) N -> OPENPAR . EA CLOSINGPAR
    (63) O -> . Ex GREATHER Ex
    (64) O -> . Ex GREATHEREQUAL Ex
    (65) O -> . Ex SMALLER Ex
    (66) O -> . Ex SMALLEREQUAL Ex
    (67) O -> . Ex NOTEQUAL Ex
    (68) O -> . Ex EQUALTO Ex
    (69) O -> . Ex error Ex
    (42) EA -> . EA PLUS P
    (43) EA -> . EA MINUS P
    (44) EA -> . P
    (37) Ex -> . EA
    (38) Ex -> . ES
    (39) Ex -> . EL
    (40) Ex -> . ID
    (45) P -> . P MULTIPLY N
    (46) P -> . P DIVIDE N
    (47) P -> . N
    (41) ES -> . WORDVAL
    (56) EL -> . TRUE
    (57) EL -> . FALSE
    (58) EL -> . OPENPAR O CLOSINGPAR
    (59) EL -> . OPENPAR O CLOSINGPAR OL EL
    (48) N -> . cte saveID
    (49) N -> . ID saveID
    (50) N -> . OPENPAR EA CLOSINGPAR
    (51) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (52) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (54) cte -> . INTVAL
    (55) cte -> . FLOATVAL

    ID              shift and go to state 40
    WORDVAL         shift and go to state 35
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    OPENPAR         shift and go to state 42
    INTVAL          shift and go to state 45
    FLOATVAL        shift and go to state 46

    O                              shift and go to state 54
    EL                             shift and go to state 39
    EA                             shift and go to state 65
    Ex                             shift and go to state 55
    P                              shift and go to state 41
    ES                             shift and go to state 38
    N                              shift and go to state 43
    cte                            shift and go to state 44

state 43

    (47) P -> N .

    MULTIPLY        reduce using rule 47 (P -> N .)
    DIVIDE          reduce using rule 47 (P -> N .)
    PLUS            reduce using rule 47 (P -> N .)
    MINUS           reduce using rule 47 (P -> N .)
    LET             reduce using rule 47 (P -> N .)
    DIM             reduce using rule 47 (P -> N .)
    IF              reduce using rule 47 (P -> N .)
    FOR             reduce using rule 47 (P -> N .)
    WHILE           reduce using rule 47 (P -> N .)
    GOSUB           reduce using rule 47 (P -> N .)
    INPUT           reduce using rule 47 (P -> N .)
    PRINT           reduce using rule 47 (P -> N .)
    SUBPROCEDURE    reduce using rule 47 (P -> N .)
    END             reduce using rule 47 (P -> N .)
    RETURN          reduce using rule 47 (P -> N .)
    ELSE            reduce using rule 47 (P -> N .)
    EIF             reduce using rule 47 (P -> N .)
    WEND            reduce using rule 47 (P -> N .)
    NEXT            reduce using rule 47 (P -> N .)
    GREATHER        reduce using rule 47 (P -> N .)
    GREATHEREQUAL   reduce using rule 47 (P -> N .)
    SMALLER         reduce using rule 47 (P -> N .)
    SMALLEREQUAL    reduce using rule 47 (P -> N .)
    NOTEQUAL        reduce using rule 47 (P -> N .)
    EQUALTO         reduce using rule 47 (P -> N .)
    error           reduce using rule 47 (P -> N .)
    CLOSINGPAR      reduce using rule 47 (P -> N .)
    TO              reduce using rule 47 (P -> N .)
    CLOSINGBRACKET  reduce using rule 47 (P -> N .)


state 44

    (48) N -> cte . saveID
    (53) saveID -> .

    MULTIPLY        reduce using rule 53 (saveID -> .)
    DIVIDE          reduce using rule 53 (saveID -> .)
    PLUS            reduce using rule 53 (saveID -> .)
    MINUS           reduce using rule 53 (saveID -> .)
    LET             reduce using rule 53 (saveID -> .)
    DIM             reduce using rule 53 (saveID -> .)
    IF              reduce using rule 53 (saveID -> .)
    FOR             reduce using rule 53 (saveID -> .)
    WHILE           reduce using rule 53 (saveID -> .)
    GOSUB           reduce using rule 53 (saveID -> .)
    INPUT           reduce using rule 53 (saveID -> .)
    PRINT           reduce using rule 53 (saveID -> .)
    SUBPROCEDURE    reduce using rule 53 (saveID -> .)
    END             reduce using rule 53 (saveID -> .)
    RETURN          reduce using rule 53 (saveID -> .)
    ELSE            reduce using rule 53 (saveID -> .)
    EIF             reduce using rule 53 (saveID -> .)
    WEND            reduce using rule 53 (saveID -> .)
    NEXT            reduce using rule 53 (saveID -> .)
    GREATHER        reduce using rule 53 (saveID -> .)
    GREATHEREQUAL   reduce using rule 53 (saveID -> .)
    SMALLER         reduce using rule 53 (saveID -> .)
    SMALLEREQUAL    reduce using rule 53 (saveID -> .)
    NOTEQUAL        reduce using rule 53 (saveID -> .)
    EQUALTO         reduce using rule 53 (saveID -> .)
    error           reduce using rule 53 (saveID -> .)
    CLOSINGPAR      reduce using rule 53 (saveID -> .)
    TO              reduce using rule 53 (saveID -> .)
    CLOSINGBRACKET  reduce using rule 53 (saveID -> .)

    saveID                         shift and go to state 66

state 45

    (54) cte -> INTVAL .

    MULTIPLY        reduce using rule 54 (cte -> INTVAL .)
    DIVIDE          reduce using rule 54 (cte -> INTVAL .)
    PLUS            reduce using rule 54 (cte -> INTVAL .)
    MINUS           reduce using rule 54 (cte -> INTVAL .)
    LET             reduce using rule 54 (cte -> INTVAL .)
    DIM             reduce using rule 54 (cte -> INTVAL .)
    IF              reduce using rule 54 (cte -> INTVAL .)
    FOR             reduce using rule 54 (cte -> INTVAL .)
    WHILE           reduce using rule 54 (cte -> INTVAL .)
    GOSUB           reduce using rule 54 (cte -> INTVAL .)
    INPUT           reduce using rule 54 (cte -> INTVAL .)
    PRINT           reduce using rule 54 (cte -> INTVAL .)
    SUBPROCEDURE    reduce using rule 54 (cte -> INTVAL .)
    END             reduce using rule 54 (cte -> INTVAL .)
    RETURN          reduce using rule 54 (cte -> INTVAL .)
    ELSE            reduce using rule 54 (cte -> INTVAL .)
    EIF             reduce using rule 54 (cte -> INTVAL .)
    WEND            reduce using rule 54 (cte -> INTVAL .)
    NEXT            reduce using rule 54 (cte -> INTVAL .)
    GREATHER        reduce using rule 54 (cte -> INTVAL .)
    GREATHEREQUAL   reduce using rule 54 (cte -> INTVAL .)
    SMALLER         reduce using rule 54 (cte -> INTVAL .)
    SMALLEREQUAL    reduce using rule 54 (cte -> INTVAL .)
    NOTEQUAL        reduce using rule 54 (cte -> INTVAL .)
    EQUALTO         reduce using rule 54 (cte -> INTVAL .)
    error           reduce using rule 54 (cte -> INTVAL .)
    CLOSINGPAR      reduce using rule 54 (cte -> INTVAL .)
    TO              reduce using rule 54 (cte -> INTVAL .)
    CLOSINGBRACKET  reduce using rule 54 (cte -> INTVAL .)


state 46

    (55) cte -> FLOATVAL .

    MULTIPLY        reduce using rule 55 (cte -> FLOATVAL .)
    DIVIDE          reduce using rule 55 (cte -> FLOATVAL .)
    PLUS            reduce using rule 55 (cte -> FLOATVAL .)
    MINUS           reduce using rule 55 (cte -> FLOATVAL .)
    LET             reduce using rule 55 (cte -> FLOATVAL .)
    DIM             reduce using rule 55 (cte -> FLOATVAL .)
    IF              reduce using rule 55 (cte -> FLOATVAL .)
    FOR             reduce using rule 55 (cte -> FLOATVAL .)
    WHILE           reduce using rule 55 (cte -> FLOATVAL .)
    GOSUB           reduce using rule 55 (cte -> FLOATVAL .)
    INPUT           reduce using rule 55 (cte -> FLOATVAL .)
    PRINT           reduce using rule 55 (cte -> FLOATVAL .)
    SUBPROCEDURE    reduce using rule 55 (cte -> FLOATVAL .)
    END             reduce using rule 55 (cte -> FLOATVAL .)
    RETURN          reduce using rule 55 (cte -> FLOATVAL .)
    ELSE            reduce using rule 55 (cte -> FLOATVAL .)
    EIF             reduce using rule 55 (cte -> FLOATVAL .)
    WEND            reduce using rule 55 (cte -> FLOATVAL .)
    NEXT            reduce using rule 55 (cte -> FLOATVAL .)
    GREATHER        reduce using rule 55 (cte -> FLOATVAL .)
    GREATHEREQUAL   reduce using rule 55 (cte -> FLOATVAL .)
    SMALLER         reduce using rule 55 (cte -> FLOATVAL .)
    SMALLEREQUAL    reduce using rule 55 (cte -> FLOATVAL .)
    NOTEQUAL        reduce using rule 55 (cte -> FLOATVAL .)
    EQUALTO         reduce using rule 55 (cte -> FLOATVAL .)
    error           reduce using rule 55 (cte -> FLOATVAL .)
    CLOSINGPAR      reduce using rule 55 (cte -> FLOATVAL .)
    TO              reduce using rule 55 (cte -> FLOATVAL .)
    CLOSINGBRACKET  reduce using rule 55 (cte -> FLOATVAL .)


state 47

    (2) V -> DIM setType Idv . AS T Arr

    AS              shift and go to state 67


state 48

    (32) Idv -> ID . COMA Idv
    (33) Idv -> ID .

    COMA            shift and go to state 68
    AS              reduce using rule 33 (Idv -> ID .)
    EQUALS          reduce using rule 33 (Idv -> ID .)
    CLOSINGBRACKET  reduce using rule 33 (Idv -> ID .)


state 49

    (1) PROGRAMA -> PROGRAM V M S END .

    $end            reduce using rule 1 (PROGRAMA -> PROGRAM V M S END .)


state 50

    (10) S -> SUBPROCEDURE ID . TWOPOINTS M RETURN S

    TWOPOINTS       shift and go to state 69


state 51

    (16) E -> LET setType Idv . EQUALS Ex

    EQUALS          shift and go to state 70


state 52

    (17) E -> DIM setType Idv . AS T Arr

    AS              shift and go to state 71


state 53

    (18) E -> IF EL THEN . first_conditional F Esf EIF final_conditional
    (27) first_conditional -> .

    LET             reduce using rule 27 (first_conditional -> .)
    DIM             reduce using rule 27 (first_conditional -> .)
    IF              reduce using rule 27 (first_conditional -> .)
    FOR             reduce using rule 27 (first_conditional -> .)
    WHILE           reduce using rule 27 (first_conditional -> .)
    GOSUB           reduce using rule 27 (first_conditional -> .)
    INPUT           reduce using rule 27 (first_conditional -> .)
    PRINT           reduce using rule 27 (first_conditional -> .)
    ELSE            reduce using rule 27 (first_conditional -> .)
    EIF             reduce using rule 27 (first_conditional -> .)

    first_conditional              shift and go to state 72

state 54

    (58) EL -> OPENPAR O . CLOSINGPAR
    (59) EL -> OPENPAR O . CLOSINGPAR OL EL

    CLOSINGPAR      shift and go to state 73


state 55

    (63) O -> Ex . GREATHER Ex
    (64) O -> Ex . GREATHEREQUAL Ex
    (65) O -> Ex . SMALLER Ex
    (66) O -> Ex . SMALLEREQUAL Ex
    (67) O -> Ex . NOTEQUAL Ex
    (68) O -> Ex . EQUALTO Ex
    (69) O -> Ex . error Ex

    GREATHER        shift and go to state 74
    GREATHEREQUAL   shift and go to state 75
    SMALLER         shift and go to state 76
    SMALLEREQUAL    shift and go to state 77
    NOTEQUAL        shift and go to state 78
    EQUALTO         shift and go to state 79
    error           shift and go to state 80


state 56

    (19) E -> FOR ID EQUALS . EA TO Ex F NEXT ID
    (42) EA -> . EA PLUS P
    (43) EA -> . EA MINUS P
    (44) EA -> . P
    (45) P -> . P MULTIPLY N
    (46) P -> . P DIVIDE N
    (47) P -> . N
    (48) N -> . cte saveID
    (49) N -> . ID saveID
    (50) N -> . OPENPAR EA CLOSINGPAR
    (51) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (52) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (54) cte -> . INTVAL
    (55) cte -> . FLOATVAL

    ID              shift and go to state 81
    OPENPAR         shift and go to state 83
    INTVAL          shift and go to state 45
    FLOATVAL        shift and go to state 46

    EA                             shift and go to state 82
    P                              shift and go to state 41
    N                              shift and go to state 43
    cte                            shift and go to state 44

state 57

    (20) E -> WHILE while_first_conditional EL . DO while_second_conditional F WEND while_final_conditional

    DO              shift and go to state 84


state 58

    (22) E -> INPUT ES COMA . IDEx
    (35) IDEx -> . ID
    (36) IDEx -> . ID OPENBRACKET setType Idv CLOSINGBRACKET

    ID              shift and go to state 86

    IDEx                           shift and go to state 85

state 59

    (42) EA -> EA PLUS . P
    (45) P -> . P MULTIPLY N
    (46) P -> . P DIVIDE N
    (47) P -> . N
    (48) N -> . cte saveID
    (49) N -> . ID saveID
    (50) N -> . OPENPAR EA CLOSINGPAR
    (51) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (52) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (54) cte -> . INTVAL
    (55) cte -> . FLOATVAL

    ID              shift and go to state 81
    OPENPAR         shift and go to state 83
    INTVAL          shift and go to state 45
    FLOATVAL        shift and go to state 46

    P                              shift and go to state 87
    N                              shift and go to state 43
    cte                            shift and go to state 44

state 60

    (43) EA -> EA MINUS . P
    (45) P -> . P MULTIPLY N
    (46) P -> . P DIVIDE N
    (47) P -> . N
    (48) N -> . cte saveID
    (49) N -> . ID saveID
    (50) N -> . OPENPAR EA CLOSINGPAR
    (51) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (52) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (54) cte -> . INTVAL
    (55) cte -> . FLOATVAL

    ID              shift and go to state 81
    OPENPAR         shift and go to state 83
    INTVAL          shift and go to state 45
    FLOATVAL        shift and go to state 46

    P                              shift and go to state 88
    N                              shift and go to state 43
    cte                            shift and go to state 44

state 61

    (49) N -> ID saveID .

    MULTIPLY        reduce using rule 49 (N -> ID saveID .)
    DIVIDE          reduce using rule 49 (N -> ID saveID .)
    PLUS            reduce using rule 49 (N -> ID saveID .)
    MINUS           reduce using rule 49 (N -> ID saveID .)
    LET             reduce using rule 49 (N -> ID saveID .)
    DIM             reduce using rule 49 (N -> ID saveID .)
    IF              reduce using rule 49 (N -> ID saveID .)
    FOR             reduce using rule 49 (N -> ID saveID .)
    WHILE           reduce using rule 49 (N -> ID saveID .)
    GOSUB           reduce using rule 49 (N -> ID saveID .)
    INPUT           reduce using rule 49 (N -> ID saveID .)
    PRINT           reduce using rule 49 (N -> ID saveID .)
    SUBPROCEDURE    reduce using rule 49 (N -> ID saveID .)
    END             reduce using rule 49 (N -> ID saveID .)
    RETURN          reduce using rule 49 (N -> ID saveID .)
    ELSE            reduce using rule 49 (N -> ID saveID .)
    EIF             reduce using rule 49 (N -> ID saveID .)
    WEND            reduce using rule 49 (N -> ID saveID .)
    NEXT            reduce using rule 49 (N -> ID saveID .)
    GREATHER        reduce using rule 49 (N -> ID saveID .)
    GREATHEREQUAL   reduce using rule 49 (N -> ID saveID .)
    SMALLER         reduce using rule 49 (N -> ID saveID .)
    SMALLEREQUAL    reduce using rule 49 (N -> ID saveID .)
    NOTEQUAL        reduce using rule 49 (N -> ID saveID .)
    EQUALTO         reduce using rule 49 (N -> ID saveID .)
    error           reduce using rule 49 (N -> ID saveID .)
    CLOSINGPAR      reduce using rule 49 (N -> ID saveID .)
    TO              reduce using rule 49 (N -> ID saveID .)
    CLOSINGBRACKET  reduce using rule 49 (N -> ID saveID .)


state 62

    (51) N -> ID OPENBRACKET . INTVAL CLOSINGBRACKET
    (52) N -> ID OPENBRACKET . setType Idv CLOSINGBRACKET
    (34) setType -> .

    INTVAL          shift and go to state 89
    ID              reduce using rule 34 (setType -> .)

    setType                        shift and go to state 90

state 63

    (45) P -> P MULTIPLY . N
    (48) N -> . cte saveID
    (49) N -> . ID saveID
    (50) N -> . OPENPAR EA CLOSINGPAR
    (51) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (52) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (54) cte -> . INTVAL
    (55) cte -> . FLOATVAL

    ID              shift and go to state 81
    OPENPAR         shift and go to state 83
    INTVAL          shift and go to state 45
    FLOATVAL        shift and go to state 46

    N                              shift and go to state 91
    cte                            shift and go to state 44

state 64

    (46) P -> P DIVIDE . N
    (48) N -> . cte saveID
    (49) N -> . ID saveID
    (50) N -> . OPENPAR EA CLOSINGPAR
    (51) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (52) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (54) cte -> . INTVAL
    (55) cte -> . FLOATVAL

    ID              shift and go to state 81
    OPENPAR         shift and go to state 83
    INTVAL          shift and go to state 45
    FLOATVAL        shift and go to state 46

    N                              shift and go to state 92
    cte                            shift and go to state 44

state 65

    (50) N -> OPENPAR EA . CLOSINGPAR
    (42) EA -> EA . PLUS P
    (43) EA -> EA . MINUS P
    (37) Ex -> EA .

    CLOSINGPAR      shift and go to state 93
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    GREATHER        reduce using rule 37 (Ex -> EA .)
    GREATHEREQUAL   reduce using rule 37 (Ex -> EA .)
    SMALLER         reduce using rule 37 (Ex -> EA .)
    SMALLEREQUAL    reduce using rule 37 (Ex -> EA .)
    NOTEQUAL        reduce using rule 37 (Ex -> EA .)
    EQUALTO         reduce using rule 37 (Ex -> EA .)
    error           reduce using rule 37 (Ex -> EA .)


state 66

    (48) N -> cte saveID .

    MULTIPLY        reduce using rule 48 (N -> cte saveID .)
    DIVIDE          reduce using rule 48 (N -> cte saveID .)
    PLUS            reduce using rule 48 (N -> cte saveID .)
    MINUS           reduce using rule 48 (N -> cte saveID .)
    LET             reduce using rule 48 (N -> cte saveID .)
    DIM             reduce using rule 48 (N -> cte saveID .)
    IF              reduce using rule 48 (N -> cte saveID .)
    FOR             reduce using rule 48 (N -> cte saveID .)
    WHILE           reduce using rule 48 (N -> cte saveID .)
    GOSUB           reduce using rule 48 (N -> cte saveID .)
    INPUT           reduce using rule 48 (N -> cte saveID .)
    PRINT           reduce using rule 48 (N -> cte saveID .)
    SUBPROCEDURE    reduce using rule 48 (N -> cte saveID .)
    END             reduce using rule 48 (N -> cte saveID .)
    RETURN          reduce using rule 48 (N -> cte saveID .)
    ELSE            reduce using rule 48 (N -> cte saveID .)
    EIF             reduce using rule 48 (N -> cte saveID .)
    WEND            reduce using rule 48 (N -> cte saveID .)
    NEXT            reduce using rule 48 (N -> cte saveID .)
    GREATHER        reduce using rule 48 (N -> cte saveID .)
    GREATHEREQUAL   reduce using rule 48 (N -> cte saveID .)
    SMALLER         reduce using rule 48 (N -> cte saveID .)
    SMALLEREQUAL    reduce using rule 48 (N -> cte saveID .)
    NOTEQUAL        reduce using rule 48 (N -> cte saveID .)
    EQUALTO         reduce using rule 48 (N -> cte saveID .)
    error           reduce using rule 48 (N -> cte saveID .)
    CLOSINGPAR      reduce using rule 48 (N -> cte saveID .)
    TO              reduce using rule 48 (N -> cte saveID .)
    CLOSINGBRACKET  reduce using rule 48 (N -> cte saveID .)


state 67

    (2) V -> DIM setType Idv AS . T Arr
    (7) T -> . INT
    (8) T -> . FLOAT
    (9) T -> . WORD

    INT             shift and go to state 95
    FLOAT           shift and go to state 96
    WORD            shift and go to state 97

    T                              shift and go to state 94

state 68

    (32) Idv -> ID COMA . Idv
    (32) Idv -> . ID COMA Idv
    (33) Idv -> . ID

    ID              shift and go to state 48

    Idv                            shift and go to state 98

state 69

    (10) S -> SUBPROCEDURE ID TWOPOINTS . M RETURN S
    (12) M -> . F M
    (13) M -> . empty
    (14) F -> . E F
    (15) F -> . empty
    (70) empty -> .
    (16) E -> . LET setType Idv EQUALS Ex
    (17) E -> . DIM setType Idv AS T Arr
    (18) E -> . IF EL THEN first_conditional F Esf EIF final_conditional
    (19) E -> . FOR ID EQUALS EA TO Ex F NEXT ID
    (20) E -> . WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional
    (21) E -> . GOSUB ID
    (22) E -> . INPUT ES COMA IDEx
    (23) E -> . PRINT Ex

  ! shift/reduce conflict for LET resolved as shift
  ! shift/reduce conflict for DIM resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for GOSUB resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
    RETURN          reduce using rule 70 (empty -> .)
    LET             shift and go to state 10
    DIM             shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    GOSUB           shift and go to state 15
    INPUT           shift and go to state 16
    PRINT           shift and go to state 17

  ! LET             [ reduce using rule 70 (empty -> .) ]
  ! DIM             [ reduce using rule 70 (empty -> .) ]
  ! IF              [ reduce using rule 70 (empty -> .) ]
  ! FOR             [ reduce using rule 70 (empty -> .) ]
  ! WHILE           [ reduce using rule 70 (empty -> .) ]
  ! GOSUB           [ reduce using rule 70 (empty -> .) ]
  ! INPUT           [ reduce using rule 70 (empty -> .) ]
  ! PRINT           [ reduce using rule 70 (empty -> .) ]

    M                              shift and go to state 99
    F                              shift and go to state 7
    empty                          shift and go to state 8
    E                              shift and go to state 9

state 70

    (16) E -> LET setType Idv EQUALS . Ex
    (37) Ex -> . EA
    (38) Ex -> . ES
    (39) Ex -> . EL
    (40) Ex -> . ID
    (42) EA -> . EA PLUS P
    (43) EA -> . EA MINUS P
    (44) EA -> . P
    (41) ES -> . WORDVAL
    (56) EL -> . TRUE
    (57) EL -> . FALSE
    (58) EL -> . OPENPAR O CLOSINGPAR
    (59) EL -> . OPENPAR O CLOSINGPAR OL EL
    (45) P -> . P MULTIPLY N
    (46) P -> . P DIVIDE N
    (47) P -> . N
    (48) N -> . cte saveID
    (49) N -> . ID saveID
    (50) N -> . OPENPAR EA CLOSINGPAR
    (51) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (52) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (54) cte -> . INTVAL
    (55) cte -> . FLOATVAL

    ID              shift and go to state 40
    WORDVAL         shift and go to state 35
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    OPENPAR         shift and go to state 42
    INTVAL          shift and go to state 45
    FLOATVAL        shift and go to state 46

    Ex                             shift and go to state 100
    EA                             shift and go to state 37
    ES                             shift and go to state 38
    EL                             shift and go to state 39
    P                              shift and go to state 41
    N                              shift and go to state 43
    cte                            shift and go to state 44

state 71

    (17) E -> DIM setType Idv AS . T Arr
    (7) T -> . INT
    (8) T -> . FLOAT
    (9) T -> . WORD

    INT             shift and go to state 95
    FLOAT           shift and go to state 96
    WORD            shift and go to state 97

    T                              shift and go to state 101

state 72

    (18) E -> IF EL THEN first_conditional . F Esf EIF final_conditional
    (14) F -> . E F
    (15) F -> . empty
    (16) E -> . LET setType Idv EQUALS Ex
    (17) E -> . DIM setType Idv AS T Arr
    (18) E -> . IF EL THEN first_conditional F Esf EIF final_conditional
    (19) E -> . FOR ID EQUALS EA TO Ex F NEXT ID
    (20) E -> . WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional
    (21) E -> . GOSUB ID
    (22) E -> . INPUT ES COMA IDEx
    (23) E -> . PRINT Ex
    (70) empty -> .

    LET             shift and go to state 10
    DIM             shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    GOSUB           shift and go to state 15
    INPUT           shift and go to state 16
    PRINT           shift and go to state 17
    ELSE            reduce using rule 70 (empty -> .)
    EIF             reduce using rule 70 (empty -> .)

    F                              shift and go to state 102
    E                              shift and go to state 9
    empty                          shift and go to state 24

state 73

    (58) EL -> OPENPAR O CLOSINGPAR .
    (59) EL -> OPENPAR O CLOSINGPAR . OL EL
    (60) OL -> . AND
    (61) OL -> . OR
    (62) OL -> . NOT

    THEN            reduce using rule 58 (EL -> OPENPAR O CLOSINGPAR .)
    LET             reduce using rule 58 (EL -> OPENPAR O CLOSINGPAR .)
    DIM             reduce using rule 58 (EL -> OPENPAR O CLOSINGPAR .)
    IF              reduce using rule 58 (EL -> OPENPAR O CLOSINGPAR .)
    FOR             reduce using rule 58 (EL -> OPENPAR O CLOSINGPAR .)
    WHILE           reduce using rule 58 (EL -> OPENPAR O CLOSINGPAR .)
    GOSUB           reduce using rule 58 (EL -> OPENPAR O CLOSINGPAR .)
    INPUT           reduce using rule 58 (EL -> OPENPAR O CLOSINGPAR .)
    PRINT           reduce using rule 58 (EL -> OPENPAR O CLOSINGPAR .)
    SUBPROCEDURE    reduce using rule 58 (EL -> OPENPAR O CLOSINGPAR .)
    END             reduce using rule 58 (EL -> OPENPAR O CLOSINGPAR .)
    RETURN          reduce using rule 58 (EL -> OPENPAR O CLOSINGPAR .)
    ELSE            reduce using rule 58 (EL -> OPENPAR O CLOSINGPAR .)
    EIF             reduce using rule 58 (EL -> OPENPAR O CLOSINGPAR .)
    WEND            reduce using rule 58 (EL -> OPENPAR O CLOSINGPAR .)
    NEXT            reduce using rule 58 (EL -> OPENPAR O CLOSINGPAR .)
    GREATHER        reduce using rule 58 (EL -> OPENPAR O CLOSINGPAR .)
    GREATHEREQUAL   reduce using rule 58 (EL -> OPENPAR O CLOSINGPAR .)
    SMALLER         reduce using rule 58 (EL -> OPENPAR O CLOSINGPAR .)
    SMALLEREQUAL    reduce using rule 58 (EL -> OPENPAR O CLOSINGPAR .)
    NOTEQUAL        reduce using rule 58 (EL -> OPENPAR O CLOSINGPAR .)
    EQUALTO         reduce using rule 58 (EL -> OPENPAR O CLOSINGPAR .)
    error           reduce using rule 58 (EL -> OPENPAR O CLOSINGPAR .)
    DO              reduce using rule 58 (EL -> OPENPAR O CLOSINGPAR .)
    CLOSINGPAR      reduce using rule 58 (EL -> OPENPAR O CLOSINGPAR .)
    AND             shift and go to state 104
    OR              shift and go to state 105
    NOT             shift and go to state 106

    OL                             shift and go to state 103

state 74

    (63) O -> Ex GREATHER . Ex
    (37) Ex -> . EA
    (38) Ex -> . ES
    (39) Ex -> . EL
    (40) Ex -> . ID
    (42) EA -> . EA PLUS P
    (43) EA -> . EA MINUS P
    (44) EA -> . P
    (41) ES -> . WORDVAL
    (56) EL -> . TRUE
    (57) EL -> . FALSE
    (58) EL -> . OPENPAR O CLOSINGPAR
    (59) EL -> . OPENPAR O CLOSINGPAR OL EL
    (45) P -> . P MULTIPLY N
    (46) P -> . P DIVIDE N
    (47) P -> . N
    (48) N -> . cte saveID
    (49) N -> . ID saveID
    (50) N -> . OPENPAR EA CLOSINGPAR
    (51) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (52) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (54) cte -> . INTVAL
    (55) cte -> . FLOATVAL

    ID              shift and go to state 40
    WORDVAL         shift and go to state 35
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    OPENPAR         shift and go to state 42
    INTVAL          shift and go to state 45
    FLOATVAL        shift and go to state 46

    Ex                             shift and go to state 107
    EA                             shift and go to state 37
    ES                             shift and go to state 38
    EL                             shift and go to state 39
    P                              shift and go to state 41
    N                              shift and go to state 43
    cte                            shift and go to state 44

state 75

    (64) O -> Ex GREATHEREQUAL . Ex
    (37) Ex -> . EA
    (38) Ex -> . ES
    (39) Ex -> . EL
    (40) Ex -> . ID
    (42) EA -> . EA PLUS P
    (43) EA -> . EA MINUS P
    (44) EA -> . P
    (41) ES -> . WORDVAL
    (56) EL -> . TRUE
    (57) EL -> . FALSE
    (58) EL -> . OPENPAR O CLOSINGPAR
    (59) EL -> . OPENPAR O CLOSINGPAR OL EL
    (45) P -> . P MULTIPLY N
    (46) P -> . P DIVIDE N
    (47) P -> . N
    (48) N -> . cte saveID
    (49) N -> . ID saveID
    (50) N -> . OPENPAR EA CLOSINGPAR
    (51) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (52) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (54) cte -> . INTVAL
    (55) cte -> . FLOATVAL

    ID              shift and go to state 40
    WORDVAL         shift and go to state 35
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    OPENPAR         shift and go to state 42
    INTVAL          shift and go to state 45
    FLOATVAL        shift and go to state 46

    Ex                             shift and go to state 108
    EA                             shift and go to state 37
    ES                             shift and go to state 38
    EL                             shift and go to state 39
    P                              shift and go to state 41
    N                              shift and go to state 43
    cte                            shift and go to state 44

state 76

    (65) O -> Ex SMALLER . Ex
    (37) Ex -> . EA
    (38) Ex -> . ES
    (39) Ex -> . EL
    (40) Ex -> . ID
    (42) EA -> . EA PLUS P
    (43) EA -> . EA MINUS P
    (44) EA -> . P
    (41) ES -> . WORDVAL
    (56) EL -> . TRUE
    (57) EL -> . FALSE
    (58) EL -> . OPENPAR O CLOSINGPAR
    (59) EL -> . OPENPAR O CLOSINGPAR OL EL
    (45) P -> . P MULTIPLY N
    (46) P -> . P DIVIDE N
    (47) P -> . N
    (48) N -> . cte saveID
    (49) N -> . ID saveID
    (50) N -> . OPENPAR EA CLOSINGPAR
    (51) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (52) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (54) cte -> . INTVAL
    (55) cte -> . FLOATVAL

    ID              shift and go to state 40
    WORDVAL         shift and go to state 35
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    OPENPAR         shift and go to state 42
    INTVAL          shift and go to state 45
    FLOATVAL        shift and go to state 46

    Ex                             shift and go to state 109
    EA                             shift and go to state 37
    ES                             shift and go to state 38
    EL                             shift and go to state 39
    P                              shift and go to state 41
    N                              shift and go to state 43
    cte                            shift and go to state 44

state 77

    (66) O -> Ex SMALLEREQUAL . Ex
    (37) Ex -> . EA
    (38) Ex -> . ES
    (39) Ex -> . EL
    (40) Ex -> . ID
    (42) EA -> . EA PLUS P
    (43) EA -> . EA MINUS P
    (44) EA -> . P
    (41) ES -> . WORDVAL
    (56) EL -> . TRUE
    (57) EL -> . FALSE
    (58) EL -> . OPENPAR O CLOSINGPAR
    (59) EL -> . OPENPAR O CLOSINGPAR OL EL
    (45) P -> . P MULTIPLY N
    (46) P -> . P DIVIDE N
    (47) P -> . N
    (48) N -> . cte saveID
    (49) N -> . ID saveID
    (50) N -> . OPENPAR EA CLOSINGPAR
    (51) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (52) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (54) cte -> . INTVAL
    (55) cte -> . FLOATVAL

    ID              shift and go to state 40
    WORDVAL         shift and go to state 35
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    OPENPAR         shift and go to state 42
    INTVAL          shift and go to state 45
    FLOATVAL        shift and go to state 46

    Ex                             shift and go to state 110
    EA                             shift and go to state 37
    ES                             shift and go to state 38
    EL                             shift and go to state 39
    P                              shift and go to state 41
    N                              shift and go to state 43
    cte                            shift and go to state 44

state 78

    (67) O -> Ex NOTEQUAL . Ex
    (37) Ex -> . EA
    (38) Ex -> . ES
    (39) Ex -> . EL
    (40) Ex -> . ID
    (42) EA -> . EA PLUS P
    (43) EA -> . EA MINUS P
    (44) EA -> . P
    (41) ES -> . WORDVAL
    (56) EL -> . TRUE
    (57) EL -> . FALSE
    (58) EL -> . OPENPAR O CLOSINGPAR
    (59) EL -> . OPENPAR O CLOSINGPAR OL EL
    (45) P -> . P MULTIPLY N
    (46) P -> . P DIVIDE N
    (47) P -> . N
    (48) N -> . cte saveID
    (49) N -> . ID saveID
    (50) N -> . OPENPAR EA CLOSINGPAR
    (51) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (52) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (54) cte -> . INTVAL
    (55) cte -> . FLOATVAL

    ID              shift and go to state 40
    WORDVAL         shift and go to state 35
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    OPENPAR         shift and go to state 42
    INTVAL          shift and go to state 45
    FLOATVAL        shift and go to state 46

    Ex                             shift and go to state 111
    EA                             shift and go to state 37
    ES                             shift and go to state 38
    EL                             shift and go to state 39
    P                              shift and go to state 41
    N                              shift and go to state 43
    cte                            shift and go to state 44

state 79

    (68) O -> Ex EQUALTO . Ex
    (37) Ex -> . EA
    (38) Ex -> . ES
    (39) Ex -> . EL
    (40) Ex -> . ID
    (42) EA -> . EA PLUS P
    (43) EA -> . EA MINUS P
    (44) EA -> . P
    (41) ES -> . WORDVAL
    (56) EL -> . TRUE
    (57) EL -> . FALSE
    (58) EL -> . OPENPAR O CLOSINGPAR
    (59) EL -> . OPENPAR O CLOSINGPAR OL EL
    (45) P -> . P MULTIPLY N
    (46) P -> . P DIVIDE N
    (47) P -> . N
    (48) N -> . cte saveID
    (49) N -> . ID saveID
    (50) N -> . OPENPAR EA CLOSINGPAR
    (51) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (52) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (54) cte -> . INTVAL
    (55) cte -> . FLOATVAL

    ID              shift and go to state 40
    WORDVAL         shift and go to state 35
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    OPENPAR         shift and go to state 42
    INTVAL          shift and go to state 45
    FLOATVAL        shift and go to state 46

    Ex                             shift and go to state 112
    EA                             shift and go to state 37
    ES                             shift and go to state 38
    EL                             shift and go to state 39
    P                              shift and go to state 41
    N                              shift and go to state 43
    cte                            shift and go to state 44

state 80

    (69) O -> Ex error . Ex
    (37) Ex -> . EA
    (38) Ex -> . ES
    (39) Ex -> . EL
    (40) Ex -> . ID
    (42) EA -> . EA PLUS P
    (43) EA -> . EA MINUS P
    (44) EA -> . P
    (41) ES -> . WORDVAL
    (56) EL -> . TRUE
    (57) EL -> . FALSE
    (58) EL -> . OPENPAR O CLOSINGPAR
    (59) EL -> . OPENPAR O CLOSINGPAR OL EL
    (45) P -> . P MULTIPLY N
    (46) P -> . P DIVIDE N
    (47) P -> . N
    (48) N -> . cte saveID
    (49) N -> . ID saveID
    (50) N -> . OPENPAR EA CLOSINGPAR
    (51) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (52) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (54) cte -> . INTVAL
    (55) cte -> . FLOATVAL

    ID              shift and go to state 40
    WORDVAL         shift and go to state 35
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    OPENPAR         shift and go to state 42
    INTVAL          shift and go to state 45
    FLOATVAL        shift and go to state 46

    Ex                             shift and go to state 113
    EA                             shift and go to state 37
    ES                             shift and go to state 38
    EL                             shift and go to state 39
    P                              shift and go to state 41
    N                              shift and go to state 43
    cte                            shift and go to state 44

state 81

    (49) N -> ID . saveID
    (51) N -> ID . OPENBRACKET INTVAL CLOSINGBRACKET
    (52) N -> ID . OPENBRACKET setType Idv CLOSINGBRACKET
    (53) saveID -> .

    OPENBRACKET     shift and go to state 62
    MULTIPLY        reduce using rule 53 (saveID -> .)
    DIVIDE          reduce using rule 53 (saveID -> .)
    TO              reduce using rule 53 (saveID -> .)
    PLUS            reduce using rule 53 (saveID -> .)
    MINUS           reduce using rule 53 (saveID -> .)
    LET             reduce using rule 53 (saveID -> .)
    DIM             reduce using rule 53 (saveID -> .)
    IF              reduce using rule 53 (saveID -> .)
    FOR             reduce using rule 53 (saveID -> .)
    WHILE           reduce using rule 53 (saveID -> .)
    GOSUB           reduce using rule 53 (saveID -> .)
    INPUT           reduce using rule 53 (saveID -> .)
    PRINT           reduce using rule 53 (saveID -> .)
    SUBPROCEDURE    reduce using rule 53 (saveID -> .)
    END             reduce using rule 53 (saveID -> .)
    RETURN          reduce using rule 53 (saveID -> .)
    ELSE            reduce using rule 53 (saveID -> .)
    EIF             reduce using rule 53 (saveID -> .)
    WEND            reduce using rule 53 (saveID -> .)
    NEXT            reduce using rule 53 (saveID -> .)
    GREATHER        reduce using rule 53 (saveID -> .)
    GREATHEREQUAL   reduce using rule 53 (saveID -> .)
    SMALLER         reduce using rule 53 (saveID -> .)
    SMALLEREQUAL    reduce using rule 53 (saveID -> .)
    NOTEQUAL        reduce using rule 53 (saveID -> .)
    EQUALTO         reduce using rule 53 (saveID -> .)
    error           reduce using rule 53 (saveID -> .)
    CLOSINGPAR      reduce using rule 53 (saveID -> .)
    CLOSINGBRACKET  reduce using rule 53 (saveID -> .)

    saveID                         shift and go to state 61

state 82

    (19) E -> FOR ID EQUALS EA . TO Ex F NEXT ID
    (42) EA -> EA . PLUS P
    (43) EA -> EA . MINUS P

    TO              shift and go to state 114
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60


state 83

    (50) N -> OPENPAR . EA CLOSINGPAR
    (42) EA -> . EA PLUS P
    (43) EA -> . EA MINUS P
    (44) EA -> . P
    (45) P -> . P MULTIPLY N
    (46) P -> . P DIVIDE N
    (47) P -> . N
    (48) N -> . cte saveID
    (49) N -> . ID saveID
    (50) N -> . OPENPAR EA CLOSINGPAR
    (51) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (52) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (54) cte -> . INTVAL
    (55) cte -> . FLOATVAL

    ID              shift and go to state 81
    OPENPAR         shift and go to state 83
    INTVAL          shift and go to state 45
    FLOATVAL        shift and go to state 46

    EA                             shift and go to state 115
    P                              shift and go to state 41
    N                              shift and go to state 43
    cte                            shift and go to state 44

state 84

    (20) E -> WHILE while_first_conditional EL DO . while_second_conditional F WEND while_final_conditional
    (25) while_second_conditional -> .

    LET             reduce using rule 25 (while_second_conditional -> .)
    DIM             reduce using rule 25 (while_second_conditional -> .)
    IF              reduce using rule 25 (while_second_conditional -> .)
    FOR             reduce using rule 25 (while_second_conditional -> .)
    WHILE           reduce using rule 25 (while_second_conditional -> .)
    GOSUB           reduce using rule 25 (while_second_conditional -> .)
    INPUT           reduce using rule 25 (while_second_conditional -> .)
    PRINT           reduce using rule 25 (while_second_conditional -> .)
    WEND            reduce using rule 25 (while_second_conditional -> .)

    while_second_conditional       shift and go to state 116

state 85

    (22) E -> INPUT ES COMA IDEx .

    LET             reduce using rule 22 (E -> INPUT ES COMA IDEx .)
    DIM             reduce using rule 22 (E -> INPUT ES COMA IDEx .)
    IF              reduce using rule 22 (E -> INPUT ES COMA IDEx .)
    FOR             reduce using rule 22 (E -> INPUT ES COMA IDEx .)
    WHILE           reduce using rule 22 (E -> INPUT ES COMA IDEx .)
    GOSUB           reduce using rule 22 (E -> INPUT ES COMA IDEx .)
    INPUT           reduce using rule 22 (E -> INPUT ES COMA IDEx .)
    PRINT           reduce using rule 22 (E -> INPUT ES COMA IDEx .)
    SUBPROCEDURE    reduce using rule 22 (E -> INPUT ES COMA IDEx .)
    END             reduce using rule 22 (E -> INPUT ES COMA IDEx .)
    RETURN          reduce using rule 22 (E -> INPUT ES COMA IDEx .)
    ELSE            reduce using rule 22 (E -> INPUT ES COMA IDEx .)
    EIF             reduce using rule 22 (E -> INPUT ES COMA IDEx .)
    WEND            reduce using rule 22 (E -> INPUT ES COMA IDEx .)
    NEXT            reduce using rule 22 (E -> INPUT ES COMA IDEx .)


state 86

    (35) IDEx -> ID .
    (36) IDEx -> ID . OPENBRACKET setType Idv CLOSINGBRACKET

    LET             reduce using rule 35 (IDEx -> ID .)
    DIM             reduce using rule 35 (IDEx -> ID .)
    IF              reduce using rule 35 (IDEx -> ID .)
    FOR             reduce using rule 35 (IDEx -> ID .)
    WHILE           reduce using rule 35 (IDEx -> ID .)
    GOSUB           reduce using rule 35 (IDEx -> ID .)
    INPUT           reduce using rule 35 (IDEx -> ID .)
    PRINT           reduce using rule 35 (IDEx -> ID .)
    SUBPROCEDURE    reduce using rule 35 (IDEx -> ID .)
    END             reduce using rule 35 (IDEx -> ID .)
    RETURN          reduce using rule 35 (IDEx -> ID .)
    ELSE            reduce using rule 35 (IDEx -> ID .)
    EIF             reduce using rule 35 (IDEx -> ID .)
    WEND            reduce using rule 35 (IDEx -> ID .)
    NEXT            reduce using rule 35 (IDEx -> ID .)
    OPENBRACKET     shift and go to state 117


state 87

    (42) EA -> EA PLUS P .
    (45) P -> P . MULTIPLY N
    (46) P -> P . DIVIDE N

    PLUS            reduce using rule 42 (EA -> EA PLUS P .)
    MINUS           reduce using rule 42 (EA -> EA PLUS P .)
    LET             reduce using rule 42 (EA -> EA PLUS P .)
    DIM             reduce using rule 42 (EA -> EA PLUS P .)
    IF              reduce using rule 42 (EA -> EA PLUS P .)
    FOR             reduce using rule 42 (EA -> EA PLUS P .)
    WHILE           reduce using rule 42 (EA -> EA PLUS P .)
    GOSUB           reduce using rule 42 (EA -> EA PLUS P .)
    INPUT           reduce using rule 42 (EA -> EA PLUS P .)
    PRINT           reduce using rule 42 (EA -> EA PLUS P .)
    SUBPROCEDURE    reduce using rule 42 (EA -> EA PLUS P .)
    END             reduce using rule 42 (EA -> EA PLUS P .)
    RETURN          reduce using rule 42 (EA -> EA PLUS P .)
    ELSE            reduce using rule 42 (EA -> EA PLUS P .)
    EIF             reduce using rule 42 (EA -> EA PLUS P .)
    WEND            reduce using rule 42 (EA -> EA PLUS P .)
    NEXT            reduce using rule 42 (EA -> EA PLUS P .)
    GREATHER        reduce using rule 42 (EA -> EA PLUS P .)
    GREATHEREQUAL   reduce using rule 42 (EA -> EA PLUS P .)
    SMALLER         reduce using rule 42 (EA -> EA PLUS P .)
    SMALLEREQUAL    reduce using rule 42 (EA -> EA PLUS P .)
    NOTEQUAL        reduce using rule 42 (EA -> EA PLUS P .)
    EQUALTO         reduce using rule 42 (EA -> EA PLUS P .)
    error           reduce using rule 42 (EA -> EA PLUS P .)
    CLOSINGPAR      reduce using rule 42 (EA -> EA PLUS P .)
    TO              reduce using rule 42 (EA -> EA PLUS P .)
    CLOSINGBRACKET  reduce using rule 42 (EA -> EA PLUS P .)
    MULTIPLY        shift and go to state 63
    DIVIDE          shift and go to state 64


state 88

    (43) EA -> EA MINUS P .
    (45) P -> P . MULTIPLY N
    (46) P -> P . DIVIDE N

    PLUS            reduce using rule 43 (EA -> EA MINUS P .)
    MINUS           reduce using rule 43 (EA -> EA MINUS P .)
    LET             reduce using rule 43 (EA -> EA MINUS P .)
    DIM             reduce using rule 43 (EA -> EA MINUS P .)
    IF              reduce using rule 43 (EA -> EA MINUS P .)
    FOR             reduce using rule 43 (EA -> EA MINUS P .)
    WHILE           reduce using rule 43 (EA -> EA MINUS P .)
    GOSUB           reduce using rule 43 (EA -> EA MINUS P .)
    INPUT           reduce using rule 43 (EA -> EA MINUS P .)
    PRINT           reduce using rule 43 (EA -> EA MINUS P .)
    SUBPROCEDURE    reduce using rule 43 (EA -> EA MINUS P .)
    END             reduce using rule 43 (EA -> EA MINUS P .)
    RETURN          reduce using rule 43 (EA -> EA MINUS P .)
    ELSE            reduce using rule 43 (EA -> EA MINUS P .)
    EIF             reduce using rule 43 (EA -> EA MINUS P .)
    WEND            reduce using rule 43 (EA -> EA MINUS P .)
    NEXT            reduce using rule 43 (EA -> EA MINUS P .)
    GREATHER        reduce using rule 43 (EA -> EA MINUS P .)
    GREATHEREQUAL   reduce using rule 43 (EA -> EA MINUS P .)
    SMALLER         reduce using rule 43 (EA -> EA MINUS P .)
    SMALLEREQUAL    reduce using rule 43 (EA -> EA MINUS P .)
    NOTEQUAL        reduce using rule 43 (EA -> EA MINUS P .)
    EQUALTO         reduce using rule 43 (EA -> EA MINUS P .)
    error           reduce using rule 43 (EA -> EA MINUS P .)
    CLOSINGPAR      reduce using rule 43 (EA -> EA MINUS P .)
    TO              reduce using rule 43 (EA -> EA MINUS P .)
    CLOSINGBRACKET  reduce using rule 43 (EA -> EA MINUS P .)
    MULTIPLY        shift and go to state 63
    DIVIDE          shift and go to state 64


state 89

    (51) N -> ID OPENBRACKET INTVAL . CLOSINGBRACKET

    CLOSINGBRACKET  shift and go to state 118


state 90

    (52) N -> ID OPENBRACKET setType . Idv CLOSINGBRACKET
    (32) Idv -> . ID COMA Idv
    (33) Idv -> . ID

    ID              shift and go to state 48

    Idv                            shift and go to state 119

state 91

    (45) P -> P MULTIPLY N .

    MULTIPLY        reduce using rule 45 (P -> P MULTIPLY N .)
    DIVIDE          reduce using rule 45 (P -> P MULTIPLY N .)
    PLUS            reduce using rule 45 (P -> P MULTIPLY N .)
    MINUS           reduce using rule 45 (P -> P MULTIPLY N .)
    LET             reduce using rule 45 (P -> P MULTIPLY N .)
    DIM             reduce using rule 45 (P -> P MULTIPLY N .)
    IF              reduce using rule 45 (P -> P MULTIPLY N .)
    FOR             reduce using rule 45 (P -> P MULTIPLY N .)
    WHILE           reduce using rule 45 (P -> P MULTIPLY N .)
    GOSUB           reduce using rule 45 (P -> P MULTIPLY N .)
    INPUT           reduce using rule 45 (P -> P MULTIPLY N .)
    PRINT           reduce using rule 45 (P -> P MULTIPLY N .)
    SUBPROCEDURE    reduce using rule 45 (P -> P MULTIPLY N .)
    END             reduce using rule 45 (P -> P MULTIPLY N .)
    RETURN          reduce using rule 45 (P -> P MULTIPLY N .)
    ELSE            reduce using rule 45 (P -> P MULTIPLY N .)
    EIF             reduce using rule 45 (P -> P MULTIPLY N .)
    WEND            reduce using rule 45 (P -> P MULTIPLY N .)
    NEXT            reduce using rule 45 (P -> P MULTIPLY N .)
    GREATHER        reduce using rule 45 (P -> P MULTIPLY N .)
    GREATHEREQUAL   reduce using rule 45 (P -> P MULTIPLY N .)
    SMALLER         reduce using rule 45 (P -> P MULTIPLY N .)
    SMALLEREQUAL    reduce using rule 45 (P -> P MULTIPLY N .)
    NOTEQUAL        reduce using rule 45 (P -> P MULTIPLY N .)
    EQUALTO         reduce using rule 45 (P -> P MULTIPLY N .)
    error           reduce using rule 45 (P -> P MULTIPLY N .)
    CLOSINGPAR      reduce using rule 45 (P -> P MULTIPLY N .)
    TO              reduce using rule 45 (P -> P MULTIPLY N .)
    CLOSINGBRACKET  reduce using rule 45 (P -> P MULTIPLY N .)


state 92

    (46) P -> P DIVIDE N .

    MULTIPLY        reduce using rule 46 (P -> P DIVIDE N .)
    DIVIDE          reduce using rule 46 (P -> P DIVIDE N .)
    PLUS            reduce using rule 46 (P -> P DIVIDE N .)
    MINUS           reduce using rule 46 (P -> P DIVIDE N .)
    LET             reduce using rule 46 (P -> P DIVIDE N .)
    DIM             reduce using rule 46 (P -> P DIVIDE N .)
    IF              reduce using rule 46 (P -> P DIVIDE N .)
    FOR             reduce using rule 46 (P -> P DIVIDE N .)
    WHILE           reduce using rule 46 (P -> P DIVIDE N .)
    GOSUB           reduce using rule 46 (P -> P DIVIDE N .)
    INPUT           reduce using rule 46 (P -> P DIVIDE N .)
    PRINT           reduce using rule 46 (P -> P DIVIDE N .)
    SUBPROCEDURE    reduce using rule 46 (P -> P DIVIDE N .)
    END             reduce using rule 46 (P -> P DIVIDE N .)
    RETURN          reduce using rule 46 (P -> P DIVIDE N .)
    ELSE            reduce using rule 46 (P -> P DIVIDE N .)
    EIF             reduce using rule 46 (P -> P DIVIDE N .)
    WEND            reduce using rule 46 (P -> P DIVIDE N .)
    NEXT            reduce using rule 46 (P -> P DIVIDE N .)
    GREATHER        reduce using rule 46 (P -> P DIVIDE N .)
    GREATHEREQUAL   reduce using rule 46 (P -> P DIVIDE N .)
    SMALLER         reduce using rule 46 (P -> P DIVIDE N .)
    SMALLEREQUAL    reduce using rule 46 (P -> P DIVIDE N .)
    NOTEQUAL        reduce using rule 46 (P -> P DIVIDE N .)
    EQUALTO         reduce using rule 46 (P -> P DIVIDE N .)
    error           reduce using rule 46 (P -> P DIVIDE N .)
    CLOSINGPAR      reduce using rule 46 (P -> P DIVIDE N .)
    TO              reduce using rule 46 (P -> P DIVIDE N .)
    CLOSINGBRACKET  reduce using rule 46 (P -> P DIVIDE N .)


state 93

    (50) N -> OPENPAR EA CLOSINGPAR .

    MULTIPLY        reduce using rule 50 (N -> OPENPAR EA CLOSINGPAR .)
    DIVIDE          reduce using rule 50 (N -> OPENPAR EA CLOSINGPAR .)
    PLUS            reduce using rule 50 (N -> OPENPAR EA CLOSINGPAR .)
    MINUS           reduce using rule 50 (N -> OPENPAR EA CLOSINGPAR .)
    LET             reduce using rule 50 (N -> OPENPAR EA CLOSINGPAR .)
    DIM             reduce using rule 50 (N -> OPENPAR EA CLOSINGPAR .)
    IF              reduce using rule 50 (N -> OPENPAR EA CLOSINGPAR .)
    FOR             reduce using rule 50 (N -> OPENPAR EA CLOSINGPAR .)
    WHILE           reduce using rule 50 (N -> OPENPAR EA CLOSINGPAR .)
    GOSUB           reduce using rule 50 (N -> OPENPAR EA CLOSINGPAR .)
    INPUT           reduce using rule 50 (N -> OPENPAR EA CLOSINGPAR .)
    PRINT           reduce using rule 50 (N -> OPENPAR EA CLOSINGPAR .)
    SUBPROCEDURE    reduce using rule 50 (N -> OPENPAR EA CLOSINGPAR .)
    END             reduce using rule 50 (N -> OPENPAR EA CLOSINGPAR .)
    RETURN          reduce using rule 50 (N -> OPENPAR EA CLOSINGPAR .)
    ELSE            reduce using rule 50 (N -> OPENPAR EA CLOSINGPAR .)
    EIF             reduce using rule 50 (N -> OPENPAR EA CLOSINGPAR .)
    WEND            reduce using rule 50 (N -> OPENPAR EA CLOSINGPAR .)
    NEXT            reduce using rule 50 (N -> OPENPAR EA CLOSINGPAR .)
    GREATHER        reduce using rule 50 (N -> OPENPAR EA CLOSINGPAR .)
    GREATHEREQUAL   reduce using rule 50 (N -> OPENPAR EA CLOSINGPAR .)
    SMALLER         reduce using rule 50 (N -> OPENPAR EA CLOSINGPAR .)
    SMALLEREQUAL    reduce using rule 50 (N -> OPENPAR EA CLOSINGPAR .)
    NOTEQUAL        reduce using rule 50 (N -> OPENPAR EA CLOSINGPAR .)
    EQUALTO         reduce using rule 50 (N -> OPENPAR EA CLOSINGPAR .)
    error           reduce using rule 50 (N -> OPENPAR EA CLOSINGPAR .)
    CLOSINGPAR      reduce using rule 50 (N -> OPENPAR EA CLOSINGPAR .)
    TO              reduce using rule 50 (N -> OPENPAR EA CLOSINGPAR .)
    CLOSINGBRACKET  reduce using rule 50 (N -> OPENPAR EA CLOSINGPAR .)


state 94

    (2) V -> DIM setType Idv AS T . Arr
    (4) Arr -> . OPENBRACKET EA CLOSINGBRACKET Arr
    (5) Arr -> . OPENBRACKET ID CLOSINGBRACKET Arr
    (6) Arr -> . empty
    (70) empty -> .

    OPENBRACKET     shift and go to state 121
    LET             reduce using rule 70 (empty -> .)
    DIM             reduce using rule 70 (empty -> .)
    IF              reduce using rule 70 (empty -> .)
    FOR             reduce using rule 70 (empty -> .)
    WHILE           reduce using rule 70 (empty -> .)
    GOSUB           reduce using rule 70 (empty -> .)
    INPUT           reduce using rule 70 (empty -> .)
    PRINT           reduce using rule 70 (empty -> .)
    SUBPROCEDURE    reduce using rule 70 (empty -> .)
    END             reduce using rule 70 (empty -> .)

    Arr                            shift and go to state 120
    empty                          shift and go to state 122

state 95

    (7) T -> INT .

    OPENBRACKET     reduce using rule 7 (T -> INT .)
    LET             reduce using rule 7 (T -> INT .)
    DIM             reduce using rule 7 (T -> INT .)
    IF              reduce using rule 7 (T -> INT .)
    FOR             reduce using rule 7 (T -> INT .)
    WHILE           reduce using rule 7 (T -> INT .)
    GOSUB           reduce using rule 7 (T -> INT .)
    INPUT           reduce using rule 7 (T -> INT .)
    PRINT           reduce using rule 7 (T -> INT .)
    SUBPROCEDURE    reduce using rule 7 (T -> INT .)
    END             reduce using rule 7 (T -> INT .)
    RETURN          reduce using rule 7 (T -> INT .)
    ELSE            reduce using rule 7 (T -> INT .)
    EIF             reduce using rule 7 (T -> INT .)
    WEND            reduce using rule 7 (T -> INT .)
    NEXT            reduce using rule 7 (T -> INT .)


state 96

    (8) T -> FLOAT .

    OPENBRACKET     reduce using rule 8 (T -> FLOAT .)
    LET             reduce using rule 8 (T -> FLOAT .)
    DIM             reduce using rule 8 (T -> FLOAT .)
    IF              reduce using rule 8 (T -> FLOAT .)
    FOR             reduce using rule 8 (T -> FLOAT .)
    WHILE           reduce using rule 8 (T -> FLOAT .)
    GOSUB           reduce using rule 8 (T -> FLOAT .)
    INPUT           reduce using rule 8 (T -> FLOAT .)
    PRINT           reduce using rule 8 (T -> FLOAT .)
    SUBPROCEDURE    reduce using rule 8 (T -> FLOAT .)
    END             reduce using rule 8 (T -> FLOAT .)
    RETURN          reduce using rule 8 (T -> FLOAT .)
    ELSE            reduce using rule 8 (T -> FLOAT .)
    EIF             reduce using rule 8 (T -> FLOAT .)
    WEND            reduce using rule 8 (T -> FLOAT .)
    NEXT            reduce using rule 8 (T -> FLOAT .)


state 97

    (9) T -> WORD .

    OPENBRACKET     reduce using rule 9 (T -> WORD .)
    LET             reduce using rule 9 (T -> WORD .)
    DIM             reduce using rule 9 (T -> WORD .)
    IF              reduce using rule 9 (T -> WORD .)
    FOR             reduce using rule 9 (T -> WORD .)
    WHILE           reduce using rule 9 (T -> WORD .)
    GOSUB           reduce using rule 9 (T -> WORD .)
    INPUT           reduce using rule 9 (T -> WORD .)
    PRINT           reduce using rule 9 (T -> WORD .)
    SUBPROCEDURE    reduce using rule 9 (T -> WORD .)
    END             reduce using rule 9 (T -> WORD .)
    RETURN          reduce using rule 9 (T -> WORD .)
    ELSE            reduce using rule 9 (T -> WORD .)
    EIF             reduce using rule 9 (T -> WORD .)
    WEND            reduce using rule 9 (T -> WORD .)
    NEXT            reduce using rule 9 (T -> WORD .)


state 98

    (32) Idv -> ID COMA Idv .

    AS              reduce using rule 32 (Idv -> ID COMA Idv .)
    EQUALS          reduce using rule 32 (Idv -> ID COMA Idv .)
    CLOSINGBRACKET  reduce using rule 32 (Idv -> ID COMA Idv .)


state 99

    (10) S -> SUBPROCEDURE ID TWOPOINTS M . RETURN S

    RETURN          shift and go to state 123


state 100

    (16) E -> LET setType Idv EQUALS Ex .

    LET             reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    DIM             reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    IF              reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    FOR             reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    WHILE           reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    GOSUB           reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    INPUT           reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    PRINT           reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    SUBPROCEDURE    reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    END             reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    RETURN          reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    ELSE            reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    EIF             reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    WEND            reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)
    NEXT            reduce using rule 16 (E -> LET setType Idv EQUALS Ex .)


state 101

    (17) E -> DIM setType Idv AS T . Arr
    (4) Arr -> . OPENBRACKET EA CLOSINGBRACKET Arr
    (5) Arr -> . OPENBRACKET ID CLOSINGBRACKET Arr
    (6) Arr -> . empty
    (70) empty -> .

    OPENBRACKET     shift and go to state 121
    LET             reduce using rule 70 (empty -> .)
    DIM             reduce using rule 70 (empty -> .)
    IF              reduce using rule 70 (empty -> .)
    FOR             reduce using rule 70 (empty -> .)
    WHILE           reduce using rule 70 (empty -> .)
    GOSUB           reduce using rule 70 (empty -> .)
    INPUT           reduce using rule 70 (empty -> .)
    PRINT           reduce using rule 70 (empty -> .)
    SUBPROCEDURE    reduce using rule 70 (empty -> .)
    END             reduce using rule 70 (empty -> .)
    RETURN          reduce using rule 70 (empty -> .)
    ELSE            reduce using rule 70 (empty -> .)
    EIF             reduce using rule 70 (empty -> .)
    WEND            reduce using rule 70 (empty -> .)
    NEXT            reduce using rule 70 (empty -> .)

    Arr                            shift and go to state 124
    empty                          shift and go to state 122

state 102

    (18) E -> IF EL THEN first_conditional F . Esf EIF final_conditional
    (30) Esf -> . ELSE second_conditional F
    (31) Esf -> . empty
    (70) empty -> .

    ELSE            shift and go to state 126
    EIF             reduce using rule 70 (empty -> .)

    Esf                            shift and go to state 125
    empty                          shift and go to state 127

state 103

    (59) EL -> OPENPAR O CLOSINGPAR OL . EL
    (56) EL -> . TRUE
    (57) EL -> . FALSE
    (58) EL -> . OPENPAR O CLOSINGPAR
    (59) EL -> . OPENPAR O CLOSINGPAR OL EL

    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    OPENPAR         shift and go to state 30

    EL                             shift and go to state 128

state 104

    (60) OL -> AND .

    TRUE            reduce using rule 60 (OL -> AND .)
    FALSE           reduce using rule 60 (OL -> AND .)
    OPENPAR         reduce using rule 60 (OL -> AND .)


state 105

    (61) OL -> OR .

    TRUE            reduce using rule 61 (OL -> OR .)
    FALSE           reduce using rule 61 (OL -> OR .)
    OPENPAR         reduce using rule 61 (OL -> OR .)


state 106

    (62) OL -> NOT .

    TRUE            reduce using rule 62 (OL -> NOT .)
    FALSE           reduce using rule 62 (OL -> NOT .)
    OPENPAR         reduce using rule 62 (OL -> NOT .)


state 107

    (63) O -> Ex GREATHER Ex .

    CLOSINGPAR      reduce using rule 63 (O -> Ex GREATHER Ex .)


state 108

    (64) O -> Ex GREATHEREQUAL Ex .

    CLOSINGPAR      reduce using rule 64 (O -> Ex GREATHEREQUAL Ex .)


state 109

    (65) O -> Ex SMALLER Ex .

    CLOSINGPAR      reduce using rule 65 (O -> Ex SMALLER Ex .)


state 110

    (66) O -> Ex SMALLEREQUAL Ex .

    CLOSINGPAR      reduce using rule 66 (O -> Ex SMALLEREQUAL Ex .)


state 111

    (67) O -> Ex NOTEQUAL Ex .

    CLOSINGPAR      reduce using rule 67 (O -> Ex NOTEQUAL Ex .)


state 112

    (68) O -> Ex EQUALTO Ex .

    CLOSINGPAR      reduce using rule 68 (O -> Ex EQUALTO Ex .)


state 113

    (69) O -> Ex error Ex .

    CLOSINGPAR      reduce using rule 69 (O -> Ex error Ex .)


state 114

    (19) E -> FOR ID EQUALS EA TO . Ex F NEXT ID
    (37) Ex -> . EA
    (38) Ex -> . ES
    (39) Ex -> . EL
    (40) Ex -> . ID
    (42) EA -> . EA PLUS P
    (43) EA -> . EA MINUS P
    (44) EA -> . P
    (41) ES -> . WORDVAL
    (56) EL -> . TRUE
    (57) EL -> . FALSE
    (58) EL -> . OPENPAR O CLOSINGPAR
    (59) EL -> . OPENPAR O CLOSINGPAR OL EL
    (45) P -> . P MULTIPLY N
    (46) P -> . P DIVIDE N
    (47) P -> . N
    (48) N -> . cte saveID
    (49) N -> . ID saveID
    (50) N -> . OPENPAR EA CLOSINGPAR
    (51) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (52) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (54) cte -> . INTVAL
    (55) cte -> . FLOATVAL

    ID              shift and go to state 40
    WORDVAL         shift and go to state 35
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    OPENPAR         shift and go to state 42
    INTVAL          shift and go to state 45
    FLOATVAL        shift and go to state 46

    EA                             shift and go to state 37
    Ex                             shift and go to state 129
    ES                             shift and go to state 38
    EL                             shift and go to state 39
    P                              shift and go to state 41
    N                              shift and go to state 43
    cte                            shift and go to state 44

state 115

    (50) N -> OPENPAR EA . CLOSINGPAR
    (42) EA -> EA . PLUS P
    (43) EA -> EA . MINUS P

    CLOSINGPAR      shift and go to state 93
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60


state 116

    (20) E -> WHILE while_first_conditional EL DO while_second_conditional . F WEND while_final_conditional
    (14) F -> . E F
    (15) F -> . empty
    (16) E -> . LET setType Idv EQUALS Ex
    (17) E -> . DIM setType Idv AS T Arr
    (18) E -> . IF EL THEN first_conditional F Esf EIF final_conditional
    (19) E -> . FOR ID EQUALS EA TO Ex F NEXT ID
    (20) E -> . WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional
    (21) E -> . GOSUB ID
    (22) E -> . INPUT ES COMA IDEx
    (23) E -> . PRINT Ex
    (70) empty -> .

    LET             shift and go to state 10
    DIM             shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    GOSUB           shift and go to state 15
    INPUT           shift and go to state 16
    PRINT           shift and go to state 17
    WEND            reduce using rule 70 (empty -> .)

    F                              shift and go to state 130
    E                              shift and go to state 9
    empty                          shift and go to state 24

state 117

    (36) IDEx -> ID OPENBRACKET . setType Idv CLOSINGBRACKET
    (34) setType -> .

    ID              reduce using rule 34 (setType -> .)

    setType                        shift and go to state 131

state 118

    (51) N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .

    MULTIPLY        reduce using rule 51 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    DIVIDE          reduce using rule 51 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    PLUS            reduce using rule 51 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    MINUS           reduce using rule 51 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    LET             reduce using rule 51 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    DIM             reduce using rule 51 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    IF              reduce using rule 51 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    FOR             reduce using rule 51 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    WHILE           reduce using rule 51 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    GOSUB           reduce using rule 51 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    INPUT           reduce using rule 51 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    PRINT           reduce using rule 51 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    SUBPROCEDURE    reduce using rule 51 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    END             reduce using rule 51 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    RETURN          reduce using rule 51 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    ELSE            reduce using rule 51 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    EIF             reduce using rule 51 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    WEND            reduce using rule 51 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    NEXT            reduce using rule 51 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    GREATHER        reduce using rule 51 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    GREATHEREQUAL   reduce using rule 51 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    SMALLER         reduce using rule 51 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    SMALLEREQUAL    reduce using rule 51 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    NOTEQUAL        reduce using rule 51 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    EQUALTO         reduce using rule 51 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    error           reduce using rule 51 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    CLOSINGPAR      reduce using rule 51 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    TO              reduce using rule 51 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)
    CLOSINGBRACKET  reduce using rule 51 (N -> ID OPENBRACKET INTVAL CLOSINGBRACKET .)


state 119

    (52) N -> ID OPENBRACKET setType Idv . CLOSINGBRACKET

    CLOSINGBRACKET  shift and go to state 132


state 120

    (2) V -> DIM setType Idv AS T Arr .

    LET             reduce using rule 2 (V -> DIM setType Idv AS T Arr .)
    DIM             reduce using rule 2 (V -> DIM setType Idv AS T Arr .)
    IF              reduce using rule 2 (V -> DIM setType Idv AS T Arr .)
    FOR             reduce using rule 2 (V -> DIM setType Idv AS T Arr .)
    WHILE           reduce using rule 2 (V -> DIM setType Idv AS T Arr .)
    GOSUB           reduce using rule 2 (V -> DIM setType Idv AS T Arr .)
    INPUT           reduce using rule 2 (V -> DIM setType Idv AS T Arr .)
    PRINT           reduce using rule 2 (V -> DIM setType Idv AS T Arr .)
    SUBPROCEDURE    reduce using rule 2 (V -> DIM setType Idv AS T Arr .)
    END             reduce using rule 2 (V -> DIM setType Idv AS T Arr .)


state 121

    (4) Arr -> OPENBRACKET . EA CLOSINGBRACKET Arr
    (5) Arr -> OPENBRACKET . ID CLOSINGBRACKET Arr
    (42) EA -> . EA PLUS P
    (43) EA -> . EA MINUS P
    (44) EA -> . P
    (45) P -> . P MULTIPLY N
    (46) P -> . P DIVIDE N
    (47) P -> . N
    (48) N -> . cte saveID
    (49) N -> . ID saveID
    (50) N -> . OPENPAR EA CLOSINGPAR
    (51) N -> . ID OPENBRACKET INTVAL CLOSINGBRACKET
    (52) N -> . ID OPENBRACKET setType Idv CLOSINGBRACKET
    (54) cte -> . INTVAL
    (55) cte -> . FLOATVAL

    ID              shift and go to state 134
    OPENPAR         shift and go to state 83
    INTVAL          shift and go to state 45
    FLOATVAL        shift and go to state 46

    EA                             shift and go to state 133
    P                              shift and go to state 41
    N                              shift and go to state 43
    cte                            shift and go to state 44

state 122

    (6) Arr -> empty .

    LET             reduce using rule 6 (Arr -> empty .)
    DIM             reduce using rule 6 (Arr -> empty .)
    IF              reduce using rule 6 (Arr -> empty .)
    FOR             reduce using rule 6 (Arr -> empty .)
    WHILE           reduce using rule 6 (Arr -> empty .)
    GOSUB           reduce using rule 6 (Arr -> empty .)
    INPUT           reduce using rule 6 (Arr -> empty .)
    PRINT           reduce using rule 6 (Arr -> empty .)
    SUBPROCEDURE    reduce using rule 6 (Arr -> empty .)
    END             reduce using rule 6 (Arr -> empty .)
    RETURN          reduce using rule 6 (Arr -> empty .)
    ELSE            reduce using rule 6 (Arr -> empty .)
    EIF             reduce using rule 6 (Arr -> empty .)
    WEND            reduce using rule 6 (Arr -> empty .)
    NEXT            reduce using rule 6 (Arr -> empty .)


state 123

    (10) S -> SUBPROCEDURE ID TWOPOINTS M RETURN . S
    (10) S -> . SUBPROCEDURE ID TWOPOINTS M RETURN S
    (11) S -> . empty
    (70) empty -> .

    SUBPROCEDURE    shift and go to state 20
    END             reduce using rule 70 (empty -> .)

    S                              shift and go to state 135
    empty                          shift and go to state 21

state 124

    (17) E -> DIM setType Idv AS T Arr .

    LET             reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    DIM             reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    IF              reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    FOR             reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    WHILE           reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    GOSUB           reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    INPUT           reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    PRINT           reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    SUBPROCEDURE    reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    END             reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    RETURN          reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    ELSE            reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    EIF             reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    WEND            reduce using rule 17 (E -> DIM setType Idv AS T Arr .)
    NEXT            reduce using rule 17 (E -> DIM setType Idv AS T Arr .)


state 125

    (18) E -> IF EL THEN first_conditional F Esf . EIF final_conditional

    EIF             shift and go to state 136


state 126

    (30) Esf -> ELSE . second_conditional F
    (28) second_conditional -> .

    LET             reduce using rule 28 (second_conditional -> .)
    DIM             reduce using rule 28 (second_conditional -> .)
    IF              reduce using rule 28 (second_conditional -> .)
    FOR             reduce using rule 28 (second_conditional -> .)
    WHILE           reduce using rule 28 (second_conditional -> .)
    GOSUB           reduce using rule 28 (second_conditional -> .)
    INPUT           reduce using rule 28 (second_conditional -> .)
    PRINT           reduce using rule 28 (second_conditional -> .)
    EIF             reduce using rule 28 (second_conditional -> .)

    second_conditional             shift and go to state 137

state 127

    (31) Esf -> empty .

    EIF             reduce using rule 31 (Esf -> empty .)


state 128

    (59) EL -> OPENPAR O CLOSINGPAR OL EL .

    THEN            reduce using rule 59 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    LET             reduce using rule 59 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    DIM             reduce using rule 59 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    IF              reduce using rule 59 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    FOR             reduce using rule 59 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    WHILE           reduce using rule 59 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    GOSUB           reduce using rule 59 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    INPUT           reduce using rule 59 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    PRINT           reduce using rule 59 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    SUBPROCEDURE    reduce using rule 59 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    END             reduce using rule 59 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    RETURN          reduce using rule 59 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    ELSE            reduce using rule 59 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    EIF             reduce using rule 59 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    WEND            reduce using rule 59 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    NEXT            reduce using rule 59 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    GREATHER        reduce using rule 59 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    GREATHEREQUAL   reduce using rule 59 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    SMALLER         reduce using rule 59 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    SMALLEREQUAL    reduce using rule 59 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    NOTEQUAL        reduce using rule 59 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    EQUALTO         reduce using rule 59 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    error           reduce using rule 59 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    DO              reduce using rule 59 (EL -> OPENPAR O CLOSINGPAR OL EL .)
    CLOSINGPAR      reduce using rule 59 (EL -> OPENPAR O CLOSINGPAR OL EL .)


state 129

    (19) E -> FOR ID EQUALS EA TO Ex . F NEXT ID
    (14) F -> . E F
    (15) F -> . empty
    (16) E -> . LET setType Idv EQUALS Ex
    (17) E -> . DIM setType Idv AS T Arr
    (18) E -> . IF EL THEN first_conditional F Esf EIF final_conditional
    (19) E -> . FOR ID EQUALS EA TO Ex F NEXT ID
    (20) E -> . WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional
    (21) E -> . GOSUB ID
    (22) E -> . INPUT ES COMA IDEx
    (23) E -> . PRINT Ex
    (70) empty -> .

    LET             shift and go to state 10
    DIM             shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    GOSUB           shift and go to state 15
    INPUT           shift and go to state 16
    PRINT           shift and go to state 17
    NEXT            reduce using rule 70 (empty -> .)

    F                              shift and go to state 138
    E                              shift and go to state 9
    empty                          shift and go to state 24

state 130

    (20) E -> WHILE while_first_conditional EL DO while_second_conditional F . WEND while_final_conditional

    WEND            shift and go to state 139


state 131

    (36) IDEx -> ID OPENBRACKET setType . Idv CLOSINGBRACKET
    (32) Idv -> . ID COMA Idv
    (33) Idv -> . ID

    ID              shift and go to state 48

    Idv                            shift and go to state 140

state 132

    (52) N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .

    MULTIPLY        reduce using rule 52 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    DIVIDE          reduce using rule 52 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    PLUS            reduce using rule 52 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    MINUS           reduce using rule 52 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    LET             reduce using rule 52 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    DIM             reduce using rule 52 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    IF              reduce using rule 52 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    FOR             reduce using rule 52 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    WHILE           reduce using rule 52 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    GOSUB           reduce using rule 52 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    INPUT           reduce using rule 52 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    PRINT           reduce using rule 52 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    SUBPROCEDURE    reduce using rule 52 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    END             reduce using rule 52 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    RETURN          reduce using rule 52 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    ELSE            reduce using rule 52 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    EIF             reduce using rule 52 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    WEND            reduce using rule 52 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    NEXT            reduce using rule 52 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    GREATHER        reduce using rule 52 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    GREATHEREQUAL   reduce using rule 52 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    SMALLER         reduce using rule 52 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    SMALLEREQUAL    reduce using rule 52 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    NOTEQUAL        reduce using rule 52 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    EQUALTO         reduce using rule 52 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    error           reduce using rule 52 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    CLOSINGPAR      reduce using rule 52 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    TO              reduce using rule 52 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    CLOSINGBRACKET  reduce using rule 52 (N -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)


state 133

    (4) Arr -> OPENBRACKET EA . CLOSINGBRACKET Arr
    (42) EA -> EA . PLUS P
    (43) EA -> EA . MINUS P

    CLOSINGBRACKET  shift and go to state 141
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60


state 134

    (5) Arr -> OPENBRACKET ID . CLOSINGBRACKET Arr
    (49) N -> ID . saveID
    (51) N -> ID . OPENBRACKET INTVAL CLOSINGBRACKET
    (52) N -> ID . OPENBRACKET setType Idv CLOSINGBRACKET
    (53) saveID -> .

  ! shift/reduce conflict for CLOSINGBRACKET resolved as shift
    CLOSINGBRACKET  shift and go to state 142
    OPENBRACKET     shift and go to state 62
    MULTIPLY        reduce using rule 53 (saveID -> .)
    DIVIDE          reduce using rule 53 (saveID -> .)
    PLUS            reduce using rule 53 (saveID -> .)
    MINUS           reduce using rule 53 (saveID -> .)

  ! CLOSINGBRACKET  [ reduce using rule 53 (saveID -> .) ]

    saveID                         shift and go to state 61

state 135

    (10) S -> SUBPROCEDURE ID TWOPOINTS M RETURN S .

    END             reduce using rule 10 (S -> SUBPROCEDURE ID TWOPOINTS M RETURN S .)


state 136

    (18) E -> IF EL THEN first_conditional F Esf EIF . final_conditional
    (29) final_conditional -> .

    LET             reduce using rule 29 (final_conditional -> .)
    DIM             reduce using rule 29 (final_conditional -> .)
    IF              reduce using rule 29 (final_conditional -> .)
    FOR             reduce using rule 29 (final_conditional -> .)
    WHILE           reduce using rule 29 (final_conditional -> .)
    GOSUB           reduce using rule 29 (final_conditional -> .)
    INPUT           reduce using rule 29 (final_conditional -> .)
    PRINT           reduce using rule 29 (final_conditional -> .)
    SUBPROCEDURE    reduce using rule 29 (final_conditional -> .)
    END             reduce using rule 29 (final_conditional -> .)
    RETURN          reduce using rule 29 (final_conditional -> .)
    ELSE            reduce using rule 29 (final_conditional -> .)
    EIF             reduce using rule 29 (final_conditional -> .)
    WEND            reduce using rule 29 (final_conditional -> .)
    NEXT            reduce using rule 29 (final_conditional -> .)

    final_conditional              shift and go to state 143

state 137

    (30) Esf -> ELSE second_conditional . F
    (14) F -> . E F
    (15) F -> . empty
    (16) E -> . LET setType Idv EQUALS Ex
    (17) E -> . DIM setType Idv AS T Arr
    (18) E -> . IF EL THEN first_conditional F Esf EIF final_conditional
    (19) E -> . FOR ID EQUALS EA TO Ex F NEXT ID
    (20) E -> . WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional
    (21) E -> . GOSUB ID
    (22) E -> . INPUT ES COMA IDEx
    (23) E -> . PRINT Ex
    (70) empty -> .

    LET             shift and go to state 10
    DIM             shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    GOSUB           shift and go to state 15
    INPUT           shift and go to state 16
    PRINT           shift and go to state 17
    EIF             reduce using rule 70 (empty -> .)

    F                              shift and go to state 144
    E                              shift and go to state 9
    empty                          shift and go to state 24

state 138

    (19) E -> FOR ID EQUALS EA TO Ex F . NEXT ID

    NEXT            shift and go to state 145


state 139

    (20) E -> WHILE while_first_conditional EL DO while_second_conditional F WEND . while_final_conditional
    (26) while_final_conditional -> .

    LET             reduce using rule 26 (while_final_conditional -> .)
    DIM             reduce using rule 26 (while_final_conditional -> .)
    IF              reduce using rule 26 (while_final_conditional -> .)
    FOR             reduce using rule 26 (while_final_conditional -> .)
    WHILE           reduce using rule 26 (while_final_conditional -> .)
    GOSUB           reduce using rule 26 (while_final_conditional -> .)
    INPUT           reduce using rule 26 (while_final_conditional -> .)
    PRINT           reduce using rule 26 (while_final_conditional -> .)
    SUBPROCEDURE    reduce using rule 26 (while_final_conditional -> .)
    END             reduce using rule 26 (while_final_conditional -> .)
    RETURN          reduce using rule 26 (while_final_conditional -> .)
    ELSE            reduce using rule 26 (while_final_conditional -> .)
    EIF             reduce using rule 26 (while_final_conditional -> .)
    WEND            reduce using rule 26 (while_final_conditional -> .)
    NEXT            reduce using rule 26 (while_final_conditional -> .)

    while_final_conditional        shift and go to state 146

state 140

    (36) IDEx -> ID OPENBRACKET setType Idv . CLOSINGBRACKET

    CLOSINGBRACKET  shift and go to state 147


state 141

    (4) Arr -> OPENBRACKET EA CLOSINGBRACKET . Arr
    (4) Arr -> . OPENBRACKET EA CLOSINGBRACKET Arr
    (5) Arr -> . OPENBRACKET ID CLOSINGBRACKET Arr
    (6) Arr -> . empty
    (70) empty -> .

    OPENBRACKET     shift and go to state 121
    LET             reduce using rule 70 (empty -> .)
    DIM             reduce using rule 70 (empty -> .)
    IF              reduce using rule 70 (empty -> .)
    FOR             reduce using rule 70 (empty -> .)
    WHILE           reduce using rule 70 (empty -> .)
    GOSUB           reduce using rule 70 (empty -> .)
    INPUT           reduce using rule 70 (empty -> .)
    PRINT           reduce using rule 70 (empty -> .)
    SUBPROCEDURE    reduce using rule 70 (empty -> .)
    END             reduce using rule 70 (empty -> .)
    RETURN          reduce using rule 70 (empty -> .)
    ELSE            reduce using rule 70 (empty -> .)
    EIF             reduce using rule 70 (empty -> .)
    WEND            reduce using rule 70 (empty -> .)
    NEXT            reduce using rule 70 (empty -> .)

    Arr                            shift and go to state 148
    empty                          shift and go to state 122

state 142

    (5) Arr -> OPENBRACKET ID CLOSINGBRACKET . Arr
    (4) Arr -> . OPENBRACKET EA CLOSINGBRACKET Arr
    (5) Arr -> . OPENBRACKET ID CLOSINGBRACKET Arr
    (6) Arr -> . empty
    (70) empty -> .

    OPENBRACKET     shift and go to state 121
    LET             reduce using rule 70 (empty -> .)
    DIM             reduce using rule 70 (empty -> .)
    IF              reduce using rule 70 (empty -> .)
    FOR             reduce using rule 70 (empty -> .)
    WHILE           reduce using rule 70 (empty -> .)
    GOSUB           reduce using rule 70 (empty -> .)
    INPUT           reduce using rule 70 (empty -> .)
    PRINT           reduce using rule 70 (empty -> .)
    SUBPROCEDURE    reduce using rule 70 (empty -> .)
    END             reduce using rule 70 (empty -> .)
    RETURN          reduce using rule 70 (empty -> .)
    ELSE            reduce using rule 70 (empty -> .)
    EIF             reduce using rule 70 (empty -> .)
    WEND            reduce using rule 70 (empty -> .)
    NEXT            reduce using rule 70 (empty -> .)

    Arr                            shift and go to state 149
    empty                          shift and go to state 122

state 143

    (18) E -> IF EL THEN first_conditional F Esf EIF final_conditional .

    LET             reduce using rule 18 (E -> IF EL THEN first_conditional F Esf EIF final_conditional .)
    DIM             reduce using rule 18 (E -> IF EL THEN first_conditional F Esf EIF final_conditional .)
    IF              reduce using rule 18 (E -> IF EL THEN first_conditional F Esf EIF final_conditional .)
    FOR             reduce using rule 18 (E -> IF EL THEN first_conditional F Esf EIF final_conditional .)
    WHILE           reduce using rule 18 (E -> IF EL THEN first_conditional F Esf EIF final_conditional .)
    GOSUB           reduce using rule 18 (E -> IF EL THEN first_conditional F Esf EIF final_conditional .)
    INPUT           reduce using rule 18 (E -> IF EL THEN first_conditional F Esf EIF final_conditional .)
    PRINT           reduce using rule 18 (E -> IF EL THEN first_conditional F Esf EIF final_conditional .)
    SUBPROCEDURE    reduce using rule 18 (E -> IF EL THEN first_conditional F Esf EIF final_conditional .)
    END             reduce using rule 18 (E -> IF EL THEN first_conditional F Esf EIF final_conditional .)
    RETURN          reduce using rule 18 (E -> IF EL THEN first_conditional F Esf EIF final_conditional .)
    ELSE            reduce using rule 18 (E -> IF EL THEN first_conditional F Esf EIF final_conditional .)
    EIF             reduce using rule 18 (E -> IF EL THEN first_conditional F Esf EIF final_conditional .)
    WEND            reduce using rule 18 (E -> IF EL THEN first_conditional F Esf EIF final_conditional .)
    NEXT            reduce using rule 18 (E -> IF EL THEN first_conditional F Esf EIF final_conditional .)


state 144

    (30) Esf -> ELSE second_conditional F .

    EIF             reduce using rule 30 (Esf -> ELSE second_conditional F .)


state 145

    (19) E -> FOR ID EQUALS EA TO Ex F NEXT . ID

    ID              shift and go to state 150


state 146

    (20) E -> WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional .

    LET             reduce using rule 20 (E -> WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional .)
    DIM             reduce using rule 20 (E -> WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional .)
    IF              reduce using rule 20 (E -> WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional .)
    FOR             reduce using rule 20 (E -> WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional .)
    WHILE           reduce using rule 20 (E -> WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional .)
    GOSUB           reduce using rule 20 (E -> WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional .)
    INPUT           reduce using rule 20 (E -> WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional .)
    PRINT           reduce using rule 20 (E -> WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional .)
    SUBPROCEDURE    reduce using rule 20 (E -> WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional .)
    END             reduce using rule 20 (E -> WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional .)
    RETURN          reduce using rule 20 (E -> WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional .)
    ELSE            reduce using rule 20 (E -> WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional .)
    EIF             reduce using rule 20 (E -> WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional .)
    WEND            reduce using rule 20 (E -> WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional .)
    NEXT            reduce using rule 20 (E -> WHILE while_first_conditional EL DO while_second_conditional F WEND while_final_conditional .)


state 147

    (36) IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .

    LET             reduce using rule 36 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    DIM             reduce using rule 36 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    IF              reduce using rule 36 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    FOR             reduce using rule 36 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    WHILE           reduce using rule 36 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    GOSUB           reduce using rule 36 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    INPUT           reduce using rule 36 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    PRINT           reduce using rule 36 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    SUBPROCEDURE    reduce using rule 36 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    END             reduce using rule 36 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    RETURN          reduce using rule 36 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    ELSE            reduce using rule 36 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    EIF             reduce using rule 36 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    WEND            reduce using rule 36 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)
    NEXT            reduce using rule 36 (IDEx -> ID OPENBRACKET setType Idv CLOSINGBRACKET .)


state 148

    (4) Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .

    LET             reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    DIM             reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    IF              reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    FOR             reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    WHILE           reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    GOSUB           reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    INPUT           reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    PRINT           reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    SUBPROCEDURE    reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    END             reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    RETURN          reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    ELSE            reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    EIF             reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    WEND            reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)
    NEXT            reduce using rule 4 (Arr -> OPENBRACKET EA CLOSINGBRACKET Arr .)


state 149

    (5) Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .

    LET             reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    DIM             reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    IF              reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    FOR             reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    WHILE           reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    GOSUB           reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    INPUT           reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    PRINT           reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    SUBPROCEDURE    reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    END             reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    RETURN          reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    ELSE            reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    EIF             reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    WEND            reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)
    NEXT            reduce using rule 5 (Arr -> OPENBRACKET ID CLOSINGBRACKET Arr .)


state 150

    (19) E -> FOR ID EQUALS EA TO Ex F NEXT ID .

    LET             reduce using rule 19 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    DIM             reduce using rule 19 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    IF              reduce using rule 19 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    FOR             reduce using rule 19 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    WHILE           reduce using rule 19 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    GOSUB           reduce using rule 19 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    INPUT           reduce using rule 19 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    PRINT           reduce using rule 19 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    SUBPROCEDURE    reduce using rule 19 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    END             reduce using rule 19 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    RETURN          reduce using rule 19 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    ELSE            reduce using rule 19 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    EIF             reduce using rule 19 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    WEND            reduce using rule 19 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)
    NEXT            reduce using rule 19 (E -> FOR ID EQUALS EA TO Ex F NEXT ID .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for DIM in state 2 resolved as shift
WARNING: shift/reduce conflict for LET in state 3 resolved as shift
WARNING: shift/reduce conflict for DIM in state 3 resolved as shift
WARNING: shift/reduce conflict for IF in state 3 resolved as shift
WARNING: shift/reduce conflict for FOR in state 3 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 3 resolved as shift
WARNING: shift/reduce conflict for GOSUB in state 3 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 3 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 3 resolved as shift
WARNING: shift/reduce conflict for LET in state 7 resolved as shift
WARNING: shift/reduce conflict for DIM in state 7 resolved as shift
WARNING: shift/reduce conflict for IF in state 7 resolved as shift
WARNING: shift/reduce conflict for FOR in state 7 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 7 resolved as shift
WARNING: shift/reduce conflict for GOSUB in state 7 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 7 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 7 resolved as shift
WARNING: shift/reduce conflict for LET in state 9 resolved as shift
WARNING: shift/reduce conflict for DIM in state 9 resolved as shift
WARNING: shift/reduce conflict for IF in state 9 resolved as shift
WARNING: shift/reduce conflict for FOR in state 9 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 9 resolved as shift
WARNING: shift/reduce conflict for GOSUB in state 9 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 9 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 9 resolved as shift
WARNING: shift/reduce conflict for LET in state 69 resolved as shift
WARNING: shift/reduce conflict for DIM in state 69 resolved as shift
WARNING: shift/reduce conflict for IF in state 69 resolved as shift
WARNING: shift/reduce conflict for FOR in state 69 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 69 resolved as shift
WARNING: shift/reduce conflict for GOSUB in state 69 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 69 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 69 resolved as shift
WARNING: shift/reduce conflict for CLOSINGBRACKET in state 134 resolved as shift
WARNING: reduce/reduce conflict in state 8 resolved using rule (M -> empty)
WARNING: rejected rule (F -> empty) in state 8
WARNING: reduce/reduce conflict in state 40 resolved using rule (Ex -> ID)
WARNING: rejected rule (saveID -> <empty>) in state 40
